{"ast":null,"code":"// index.ts\nimport earcut from \"earcut\";\nimport { polygon } from \"@turf/helpers\";\nfunction tesselate(poly) {\n  if (!poly.geometry || poly.geometry.type !== \"Polygon\" && poly.geometry.type !== \"MultiPolygon\") {\n    throw new Error(\"input must be a Polygon or MultiPolygon\");\n  }\n  const fc = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  if (poly.geometry.type === \"Polygon\") {\n    fc.features = processPolygon(poly.geometry.coordinates);\n  } else {\n    poly.geometry.coordinates.forEach(function (coordinates) {\n      fc.features = fc.features.concat(processPolygon(coordinates));\n    });\n  }\n  return fc;\n}\nfunction processPolygon(coordinates) {\n  const data = flattenCoords(coordinates);\n  const dim = 2;\n  const result = earcut(data.vertices, data.holes, dim);\n  const features = [];\n  const vertices = [];\n  result.forEach(function (vert, i2) {\n    const index = result[i2];\n    vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);\n  });\n  for (var i = 0; i < vertices.length; i += 3) {\n    const coords = vertices.slice(i, i + 3);\n    coords.push(vertices[i]);\n    features.push(polygon([coords]));\n  }\n  return features;\n}\nfunction flattenCoords(data) {\n  const dim = data[0][0].length,\n    result = {\n      vertices: [],\n      holes: [],\n      dimensions: dim\n    };\n  let holeIndex = 0;\n  for (let i = 0; i < data.length; i++) {\n    for (let j = 0; j < data[i].length; j++) {\n      for (let d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n    }\n    if (i > 0) {\n      holeIndex += data[i - 1].length;\n      result.holes.push(holeIndex);\n    }\n  }\n  return result;\n}\nvar turf_tesselate_default = tesselate;\nexport { turf_tesselate_default as default, tesselate };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}