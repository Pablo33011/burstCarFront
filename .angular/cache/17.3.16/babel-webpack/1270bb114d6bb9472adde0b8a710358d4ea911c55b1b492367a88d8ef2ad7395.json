{"ast":null,"code":"// index.ts\nimport { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { booleanPointOnLine } from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport equal from \"fast-deep-equal\";\nfunction lineOverlap(line1, line2, options = {}) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance || 0;\n  var features = [];\n  var tree = rbush();\n  const line = lineSegment(line1);\n  tree.load(line);\n  var overlapSegment;\n  let additionalSegments = [];\n  segmentEach(line2, function (segment) {\n    var doesOverlaps = false;\n    if (!segment) {\n      return;\n    }\n    featureEach(tree.search(segment), function (match) {\n      if (doesOverlaps === false) {\n        var coordsSegment = getCoords(segment).sort();\n        var coordsMatch = getCoords(match).sort();\n        if (equal(coordsSegment, coordsMatch)) {\n          doesOverlaps = true;\n          if (overlapSegment) {\n            overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;\n          } else overlapSegment = segment;\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) : nearestPointOnLine(match, coordsSegment[0]).properties.dist <= tolerance && nearestPointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {\n          doesOverlaps = true;\n          if (overlapSegment) {\n            overlapSegment = concatSegment(overlapSegment, segment) || overlapSegment;\n          } else overlapSegment = segment;\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance && nearestPointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {\n          if (overlapSegment) {\n            const combinedSegment = concatSegment(overlapSegment, match);\n            if (combinedSegment) {\n              overlapSegment = combinedSegment;\n            } else {\n              additionalSegments.push(match);\n            }\n          } else overlapSegment = match;\n        }\n      }\n    });\n    if (doesOverlaps === false && overlapSegment) {\n      features.push(overlapSegment);\n      if (additionalSegments.length) {\n        features = features.concat(additionalSegments);\n        additionalSegments = [];\n      }\n      overlapSegment = void 0;\n    }\n  });\n  if (overlapSegment) features.push(overlapSegment);\n  return featureCollection(features);\n}\nfunction concatSegment(line, segment) {\n  var coords = getCoords(segment);\n  var lineCoords = getCoords(line);\n  var start = lineCoords[0];\n  var end = lineCoords[lineCoords.length - 1];\n  var geom = line.geometry.coordinates;\n  if (equal(coords[0], start)) geom.unshift(coords[1]);else if (equal(coords[0], end)) geom.push(coords[1]);else if (equal(coords[1], start)) geom.unshift(coords[0]);else if (equal(coords[1], end)) geom.push(coords[0]);else return;\n  return line;\n}\nvar turf_line_overlap_default = lineOverlap;\nexport { turf_line_overlap_default as default, lineOverlap };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}