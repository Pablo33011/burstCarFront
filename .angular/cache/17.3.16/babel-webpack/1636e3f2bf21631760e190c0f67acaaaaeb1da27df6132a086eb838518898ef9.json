{"ast":null,"code":"class TinyQueue {\n  constructor(data = [], compare = defaultCompare) {\n    this.data = data;\n    this.length = this.data.length;\n    this.compare = compare;\n    if (this.length > 0) {\n      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n  }\n  push(item) {\n    this.data.push(item);\n    this.length++;\n    this._up(this.length - 1);\n  }\n  pop() {\n    if (this.length === 0) return undefined;\n    const top = this.data[0];\n    const bottom = this.data.pop();\n    this.length--;\n    if (this.length > 0) {\n      this.data[0] = bottom;\n      this._down(0);\n    }\n    return top;\n  }\n  peek() {\n    return this.data[0];\n  }\n  _up(pos) {\n    const {\n      data,\n      compare\n    } = this;\n    const item = data[pos];\n    while (pos > 0) {\n      const parent = pos - 1 >> 1;\n      const current = data[parent];\n      if (compare(item, current) >= 0) break;\n      data[pos] = current;\n      pos = parent;\n    }\n    data[pos] = item;\n  }\n  _down(pos) {\n    const {\n      data,\n      compare\n    } = this;\n    const halfLength = this.length >> 1;\n    const item = data[pos];\n    while (pos < halfLength) {\n      let left = (pos << 1) + 1;\n      let best = data[left];\n      const right = left + 1;\n      if (right < this.length && compare(data[right], best) < 0) {\n        left = right;\n        best = data[right];\n      }\n      if (compare(best, item) >= 0) break;\n      data[pos] = best;\n      pos = left;\n    }\n    data[pos] = item;\n  }\n}\nfunction defaultCompare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction checkWhichEventIsLeft(e1, e2) {\n  if (e1.p.x > e2.p.x) return 1;\n  if (e1.p.x < e2.p.x) return -1;\n  if (e1.p.y !== e2.p.y) return e1.p.y > e2.p.y ? 1 : -1;\n  return 1;\n}\nfunction checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {\n  if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x) return 1;\n  if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x) return -1;\n  if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y) return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1;\n  return 1;\n}\nclass Event {\n  constructor(p, featureId, ringId, eventId) {\n    this.p = {\n      x: p[0],\n      y: p[1]\n    };\n    this.featureId = featureId;\n    this.ringId = ringId;\n    this.eventId = eventId;\n    this.otherEvent = null;\n    this.isLeftEndpoint = null;\n  }\n  isSamePoint(eventToCheck) {\n    return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y;\n  }\n}\nfunction fillEventQueue(geojson, eventQueue) {\n  if (geojson.type === 'FeatureCollection') {\n    const features = geojson.features;\n    for (let i = 0; i < features.length; i++) {\n      processFeature(features[i], eventQueue);\n    }\n  } else {\n    processFeature(geojson, eventQueue);\n  }\n}\nlet featureId = 0;\nlet ringId = 0;\nlet eventId = 0;\nfunction processFeature(featureOrGeometry, eventQueue) {\n  const geom = featureOrGeometry.type === 'Feature' ? featureOrGeometry.geometry : featureOrGeometry;\n  let coords = geom.coordinates;\n  // standardise the input\n  if (geom.type === 'Polygon' || geom.type === 'MultiLineString') coords = [coords];\n  if (geom.type === 'LineString') coords = [[coords]];\n  for (let i = 0; i < coords.length; i++) {\n    for (let ii = 0; ii < coords[i].length; ii++) {\n      let currentP = coords[i][ii][0];\n      let nextP = null;\n      ringId = ringId + 1;\n      for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {\n        nextP = coords[i][ii][iii + 1];\n        const e1 = new Event(currentP, featureId, ringId, eventId);\n        const e2 = new Event(nextP, featureId, ringId, eventId + 1);\n        e1.otherEvent = e2;\n        e2.otherEvent = e1;\n        if (checkWhichEventIsLeft(e1, e2) > 0) {\n          e2.isLeftEndpoint = true;\n          e1.isLeftEndpoint = false;\n        } else {\n          e1.isLeftEndpoint = true;\n          e2.isLeftEndpoint = false;\n        }\n        eventQueue.push(e1);\n        eventQueue.push(e2);\n        currentP = nextP;\n        eventId = eventId + 1;\n      }\n    }\n  }\n  featureId = featureId + 1;\n}\nclass Segment {\n  constructor(event) {\n    this.leftSweepEvent = event;\n    this.rightSweepEvent = event.otherEvent;\n  }\n}\nfunction testSegmentIntersect(seg1, seg2) {\n  if (seg1 === null || seg2 === null) return false;\n  if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId && (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent))) return false;\n  const x1 = seg1.leftSweepEvent.p.x;\n  const y1 = seg1.leftSweepEvent.p.y;\n  const x2 = seg1.rightSweepEvent.p.x;\n  const y2 = seg1.rightSweepEvent.p.y;\n  const x3 = seg2.leftSweepEvent.p.x;\n  const y3 = seg2.leftSweepEvent.p.y;\n  const x4 = seg2.rightSweepEvent.p.x;\n  const y4 = seg2.rightSweepEvent.p.y;\n  const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n  const numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n  const numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n  if (denom === 0) {\n    if (numeA === 0 && numeB === 0) return false;\n    return false;\n  }\n  const uA = numeA / denom;\n  const uB = numeB / denom;\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n    const x = x1 + uA * (x2 - x1);\n    const y = y1 + uA * (y2 - y1);\n    return [x, y];\n  }\n  return false;\n}\n\n// import {debugEventAndSegments, debugRemovingSegment} from './debug'\n\nfunction runCheck(eventQueue, ignoreSelfIntersections) {\n  ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;\n  const intersectionPoints = [];\n  const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);\n  while (eventQueue.length) {\n    const event = eventQueue.pop();\n    if (event.isLeftEndpoint) {\n      // debugEventAndSegments(event.p, outQueue.data)\n      const segment = new Segment(event);\n      for (let i = 0; i < outQueue.data.length; i++) {\n        const otherSeg = outQueue.data[i];\n        if (ignoreSelfIntersections) {\n          if (otherSeg.leftSweepEvent.featureId === event.featureId) continue;\n        }\n        const intersection = testSegmentIntersect(segment, otherSeg);\n        if (intersection !== false) intersectionPoints.push(intersection);\n      }\n      outQueue.push(segment);\n    } else if (event.isLeftEndpoint === false) {\n      outQueue.pop();\n      // const seg = outQueue.pop()\n      // debugRemovingSegment(event.p, seg)\n    }\n  }\n  return intersectionPoints;\n}\nfunction sweeplineIntersections(geojson, ignoreSelfIntersections) {\n  const eventQueue = new TinyQueue([], checkWhichEventIsLeft);\n  fillEventQueue(geojson, eventQueue);\n  return runCheck(eventQueue, ignoreSelfIntersections);\n}\nexport default sweeplineIntersections;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}