{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nvar _GeojsonEquality = class _GeojsonEquality {\n  constructor(opts) {\n    this.direction = false;\n    this.compareProperties = true;\n    var _a, _b, _c;\n    this.precision = 10 ** -((_a = opts == null ? void 0 : opts.precision) != null ? _a : 17);\n    this.direction = (_b = opts == null ? void 0 : opts.direction) != null ? _b : false;\n    this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;\n  }\n  compare(g1, g2) {\n    if (g1.type !== g2.type) {\n      return false;\n    }\n    if (!sameLength(g1, g2)) {\n      return false;\n    }\n    switch (g1.type) {\n      case \"Point\":\n        return this.compareCoord(g1.coordinates, g2.coordinates);\n      case \"LineString\":\n        return this.compareLine(g1.coordinates, g2.coordinates);\n      case \"Polygon\":\n        return this.comparePolygon(g1, g2);\n      case \"GeometryCollection\":\n        return this.compareGeometryCollection(g1, g2);\n      case \"Feature\":\n        return this.compareFeature(g1, g2);\n      case \"FeatureCollection\":\n        return this.compareFeatureCollection(g1, g2);\n      default:\n        if (g1.type.startsWith(\"Multi\")) {\n          const g1s = explode(g1);\n          const g2s = explode(g2);\n          return g1s.every(g1part => g2s.some(g2part => this.compare(g1part, g2part)));\n        }\n    }\n    return false;\n  }\n  compareCoord(c1, c2) {\n    return c1.length === c2.length && c1.every((c, i) => Math.abs(c - c2[i]) < this.precision);\n  }\n  compareLine(path1, path2, ind = 0, isPoly = false) {\n    if (!sameLength(path1, path2)) {\n      return false;\n    }\n    const p1 = path1;\n    let p2 = path2;\n    if (isPoly && !this.compareCoord(p1[0], p2[0])) {\n      const startIndex = this.fixStartIndex(p2, p1);\n      if (!startIndex) {\n        return false;\n      } else {\n        p2 = startIndex;\n      }\n    }\n    const sameDirection = this.compareCoord(p1[ind], p2[ind]);\n    if (this.direction || sameDirection) {\n      return this.comparePath(p1, p2);\n    } else {\n      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {\n        return this.comparePath(p1.slice().reverse(), p2);\n      }\n      return false;\n    }\n  }\n  fixStartIndex(sourcePath, targetPath) {\n    let correctPath,\n      ind = -1;\n    for (let i = 0; i < sourcePath.length; i++) {\n      if (this.compareCoord(sourcePath[i], targetPath[0])) {\n        ind = i;\n        break;\n      }\n    }\n    if (ind >= 0) {\n      correctPath = [].concat(sourcePath.slice(ind, sourcePath.length), sourcePath.slice(1, ind + 1));\n    }\n    return correctPath;\n  }\n  comparePath(p1, p2) {\n    return p1.every((c, i) => this.compareCoord(c, p2[i]));\n  }\n  comparePolygon(g1, g2) {\n    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {\n      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);\n      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);\n      return holes1.every(h1 => holes2.some(h2 => this.compareLine(h1, h2, 1, true)));\n    }\n    return false;\n  }\n  compareGeometryCollection(g1, g2) {\n    return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]));\n  }\n  compareFeature(g1, g2) {\n    return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);\n  }\n  compareFeatureCollection(g1, g2) {\n    return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i) => this.compare(f, g2.features[i]));\n  }\n  compareBBox(g1, g2) {\n    return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);\n  }\n};\n__name(_GeojsonEquality, \"GeojsonEquality\");\nvar GeojsonEquality = _GeojsonEquality;\nfunction sameLength(g1, g2) {\n  return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;\n}\n__name(sameLength, \"sameLength\");\nfunction explode(g) {\n  return g.coordinates.map(part => ({\n    type: g.type.replace(\"Multi\", \"\"),\n    coordinates: part\n  }));\n}\n__name(explode, \"explode\");\nfunction geojsonEquality(g1, g2, opts) {\n  const eq = new GeojsonEquality(opts);\n  return eq.compare(g1, g2);\n}\n__name(geojsonEquality, \"geojsonEquality\");\nfunction equal(object1, object2) {\n  if (object1 === null && object2 === null) {\n    return true;\n  }\n  if (object1 === null || object2 === null) {\n    return false;\n  }\n  const objKeys1 = Object.keys(object1);\n  const objKeys2 = Object.keys(object2);\n  if (objKeys1.length !== objKeys2.length) return false;\n  for (var key of objKeys1) {\n    const value1 = object1[key];\n    const value2 = object2[key];\n    const isObjects = isObject(value1) && isObject(value2);\n    if (isObjects && !equal(value1, value2) || !isObjects && value1 !== value2) {\n      return false;\n    }\n  }\n  return true;\n}\n__name(equal, \"equal\");\nvar isObject = /* @__PURE__ */__name(object => {\n  return object != null && typeof object === \"object\";\n}, \"isObject\");\nvar geojson_equality_ts_default = GeojsonEquality;\nexport { GeojsonEquality, geojson_equality_ts_default as default, geojsonEquality };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}