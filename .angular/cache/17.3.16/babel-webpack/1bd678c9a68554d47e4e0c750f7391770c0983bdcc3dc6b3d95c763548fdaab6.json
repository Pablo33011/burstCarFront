{"ast":null,"code":"// index.ts\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { clone } from \"@turf/clone\";\nimport { geomEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\n\n// lib/simplify.js\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n  if (prevPoint !== point) newPoints.push(point);\n  return newPoints;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n  var sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n  return points;\n}\n\n// index.ts\nfunction simplify2(geojson, options = {}) {\n  var _a, _b, _c;\n  options = options != null ? options : {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const tolerance = (_a = options.tolerance) != null ? _a : 1;\n  const highQuality = (_b = options.highQuality) != null ? _b : false;\n  const mutate = (_c = options.mutate) != null ? _c : false;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n  if (mutate !== true) geojson = clone(geojson);\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  const type = geometry.type;\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n  cleanCoords(geometry, {\n    mutate: true\n  });\n  if (type !== \"GeometryCollection\") {\n    switch (type) {\n      case \"LineString\":\n        geometry.coordinates = simplify(geometry.coordinates, tolerance, highQuality);\n        break;\n      case \"MultiLineString\":\n        geometry.coordinates = geometry.coordinates.map(lines => simplify(lines, tolerance, highQuality));\n        break;\n      case \"Polygon\":\n        geometry.coordinates = simplifyPolygon(geometry.coordinates, tolerance, highQuality);\n        break;\n      case \"MultiPolygon\":\n        geometry.coordinates = geometry.coordinates.map(rings => simplifyPolygon(rings, tolerance, highQuality));\n    }\n  }\n  return geometry;\n}\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    if (ring.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    let ringTolerance = tolerance;\n    let simpleRing = simplify(ring, ringTolerance, highQuality);\n    while (!checkValidity(simpleRing)) {\n      ringTolerance -= ringTolerance * 0.01;\n      simpleRing = simplify(ring, ringTolerance, highQuality);\n    }\n    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);\n}\nvar turf_simplify_default = simplify2;\nexport { turf_simplify_default as default, simplify2 as simplify };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}