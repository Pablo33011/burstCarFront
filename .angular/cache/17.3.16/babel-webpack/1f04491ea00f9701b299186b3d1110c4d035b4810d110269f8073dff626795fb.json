{"ast":null,"code":"// index.ts\nimport { distance } from \"@turf/distance\";\nimport { feature, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport { tin } from \"@turf/tin\";\n\n// lib/turf-dissolve.ts\nimport { clone as clone3 } from \"@turf/clone\";\nimport { isObject as isObject2 } from \"@turf/helpers\";\nimport { getType as getType3 } from \"@turf/invariant\";\nimport { flattenEach as flattenEach2 } from \"@turf/meta\";\n\n// lib/turf-line-dissolve.ts\nimport { clone } from \"@turf/clone\";\nimport { isObject, lineString, multiLineString } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { lineReduce } from \"@turf/meta\";\nfunction lineDissolve(geojson, options = {}) {\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const mutate = options.mutate;\n  if (getType(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  if (mutate === false || mutate === void 0) {\n    geojson = clone(geojson);\n  }\n  const result = [];\n  const lastLine = lineReduce(geojson, (previousLine, currentLine) => {\n    const merged = mergeLineStrings(previousLine, currentLine);\n    if (merged) {\n      return merged;\n    } else {\n      result.push(previousLine);\n      return currentLine;\n    }\n  });\n  if (lastLine) {\n    result.push(lastLine);\n  }\n  if (!result.length) {\n    return null;\n  } else if (result.length === 1) {\n    return result[0];\n  } else {\n    return multiLineString(result.map(line => {\n      return line.coordinates;\n    }));\n  }\n}\nfunction coordId(coord) {\n  return coord[0].toString() + \",\" + coord[1].toString();\n}\nfunction mergeLineStrings(a, b) {\n  const coords1 = a.geometry.coordinates;\n  const coords2 = b.geometry.coordinates;\n  const s1 = coordId(coords1[0]);\n  const e1 = coordId(coords1[coords1.length - 1]);\n  const s2 = coordId(coords2[0]);\n  const e2 = coordId(coords2[coords2.length - 1]);\n  let coords;\n  if (s1 === e2) {\n    coords = coords2.concat(coords1.slice(1));\n  } else if (s2 === e1) {\n    coords = coords1.concat(coords2.slice(1));\n  } else if (s1 === s2) {\n    coords = coords1.slice(1).reverse().concat(coords2);\n  } else if (e1 === e2) {\n    coords = coords1.concat(coords2.reverse().slice(1));\n  } else {\n    return null;\n  }\n  return lineString(coords);\n}\n\n// lib/turf-polygon-dissolve.ts\nimport { clone as clone2 } from \"@turf/clone\";\nimport { geometryCollection } from \"@turf/helpers\";\nimport { getType as getType2 } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nimport { merge } from \"topojson-client\";\nimport { topology } from \"topojson-server\";\nfunction polygonDissolve(geojson, options = {}) {\n  if (getType2(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  if (options.mutate === false || options.mutate === void 0) {\n    geojson = clone2(geojson);\n  }\n  const geoms = [];\n  flattenEach(geojson, feature2 => {\n    geoms.push(feature2.geometry);\n  });\n  const topo = topology({\n    geoms: geometryCollection(geoms).geometry\n  });\n  const merged = merge(topo, topo.objects.geoms.geometries);\n  return merged;\n}\n\n// lib/turf-dissolve.ts\nfunction dissolve(geojson, options = {}) {\n  options = options || {};\n  if (!isObject2(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const mutate = options.mutate;\n  if (getType3(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  if (mutate === false || mutate === void 0) {\n    geojson = clone3(geojson);\n  }\n  const type = getHomogenousType(geojson);\n  if (!type) {\n    throw new Error(\"geojson must be homogenous\");\n  }\n  const data = geojson;\n  switch (type) {\n    case \"LineString\":\n      return lineDissolve(data, options);\n    case \"Polygon\":\n      return polygonDissolve(data, options);\n    default:\n      throw new Error(type + \" is not supported\");\n  }\n}\nfunction getHomogenousType(geojson) {\n  const types = {};\n  flattenEach2(geojson, feature2 => {\n    types[feature2.geometry.type] = true;\n  });\n  const keys = Object.keys(types);\n  if (keys.length === 1) {\n    return keys[0];\n  }\n  return null;\n}\n\n// index.ts\nfunction concave(points, options = {}) {\n  const maxEdge = options.maxEdge || Infinity;\n  const cleaned = removeDuplicates(points);\n  const tinPolys = tin(cleaned);\n  tinPolys.features = tinPolys.features.filter(triangle => {\n    const pt1 = triangle.geometry.coordinates[0][0];\n    const pt2 = triangle.geometry.coordinates[0][1];\n    const pt3 = triangle.geometry.coordinates[0][2];\n    const dist1 = distance(pt1, pt2, options);\n    const dist2 = distance(pt2, pt3, options);\n    const dist3 = distance(pt1, pt3, options);\n    return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n  });\n  if (tinPolys.features.length < 1) {\n    return null;\n  }\n  const dissolved = dissolve(tinPolys);\n  if (dissolved.coordinates.length === 1) {\n    dissolved.coordinates = dissolved.coordinates[0];\n    dissolved.type = \"Polygon\";\n  }\n  return feature(dissolved);\n}\nfunction removeDuplicates(points) {\n  const cleaned = [];\n  const existing = {};\n  featureEach(points, pt => {\n    if (!pt.geometry) {\n      return;\n    }\n    const key = pt.geometry.coordinates.join(\"-\");\n    if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n      cleaned.push(pt);\n      existing[key] = true;\n    }\n  });\n  return featureCollection(cleaned);\n}\nvar turf_concave_default = concave;\nexport { concave, turf_concave_default as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}