{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { coordEach } from \"@turf/meta\";\nimport { collectionOf as collectionOf2 } from \"@turf/invariant\";\nimport { multiLineString, featureCollection, isObject as isObject2 } from \"@turf/helpers\";\nimport { isoContours } from \"marchingsquares\";\n\n// lib/grid-to-matrix.js\nimport { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nfunction gridToMatrix(grid, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = [];\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0);\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n  return matrix;\n}\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n\n// index.ts\nfunction isolines(pointGrid, breaks, options) {\n  options = options || {};\n  if (!isObject2(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n  collectionOf2(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject2(commonProperties)) throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties must be an Array\");\n  const matrix = gridToMatrix(pointGrid, {\n    zProperty,\n    flip: true\n  });\n  const createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);\n  const scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n  return featureCollection(scaledIsolines);\n}\nfunction createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {\n  const results = [];\n  for (let i = 0; i < breaks.length; i++) {\n    const threshold = +breaks[i];\n    const properties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[i]);\n    properties[zProperty] = threshold;\n    const isoline = multiLineString(isoContours(matrix, threshold, {\n      linearRing: false,\n      noFrame: true\n    }), properties);\n    results.push(isoline);\n  }\n  return results;\n}\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  const gridBbox = bbox(points);\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n  const resize = point => {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n  createdIsoLines.forEach(isoline => {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\nvar turf_isolines_default = isolines;\nexport { turf_isolines_default as default, isolines };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}