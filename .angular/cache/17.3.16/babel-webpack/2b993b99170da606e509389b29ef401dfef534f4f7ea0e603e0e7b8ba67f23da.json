{"ast":null,"code":"// index.ts\nimport { featureCollection, multiPolygon, polygon } from \"@turf/helpers\";\nimport { coordEach, geomEach } from \"@turf/meta\";\nfunction polygonSmooth(inputPolys, options) {\n  options = options || {};\n  options.iterations = options.iterations || 1;\n  const {\n    iterations\n  } = options;\n  const outPolys = [];\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    if (geom.type === \"Polygon\") {\n      let outCoords = [[]];\n      for (let i = 0; i < iterations; i++) {\n        let tempOutput = [];\n        let poly = geom;\n        if (i > 0) {\n          poly = polygon(outCoords).geometry;\n        }\n        processPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(polygon(outCoords, properties));\n    } else if (geom.type === \"MultiPolygon\") {\n      let outCoords = [[[]]];\n      for (let y = 0; y < iterations; y++) {\n        let tempOutput = [];\n        let poly = geom;\n        if (y > 0) {\n          poly = multiPolygon(outCoords).geometry;\n        }\n        processMultiPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(multiPolygon(outCoords, properties));\n    } else {\n      throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\nfunction processPolygon(poly, tempOutput) {\n  var previousCoord;\n  var previousGeometryIndex;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (previousGeometryIndex !== geometryIndex) {\n      tempOutput.push([]);\n    } else {\n      var p0x = previousCoord[0];\n      var p0y = previousCoord[1];\n      var p1x = currentCoord[0];\n      var p1y = currentCoord[1];\n      tempOutput[geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n      tempOutput[geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n    }\n    previousCoord = currentCoord;\n    previousGeometryIndex = geometryIndex;\n  }, false);\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\nfunction processMultiPolygon(poly, tempOutput) {\n  let previousCoord;\n  let previousMultiFeatureIndex;\n  let previousGeometryIndex;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (previousMultiFeatureIndex !== multiFeatureIndex) {\n      tempOutput.push([[]]);\n    } else if (previousGeometryIndex !== geometryIndex) {\n      tempOutput[multiFeatureIndex].push([]);\n    } else {\n      var p0x = previousCoord[0];\n      var p0y = previousCoord[1];\n      var p1x = currentCoord[0];\n      var p1y = currentCoord[1];\n      tempOutput[multiFeatureIndex][geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n      tempOutput[multiFeatureIndex][geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n    }\n    previousCoord = currentCoord;\n    previousMultiFeatureIndex = multiFeatureIndex;\n    previousGeometryIndex = geometryIndex;\n  }, false);\n  tempOutput.forEach(function (poly2) {\n    poly2.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\nvar turf_polygon_smooth_default = polygonSmooth;\nexport { turf_polygon_smooth_default as default, polygonSmooth };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}