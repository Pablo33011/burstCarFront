{"ast":null,"code":"'use strict';\n\nvar RBush = require('rbush');\nvar Queue = require('tinyqueue');\nvar pointInPolygon = require('point-in-polygon');\nvar orient = require('robust-predicates/umd/orient2d.min.js').orient2d;\n\n// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18\nif (Queue.default) {\n  Queue = Queue.default;\n}\nmodule.exports = concaveman;\nmodule.exports.default = concaveman;\nfunction concaveman(points, concavity, lengthThreshold) {\n  // a relative measure of concavity; higher value means simpler hull\n  concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n  // when a segment goes below this length threshold, it won't be drilled down further\n  lengthThreshold = lengthThreshold || 0;\n\n  // start with a convex hull of the points\n  var hull = fastConvexHull(points);\n\n  // index the points with an R-tree\n  var tree = new RBush(16);\n  tree.toBBox = function (a) {\n    return {\n      minX: a[0],\n      minY: a[1],\n      maxX: a[0],\n      maxY: a[1]\n    };\n  };\n  tree.compareMinX = function (a, b) {\n    return a[0] - b[0];\n  };\n  tree.compareMinY = function (a, b) {\n    return a[1] - b[1];\n  };\n  tree.load(points);\n\n  // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n  var queue = [];\n  for (var i = 0, last; i < hull.length; i++) {\n    var p = hull[i];\n    tree.remove(p);\n    last = insertNode(p, last);\n    queue.push(last);\n  }\n\n  // index the segments with an R-tree (for intersection checks)\n  var segTree = new RBush(16);\n  for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n  var sqConcavity = concavity * concavity;\n  var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n  // process edges one by one\n  while (queue.length) {\n    var node = queue.shift();\n    var a = node.p;\n    var b = node.next.p;\n\n    // skip the edge if it's already short enough\n    var sqLen = getSqDist(a, b);\n    if (sqLen < sqLenThreshold) continue;\n    var maxSqLen = sqLen / sqConcavity;\n\n    // find the best connection point for the current edge to flex inward to\n    p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n    // if we found a connection and it satisfies our concavity measure\n    if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n      // connect the edge endpoints through this point and add 2 new edges to the queue\n      queue.push(node);\n      queue.push(insertNode(p, node));\n\n      // update point and segment indexes\n      tree.remove(p);\n      segTree.remove(node);\n      segTree.insert(updateBBox(node));\n      segTree.insert(updateBBox(node.next));\n    }\n  }\n\n  // convert the resulting hull linked list to an array of points\n  node = last;\n  var concave = [];\n  do {\n    concave.push(node.p);\n    node = node.next;\n  } while (node !== last);\n  concave.push(node.p);\n  return concave;\n}\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n  var queue = new Queue([], compareDist);\n  var node = tree.data;\n\n  // search through the point R-tree with a depth-first search using a priority queue\n  // in the order of distance to the edge (b, c)\n  while (node) {\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n      var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n      if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n      queue.push({\n        node: child,\n        dist: dist\n      });\n    }\n    while (queue.length && !queue.peek().node.children) {\n      var item = queue.pop();\n      var p = item.node;\n\n      // skip all points that are as close to adjacent edges (a,b) and (c,d),\n      // and points that would introduce self-intersections when connected\n      var d0 = sqSegDist(p, a, b);\n      var d1 = sqSegDist(p, c, d);\n      if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;\n    }\n    node = queue.pop();\n    if (node) node = node.node;\n  }\n  return null;\n}\nfunction compareDist(a, b) {\n  return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n  if (inside(a, bbox) || inside(b, bbox)) return 0;\n  var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n  if (d1 === 0) return 0;\n  var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n  if (d2 === 0) return 0;\n  var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n  if (d3 === 0) return 0;\n  var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n  if (d4 === 0) return 0;\n  return Math.min(d1, d2, d3, d4);\n}\nfunction inside(a, bbox) {\n  return a[0] >= bbox.minX && a[0] <= bbox.maxX && a[1] >= bbox.minY && a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n  var minX = Math.min(a[0], b[0]);\n  var minY = Math.min(a[1], b[1]);\n  var maxX = Math.max(a[0], b[0]);\n  var maxY = Math.max(a[1], b[1]);\n  var edges = segTree.search({\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  });\n  for (var i = 0; i < edges.length; i++) {\n    if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n  }\n  return true;\n}\nfunction cross(p1, p2, p3) {\n  return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n  return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n  var p1 = node.p;\n  var p2 = node.next.p;\n  node.minX = Math.min(p1[0], p2[0]);\n  node.minY = Math.min(p1[1], p2[1]);\n  node.maxX = Math.max(p1[0], p2[0]);\n  node.maxY = Math.max(p1[1], p2[1]);\n  return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n  var left = points[0];\n  var top = points[0];\n  var right = points[0];\n  var bottom = points[0];\n\n  // find the leftmost, rightmost, topmost and bottommost points\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p[0] < left[0]) left = p;\n    if (p[0] > right[0]) right = p;\n    if (p[1] < top[1]) top = p;\n    if (p[1] > bottom[1]) bottom = p;\n  }\n\n  // filter out points that are inside the resulting quadrilateral\n  var cull = [left, top, right, bottom];\n  var filtered = cull.slice();\n  for (i = 0; i < points.length; i++) {\n    if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n  }\n\n  // get convex hull around the filtered points\n  return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n  var node = {\n    p: p,\n    prev: null,\n    next: null,\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0\n  };\n  if (!prev) {\n    node.prev = node;\n    node.next = node;\n  } else {\n    node.next = prev.next;\n    node.prev = prev;\n    prev.next.prev = node;\n    prev.next = node;\n  }\n  return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p[0] - x;\n  dy = p[1] - y;\n  return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var ux = x1 - x0;\n  var uy = y1 - y0;\n  var vx = x3 - x2;\n  var vy = y3 - y2;\n  var wx = x0 - x2;\n  var wy = y0 - y2;\n  var a = ux * ux + uy * uy;\n  var b = ux * vx + uy * vy;\n  var c = vx * vx + vy * vy;\n  var d = ux * wx + uy * wy;\n  var e = vx * wx + vy * wy;\n  var D = a * c - b * b;\n  var sc, sN, tc, tN;\n  var sD = D;\n  var tD = D;\n  if (D === 0) {\n    sN = 0;\n    sD = 1;\n    tN = e;\n    tD = c;\n  } else {\n    sN = b * e - c * d;\n    tN = a * e - b * d;\n    if (sN < 0) {\n      sN = 0;\n      tN = e;\n      tD = c;\n    } else if (sN > sD) {\n      sN = sD;\n      tN = e + b;\n      tD = c;\n    }\n  }\n  if (tN < 0.0) {\n    tN = 0.0;\n    if (-d < 0.0) sN = 0.0;else if (-d > a) sN = sD;else {\n      sN = -d;\n      sD = a;\n    }\n  } else if (tN > tD) {\n    tN = tD;\n    if (-d + b < 0.0) sN = 0;else if (-d + b > a) sN = sD;else {\n      sN = -d + b;\n      sD = a;\n    }\n  }\n  sc = sN === 0 ? 0 : sN / sD;\n  tc = tN === 0 ? 0 : tN / tD;\n  var cx = (1 - sc) * x0 + sc * x1;\n  var cy = (1 - sc) * y0 + sc * y1;\n  var cx2 = (1 - tc) * x2 + tc * x3;\n  var cy2 = (1 - tc) * y2 + tc * y3;\n  var dx = cx2 - cx;\n  var dy = cy2 - cy;\n  return dx * dx + dy * dy;\n}\nfunction compareByX(a, b) {\n  return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\nfunction convexHull(points) {\n  points.sort(compareByX);\n  var lower = [];\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n    lower.push(points[i]);\n  }\n  var upper = [];\n  for (var ii = points.length - 1; ii >= 0; ii--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\n      upper.pop();\n    }\n    upper.push(points[ii]);\n  }\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}