{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\nfunction nearestPointToLine(points, line, options = {}) {\n  const units = options.units;\n  const properties = options.properties || {};\n  const pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n  let dist = Infinity;\n  let pt = null;\n  featureEach(pts, point => {\n    const d = pointToLineDistance(point, line, {\n      units\n    });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  if (pt) {\n    pt.properties = __spreadValues(__spreadValues(__spreadValues({}, {\n      dist\n    }), pt.properties), properties);\n  }\n  return pt;\n}\nfunction normalize(points) {\n  const features = [];\n  const type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, geom => {\n        if (geom.type === \"Point\") {\n          features.push({\n            type: \"Feature\",\n            properties: {},\n            geometry: geom\n          });\n        }\n      });\n      return {\n        type: \"FeatureCollection\",\n        features\n      };\n    case \"FeatureCollection\":\n      points.features = points.features.filter(feature => {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\nvar turf_nearest_point_to_line_default = nearestPointToLine;\nexport { turf_nearest_point_to_line_default as default, nearestPointToLine };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}