{"ast":null,"code":"// index.ts\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject, isNumber } from \"@turf/helpers\";\nimport { centerMean } from \"@turf/center-mean\";\nimport { pointsWithinPolygon } from \"@turf/points-within-polygon\";\nimport { ellipse } from \"@turf/ellipse\";\nfunction standardDeviationalEllipse(points, options) {\n  var _a;\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  const steps = options.steps || 64;\n  const weightTerm = options.weight;\n  const properties = options.properties || {};\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\n  const numberOfFeatures = coordAll(points).length;\n  const meanCenter = centerMean(points, {\n    weight: weightTerm\n  });\n  let xDeviationSquaredSum = 0;\n  let yDeviationSquaredSum = 0;\n  let xyDeviationSum = 0;\n  featureEach(points, function (point) {\n    var _a2;\n    const weight = weightTerm ? ((_a2 = point.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;\n    const deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n  const bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  const bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  const bigC = 2 * xyDeviationSum;\n  const theta = Math.atan((bigA + bigB) / bigC);\n  const thetaDeg = theta * 180 / Math.PI;\n  let sigmaXsum = 0;\n  let sigmaYsum = 0;\n  let weightsum = 0;\n  featureEach(points, function (point) {\n    var _a2;\n    const weight = weightTerm ? ((_a2 = point.properties) == null ? void 0 : _a2[weightTerm]) || 1 : 1;\n    const deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum += Math.pow(deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta), 2) * weight;\n    sigmaYsum += Math.pow(deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta), 2) * weight;\n    weightsum += weight;\n  });\n  const sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);\n  const sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);\n  const theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps,\n    properties\n  });\n  const pointsWithinEllipse = pointsWithinPolygon(points, featureCollection([theEllipse]));\n  const standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures\n  };\n  theEllipse.properties = (_a = theEllipse.properties) != null ? _a : {};\n  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;\n  return theEllipse;\n}\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1]\n  };\n}\nvar turf_standard_deviational_ellipse_default = standardDeviationalEllipse;\nexport { turf_standard_deviational_ellipse_default as default, standardDeviationalEllipse };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}