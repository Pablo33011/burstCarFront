{"ast":null,"code":"// index.ts\nimport { convertLength, degreesToRadians, earthRadius, point } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\nfunction rhumbDestination(origin, distance, bearing, options = {}) {\n  const wasNegativeDistance = distance < 0;\n  let distanceInMeters = convertLength(Math.abs(distance), options.units, \"meters\");\n  if (wasNegativeDistance) distanceInMeters = -Math.abs(distanceInMeters);\n  const coords = getCoord(origin);\n  const destination = calculateRhumbDestination(coords, distanceInMeters, bearing);\n  destination[0] += destination[0] - coords[0] > 180 ? -360 : coords[0] - destination[0] > 180 ? 360 : 0;\n  return point(destination, options.properties);\n}\nfunction calculateRhumbDestination(origin, distance, bearing, radius) {\n  radius = radius === void 0 ? earthRadius : Number(radius);\n  const delta = distance / radius;\n  const lambda1 = origin[0] * Math.PI / 180;\n  const phi1 = degreesToRadians(origin[1]);\n  const theta = degreesToRadians(bearing);\n  const DeltaPhi = delta * Math.cos(theta);\n  let phi2 = phi1 + DeltaPhi;\n  if (Math.abs(phi2) > Math.PI / 2) {\n    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;\n  }\n  const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n  const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n  const DeltaLambda = delta * Math.sin(theta) / q;\n  const lambda2 = lambda1 + DeltaLambda;\n  return [(lambda2 * 180 / Math.PI + 540) % 360 - 180, phi2 * 180 / Math.PI];\n}\nvar turf_rhumb_destination_default = rhumbDestination;\nexport { turf_rhumb_destination_default as default, rhumbDestination };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}