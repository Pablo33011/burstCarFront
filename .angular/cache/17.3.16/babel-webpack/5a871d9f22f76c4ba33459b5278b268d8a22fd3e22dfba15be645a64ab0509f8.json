{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// index.ts\nimport { distance } from \"@turf/distance\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord, getCoords } from \"@turf/invariant\";\nfunction nearestPointOnLine(lines, pt, options = {}) {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n  const ptPos = getCoord(pt);\n  let closestPt = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1\n  });\n  let length = 0;\n  flattenEach(lines, function (line, _featureIndex, multiFeatureIndex) {\n    const coords = getCoords(line);\n    for (let i = 0; i < coords.length - 1; i++) {\n      const start = point(coords[i]);\n      start.properties.dist = distance(pt, start, options);\n      const startPos = getCoord(start);\n      const stop = point(coords[i + 1]);\n      stop.properties.dist = distance(pt, stop, options);\n      const stopPos = getCoord(stop);\n      const sectionLength = distance(start, stop, options);\n      let intersectPos;\n      let wasEnd;\n      if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {\n        [intersectPos,, wasEnd] = [startPos, void 0, false];\n      } else if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {\n        [intersectPos,, wasEnd] = [stopPos, void 0, true];\n      } else {\n        [intersectPos,, wasEnd] = nearestPointOnSegment(start.geometry.coordinates, stop.geometry.coordinates, getCoord(pt));\n      }\n      let intersectPt;\n      if (intersectPos) {\n        intersectPt = point(intersectPos, {\n          dist: distance(pt, intersectPos, options),\n          multiFeatureIndex,\n          location: length + distance(start, intersectPos, options)\n        });\n      }\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = __spreadProps(__spreadValues({}, intersectPt), {\n          properties: __spreadProps(__spreadValues({}, intersectPt.properties), {\n            // Legacy behaviour where index progresses to next segment # if we\n            // went with the end point this iteration.\n            index: wasEnd ? i + 1 : i\n          })\n        });\n      }\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\nfunction dot(v1, v2) {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return v1x * v2x + v1y * v2y + v1z * v2z;\n}\nfunction cross(v1, v2) {\n  const [v1x, v1y, v1z] = v1;\n  const [v2x, v2y, v2z] = v2;\n  return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];\n}\nfunction magnitude(v) {\n  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));\n}\nfunction angle(v1, v2) {\n  const theta = dot(v1, v2) / (magnitude(v1) * magnitude(v2));\n  return Math.acos(Math.min(Math.max(theta, -1), 1));\n}\nfunction lngLatToVector(a) {\n  const lat = degreesToRadians(a[1]);\n  const lng = degreesToRadians(a[0]);\n  return [Math.cos(lat) * Math.cos(lng), Math.cos(lat) * Math.sin(lng), Math.sin(lat)];\n}\nfunction vectorToLngLat(v) {\n  const [x, y, z] = v;\n  const lat = radiansToDegrees(Math.asin(z));\n  const lng = radiansToDegrees(Math.atan2(y, x));\n  return [lng, lat];\n}\nfunction nearestPointOnSegment(posA, posB, posC) {\n  const A = lngLatToVector(posA);\n  const B = lngLatToVector(posB);\n  const C = lngLatToVector(posC);\n  const [Cx, Cy, Cz] = C;\n  const [D, E, F] = cross(A, B);\n  const a = E * Cz - F * Cy;\n  const b = F * Cx - D * Cz;\n  const c = D * Cy - E * Cx;\n  const f = c * E - b * F;\n  const g = a * F - c * D;\n  const h = b * D - a * E;\n  const t = 1 / Math.sqrt(Math.pow(f, 2) + Math.pow(g, 2) + Math.pow(h, 2));\n  const I1 = [f * t, g * t, h * t];\n  const I2 = [-1 * f * t, -1 * g * t, -1 * h * t];\n  const angleAB = angle(A, B);\n  const angleAI1 = angle(A, I1);\n  const angleBI1 = angle(B, I1);\n  const angleAI2 = angle(A, I2);\n  const angleBI2 = angle(B, I2);\n  let I;\n  if (angleAI1 < angleAI2 && angleAI1 < angleBI2 || angleBI1 < angleAI2 && angleBI1 < angleBI2) {\n    I = I1;\n  } else {\n    I = I2;\n  }\n  if (angle(A, I) > angleAB || angle(B, I) > angleAB) {\n    if (distance(vectorToLngLat(I), vectorToLngLat(A)) <= distance(vectorToLngLat(I), vectorToLngLat(B))) {\n      return [vectorToLngLat(A), true, false];\n    } else {\n      return [vectorToLngLat(B), false, true];\n    }\n  }\n  return [vectorToLngLat(I), false, false];\n}\nvar turf_nearest_point_on_line_default = nearestPointOnLine;\nexport { turf_nearest_point_on_line_default as default, nearestPointOnLine };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}