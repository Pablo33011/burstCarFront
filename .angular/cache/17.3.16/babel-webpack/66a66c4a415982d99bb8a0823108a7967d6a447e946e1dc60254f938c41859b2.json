{"ast":null,"code":"// index.ts\nimport { lineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n\n// lib/spline.ts\nvar Spline = class {\n  constructor(options) {\n    this.points = options.points || [];\n    this.duration = options.duration || 1e4;\n    this.sharpness = options.sharpness || 0.85;\n    this.centers = [];\n    this.controls = [];\n    this.stepLength = options.stepLength || 60;\n    this.length = this.points.length;\n    this.delay = 0;\n    for (let i = 0; i < this.length; i++) {\n      this.points[i].z = this.points[i].z || 0;\n    }\n    for (let i = 0; i < this.length - 1; i++) {\n      const p1 = this.points[i];\n      const p2 = this.points[i + 1];\n      this.centers.push({\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2,\n        z: (p1.z + p2.z) / 2\n      });\n    }\n    this.controls.push([this.points[0], this.points[0]]);\n    for (let i = 0; i < this.centers.length - 1; i++) {\n      const dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;\n      const dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;\n      const dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;\n      this.controls.push([{\n        x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),\n        y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),\n        z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)\n      }, {\n        x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),\n        y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),\n        z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)\n      }]);\n    }\n    this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);\n    this.steps = this.cacheSteps(this.stepLength);\n    return this;\n  }\n  /**\n   * Caches an array of equidistant (more or less) points on the curve.\n   */\n  cacheSteps(mindist) {\n    const steps = [];\n    let laststep = this.pos(0);\n    steps.push(0);\n    for (let t = 0; t < this.duration; t += 10) {\n      const step = this.pos(t);\n      const dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));\n      if (dist > mindist) {\n        steps.push(t);\n        laststep = step;\n      }\n    }\n    return steps;\n  }\n  /**\n   * returns angle and speed in the given point in the curve\n   */\n  vector(t) {\n    const p1 = this.pos(t + 10);\n    const p2 = this.pos(t - 10);\n    return {\n      angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,\n      speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))\n    };\n  }\n  /**\n   * Gets the position of the point, given time.\n   *\n   * WARNING: The speed is not constant. The time it takes between control points is constant.\n   *\n   * For constant speed, use Spline.steps[i];\n   */\n  pos(time) {\n    let t = time - this.delay;\n    if (t < 0) {\n      t = 0;\n    }\n    if (t > this.duration) {\n      t = this.duration - 1;\n    }\n    const t2 = t / this.duration;\n    if (t2 >= 1) {\n      return this.points[this.length - 1];\n    }\n    const n = Math.floor((this.points.length - 1) * t2);\n    const t1 = (this.length - 1) * t2 - n;\n    return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);\n  }\n};\nfunction bezier(t, p1, c1, c2, p2) {\n  const b = B(t);\n  const pos = {\n    x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],\n    y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],\n    z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]\n  };\n  return pos;\n}\nfunction B(t) {\n  const t2 = t * t;\n  const t3 = t2 * t;\n  return [t3, 3 * t2 * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)];\n}\n\n// index.ts\nfunction bezierSpline(line, options = {}) {\n  const resolution = options.resolution || 1e4;\n  const sharpness = options.sharpness || 0.85;\n  const coords = [];\n  const points = getGeom(line).coordinates.map(pt => {\n    return {\n      x: pt[0],\n      y: pt[1]\n    };\n  });\n  const spline = new Spline({\n    duration: resolution,\n    points,\n    sharpness\n  });\n  const pushCoord = time => {\n    var pos = spline.pos(time);\n    if (Math.floor(time / 100) % 2 === 0) {\n      coords.push([pos.x, pos.y]);\n    }\n  };\n  for (var i = 0; i < spline.duration; i += 10) {\n    pushCoord(i);\n  }\n  pushCoord(spline.duration);\n  return lineString(coords, options.properties);\n}\nvar turf_bezier_spline_default = bezierSpline;\nexport { bezierSpline, turf_bezier_spline_default as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}