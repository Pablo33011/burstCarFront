{"ast":null,"code":"// index.ts\nimport { clone } from \"@turf/clone\";\nimport { distance } from \"@turf/distance\";\nimport { degreesToRadians, lengthToDegrees } from \"@turf/helpers\";\n\n// lib/rbush-export.ts\nimport lib from \"rbush\";\nvar rbush = lib;\n\n// index.ts\nfunction clustersDbscan(points, maxDistance, options = {}) {\n  if (options.mutate !== true) points = clone(points);\n  const minPoints = options.minPoints || 3;\n  const latDistanceInDegrees = lengthToDegrees(maxDistance, options.units);\n  var tree = new rbush(points.features.length);\n  var visited = points.features.map(_ => false);\n  var assigned = points.features.map(_ => false);\n  var isnoise = points.features.map(_ => false);\n  var clusterIds = points.features.map(_ => -1);\n  tree.load(points.features.map((point, index) => {\n    var [x, y] = point.geometry.coordinates;\n    return {\n      minX: x,\n      minY: y,\n      maxX: x,\n      maxY: y,\n      index\n    };\n  }));\n  const regionQuery = index => {\n    const point = points.features[index];\n    const [x, y] = point.geometry.coordinates;\n    const minY = Math.max(y - latDistanceInDegrees, -90);\n    const maxY = Math.min(y + latDistanceInDegrees, 90);\n    const lonDistanceInDegrees = function () {\n      if (minY < 0 && maxY > 0) {\n        return latDistanceInDegrees;\n      }\n      if (Math.abs(minY) < Math.abs(maxY)) {\n        return latDistanceInDegrees / Math.cos(degreesToRadians(maxY));\n      } else {\n        return latDistanceInDegrees / Math.cos(degreesToRadians(minY));\n      }\n    }();\n    const minX = Math.max(x - lonDistanceInDegrees, -360);\n    const maxX = Math.min(x + lonDistanceInDegrees, 360);\n    const bbox = {\n      minX,\n      minY,\n      maxX,\n      maxY\n    };\n    return tree.search(bbox).filter(neighbor => {\n      const neighborIndex = neighbor.index;\n      const neighborPoint = points.features[neighborIndex];\n      const distanceInKm = distance(point, neighborPoint, {\n        units: \"kilometers\"\n      });\n      return distanceInKm <= maxDistance;\n    });\n  };\n  const expandCluster = (clusteredId, neighbors) => {\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i];\n      const neighborIndex = neighbor.index;\n      if (!visited[neighborIndex]) {\n        visited[neighborIndex] = true;\n        const nextNeighbors = regionQuery(neighborIndex);\n        if (nextNeighbors.length >= minPoints) {\n          neighbors.push(...nextNeighbors);\n        }\n      }\n      if (!assigned[neighborIndex]) {\n        assigned[neighborIndex] = true;\n        clusterIds[neighborIndex] = clusteredId;\n      }\n    }\n  };\n  var nextClusteredId = 0;\n  points.features.forEach((_, index) => {\n    if (visited[index]) return;\n    const neighbors = regionQuery(index);\n    if (neighbors.length >= minPoints) {\n      const clusteredId = nextClusteredId;\n      nextClusteredId++;\n      visited[index] = true;\n      expandCluster(clusteredId, neighbors);\n    } else {\n      isnoise[index] = true;\n    }\n  });\n  points.features.forEach((_, index) => {\n    var clusterPoint = points.features[index];\n    if (!clusterPoint.properties) {\n      clusterPoint.properties = {};\n    }\n    if (clusterIds[index] >= 0) {\n      clusterPoint.properties.dbscan = isnoise[index] ? \"edge\" : \"core\";\n      clusterPoint.properties.cluster = clusterIds[index];\n    } else {\n      clusterPoint.properties.dbscan = \"noise\";\n    }\n  });\n  return points;\n}\nvar turf_clusters_dbscan_default = clustersDbscan;\nexport { clustersDbscan, turf_clusters_dbscan_default as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}