{"ast":null,"code":"// index.ts\nimport { featureEach } from \"@turf/meta\";\nimport { featureCollection } from \"@turf/helpers\";\nfunction getCluster(geojson, filter) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (geojson.type !== \"FeatureCollection\") throw new Error(\"geojson must be a FeatureCollection\");\n  if (filter === void 0 || filter === null) throw new Error(\"filter is required\");\n  var features = [];\n  featureEach(geojson, function (feature) {\n    if (applyFilter(feature.properties, filter)) features.push(feature);\n  });\n  return featureCollection(features);\n}\nfunction clusterEach(geojson, property, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (geojson.type !== \"FeatureCollection\") throw new Error(\"geojson must be a FeatureCollection\");\n  if (property === void 0 || property === null) throw new Error(\"property is required\");\n  var bins = createBins(geojson, property);\n  var values = Object.keys(bins);\n  for (var index = 0; index < values.length; index++) {\n    var value = values[index];\n    var bin = bins[value];\n    var features = [];\n    for (var i = 0; i < bin.length; i++) {\n      features.push(geojson.features[bin[i]]);\n    }\n    callback(featureCollection(features), value, index);\n  }\n}\nfunction clusterReduce(geojson, property, callback, initialValue) {\n  var previousValue = initialValue;\n  clusterEach(geojson, property, function (cluster, clusterValue, currentIndex) {\n    if (currentIndex === 0 && initialValue === void 0) previousValue = cluster;else previousValue = callback(previousValue, cluster, clusterValue, currentIndex);\n  });\n  return previousValue;\n}\nfunction createBins(geojson, property) {\n  var bins = {};\n  featureEach(geojson, function (feature, i) {\n    var properties = feature.properties || {};\n    if (Object.prototype.hasOwnProperty.call(properties, String(property))) {\n      var value = properties[property];\n      if (Object.prototype.hasOwnProperty.call(bins, value)) bins[value].push(i);else bins[value] = [i];\n    }\n  });\n  return bins;\n}\nfunction applyFilter(properties, filter) {\n  if (properties === void 0) return false;\n  var filterType = typeof filter;\n  if (filterType === \"number\" || filterType === \"string\") return Object.prototype.hasOwnProperty.call(properties, filter);else if (Array.isArray(filter)) {\n    for (var i = 0; i < filter.length; i++) {\n      if (!applyFilter(properties, filter[i])) return false;\n    }\n    return true;\n  } else {\n    return propertiesContainsFilter(properties, filter);\n  }\n}\nfunction propertiesContainsFilter(properties, filter) {\n  var keys = Object.keys(filter);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (properties[key] !== filter[key]) return false;\n  }\n  return true;\n}\nfunction filterProperties(properties, keys) {\n  if (!keys) return {};\n  if (!keys.length) return {};\n  var newProperties = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (Object.prototype.hasOwnProperty.call(properties, key)) newProperties[key] = properties[key];\n  }\n  return newProperties;\n}\nexport { applyFilter, clusterEach, clusterReduce, createBins, filterProperties, getCluster, propertiesContainsFilter };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}