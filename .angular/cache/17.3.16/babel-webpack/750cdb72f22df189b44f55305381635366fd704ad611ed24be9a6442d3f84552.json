{"ast":null,"code":"// index.ts\nimport { distance } from \"@turf/distance\";\nimport { intersect } from \"@turf/intersect\";\nimport { polygon, featureCollection } from \"@turf/helpers\";\nfunction hexGrid(bbox, cellSide, options = {}) {\n  const clonedProperties = JSON.stringify(options.properties || {});\n  const [west, south, east, north] = bbox;\n  const centerY = (south + north) / 2;\n  const centerX = (west + east) / 2;\n  const xFraction = cellSide * 2 / distance([west, centerY], [east, centerY], options);\n  const cellWidth = xFraction * (east - west);\n  const yFraction = cellSide * 2 / distance([centerX, south], [centerX, north], options);\n  const cellHeight = yFraction * (north - south);\n  const radius = cellWidth / 2;\n  const hex_width = radius * 2;\n  const hex_height = Math.sqrt(3) / 2 * cellHeight;\n  const box_width = east - west;\n  const box_height = north - south;\n  const x_interval = 3 / 4 * hex_width;\n  const y_interval = hex_height;\n  const x_span = (box_width - hex_width) / (hex_width - radius / 2);\n  const x_count = Math.floor(x_span);\n  const x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2 + x_interval / 2;\n  const y_count = Math.floor((box_height - hex_height) / hex_height);\n  let y_adjust = (box_height - y_count * hex_height) / 2;\n  const hasOffsetY = y_count * hex_height - box_height > hex_height / 2;\n  if (hasOffsetY) {\n    y_adjust -= hex_height / 4;\n  }\n  const cosines = [];\n  const sines = [];\n  for (let i = 0; i < 6; i++) {\n    const angle = 2 * Math.PI / 6 * i;\n    cosines.push(Math.cos(angle));\n    sines.push(Math.sin(angle));\n  }\n  const results = [];\n  for (let x = 0; x <= x_count; x++) {\n    for (let y = 0; y <= y_count; y++) {\n      const isOdd = x % 2 === 1;\n      if (y === 0 && isOdd) continue;\n      if (y === 0 && hasOffsetY) continue;\n      const center_x = x * x_interval + west - x_adjust;\n      let center_y = y * y_interval + south + y_adjust;\n      if (isOdd) {\n        center_y -= hex_height / 2;\n      }\n      if (options.triangles === true) {\n        hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines).forEach(function (triangle) {\n          if (options.mask) {\n            if (intersect(featureCollection([options.mask, triangle]))) results.push(triangle);\n          } else {\n            results.push(triangle);\n          }\n        });\n      } else {\n        const hex = hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2, JSON.parse(clonedProperties), cosines, sines);\n        if (options.mask) {\n          if (intersect(featureCollection([options.mask, hex]))) results.push(hex);\n        } else {\n          results.push(hex);\n        }\n      }\n    }\n  }\n  return featureCollection(results);\n}\nfunction hexagon(center, rx, ry, properties, cosines, sines) {\n  const vertices = [];\n  for (let i = 0; i < 6; i++) {\n    const x = center[0] + rx * cosines[i];\n    const y = center[1] + ry * sines[i];\n    vertices.push([x, y]);\n  }\n  vertices.push(vertices[0].slice());\n  return polygon([vertices], properties);\n}\nfunction hexTriangles(center, rx, ry, properties, cosines, sines) {\n  const triangles = [];\n  for (let i = 0; i < 6; i++) {\n    const vertices = [];\n    vertices.push(center);\n    vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);\n    vertices.push([center[0] + rx * cosines[(i + 1) % 6], center[1] + ry * sines[(i + 1) % 6]]);\n    vertices.push(center);\n    triangles.push(polygon([vertices], properties));\n  }\n  return triangles;\n}\nvar turf_hex_grid_default = hexGrid;\nexport { turf_hex_grid_default as default, hexGrid };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}