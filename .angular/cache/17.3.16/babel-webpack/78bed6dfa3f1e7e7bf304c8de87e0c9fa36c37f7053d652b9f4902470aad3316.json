{"ast":null,"code":"// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { distance } from \"@turf/distance\";\nimport { transformScale as scale } from \"@turf/transform-scale\";\nimport { cleanCoords } from \"@turf/clean-coords\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord, getGeom } from \"@turf/invariant\";\nimport { point, isNumber, lineString, isObject, featureCollection, feature } from \"@turf/helpers\";\n\n// lib/javascript-astar.js\nfunction pathTo(node) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\nvar astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (graph, start, end, options) {\n    var _a;\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n      closest = (_a = options.closest) != null ? _a : false;\n    var openHeap = getHeap(),\n      closestNode = start;\n    start.h = heuristic(start, end);\n    openHeap.push(start);\n    while (openHeap.size() > 0) {\n      var currentNode = openHeap.pop();\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n      currentNode.closed = true;\n      var neighbors = graph.neighbors(currentNode);\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n        if (neighbor.closed || neighbor.isWall()) {\n          continue;\n        }\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n        if (!beenVisited || gScore < neighbor.g) {\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {\n              closestNode = neighbor;\n            }\n          }\n          if (!beenVisited) {\n            openHeap.push(neighbor);\n          } else {\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n    if (closest) {\n      return pathTo(closestNode);\n    }\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    }\n  },\n  cleanNode: function (node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n    x = node.x,\n    y = node.y,\n    grid = this.grid;\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n  if (this.diagonal) {\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n  return ret;\n};\nGraph.prototype.toString = function () {\n  var graphString = [],\n    nodes = this.grid,\n    rowDebug,\n    row,\n    y,\n    l;\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\nGridNode.prototype.getCost = function (fromNeighbor) {\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\nBinaryHeap.prototype = {\n  push: function (element) {\n    this.content.push(element);\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function () {\n    var result = this.content[0];\n    var end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function (node) {\n    var i = this.content.indexOf(node);\n    var end = this.content.pop();\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function () {\n    return this.content.length;\n  },\n  rescoreElement: function (node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function (n) {\n    var element = this.content[n];\n    while (n > 0) {\n      var parentN = (n + 1 >> 1) - 1,\n        parent = this.content[parentN];\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        n = parentN;\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function (n) {\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n    while (true) {\n      var child2N = n + 1 << 1,\n        child1N = child2N - 1;\n      var swap = null,\n        child1Score;\n      if (child1N < length) {\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } else {\n        break;\n      }\n    }\n  }\n};\n\n// index.ts\nfunction shortestPath(start, end, options = {}) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  let obstacles = options.obstacles || featureCollection([]);\n  let resolution = options.resolution || 100;\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if (resolution && (!isNumber(resolution) || resolution <= 0)) throw new Error(\"options.resolution must be a number, greater than 0\");\n  const startCoord = getCoord(start);\n  const endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord);\n  if (obstacles.type === \"FeatureCollection\") {\n    if (obstacles.features.length === 0) {\n      return lineString([startCoord, endCoord]);\n    }\n  } else if (obstacles.type === \"Polygon\") {\n    obstacles = featureCollection([feature(getGeom(obstacles))]);\n  } else {\n    throw new Error(\"invalid obstacles\");\n  }\n  const collection = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  const box = bbox(scale(bboxPolygon(bbox(collection)), 1.15));\n  const [west, south, east, north] = box;\n  const width = distance([west, south], [east, south], options);\n  const division = width / resolution;\n  collection.features.pop();\n  collection.features.pop();\n  const xFraction = division / distance([west, south], [east, south], options);\n  const cellWidth = xFraction * (east - west);\n  const yFraction = division / distance([west, south], [west, north], options);\n  const cellHeight = yFraction * (north - south);\n  const bboxHorizontalSide = east - west;\n  const bboxVerticalSide = north - south;\n  const columns = Math.floor(bboxHorizontalSide / cellWidth);\n  const rows = Math.floor(bboxVerticalSide / cellHeight);\n  const deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  const deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\n  const pointMatrix = [];\n  const matrix = [];\n  let closestToStart;\n  let closestToEnd;\n  let minDistStart = Infinity;\n  let minDistEnd = Infinity;\n  let currentY = north - deltaY;\n  let r = 0;\n  while (currentY >= south) {\n    const matrixRow = [];\n    const pointMatrixRow = [];\n    let currentX = west + deltaX;\n    let c = 0;\n    while (currentX <= east) {\n      const pt = point([currentX, currentY]);\n      const isInsideObstacle = isInside(pt, obstacles);\n      matrixRow.push(isInsideObstacle ? 0 : 1);\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      const distStart = distance(pt, start);\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = {\n          x: c,\n          y: r\n        };\n      }\n      const distEnd = distance(pt, end);\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = {\n          x: c,\n          y: r\n        };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n  const graph = new Graph(matrix, {\n    diagonal: true\n  });\n  const startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\n  const endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\n  const result = astar.search(graph, startOnMatrix, endOnMatrix);\n  const path = [startCoord];\n  result.forEach(function (coord) {\n    const coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]);\n  });\n  path.push(endCoord);\n  return cleanCoords(lineString(path));\n}\nfunction isInside(pt, polygons) {\n  for (let i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nvar turf_shortest_path_default = shortestPath;\nexport { turf_shortest_path_default as default, shortestPath };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}