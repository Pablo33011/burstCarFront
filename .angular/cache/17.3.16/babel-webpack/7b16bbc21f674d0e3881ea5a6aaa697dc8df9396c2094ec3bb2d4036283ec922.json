{"ast":null,"code":"// index.js\nimport { flattenEach } from \"@turf/meta\";\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { isObject, lineString, multiLineString, lengthToDegrees } from \"@turf/helpers\";\n\n// lib/intersection.js\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection2 = add(p, scalarMult(t, r));\n  return intersection2;\n}\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n// index.js\nfunction lineOffset(geojson, distance, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === void 0 || distance === null || isNaN(distance)) throw new Error(\"distance is required\");\n  var type = getType(geojson);\n  var properties = geojson.properties;\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\n  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n  return [[out1x, out1y], [out2x, out2y]];\n}\nvar turf_line_offset_default = lineOffset;\nexport { turf_line_offset_default as default, lineOffset };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}