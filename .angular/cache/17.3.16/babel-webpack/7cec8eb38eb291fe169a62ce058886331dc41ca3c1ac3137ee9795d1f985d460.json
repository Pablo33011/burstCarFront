{"ast":null,"code":"// index.ts\nimport { getCoords, getType } from \"@turf/invariant\";\nimport { point, featureCollection } from \"@turf/helpers\";\nimport { bbox as calcBbox } from \"@turf/bbox\";\nimport { explode } from \"@turf/explode\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nfunction polygonTangents(pt, polygon) {\n  const pointCoords = getCoords(pt);\n  const polyCoords = getCoords(polygon);\n  let rtan = [];\n  let ltan = [];\n  let eprev;\n  const bbox = calcBbox(polygon);\n  let nearestPtIndex = 0;\n  let nearest = null;\n  if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n  const type = getType(polygon);\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1]) ltan = polyCoords[0][nearestPtIndex];\n      }\n      eprev = isLeft(polyCoords[0][0], polyCoords[0][polyCoords[0].length - 1], pointCoords);\n      [rtan, ltan] = processPolygon(polyCoords[0], pointCoords, eprev, rtan, ltan);\n      break;\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n          verticesCounted++;\n        }\n        if (verticeFound) break;\n      }\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(polyCoords[0][0][0], polyCoords[0][0][polyCoords[0][0].length - 1], pointCoords);\n      polyCoords.forEach(function (ring) {\n        [rtan, ltan] = processPolygon(ring[0], pointCoords, eprev, rtan, ltan);\n      });\n      break;\n  }\n  return featureCollection([point(rtan), point(ltan)]);\n}\nfunction processPolygon(polygonCoords, ptCoords, eprev, rtan, ltan) {\n  for (let i = 0; i < polygonCoords.length; i++) {\n    const currentCoords = polygonCoords[i];\n    let nextCoordPair = polygonCoords[i + 1];\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n    const enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n    eprev = enext;\n  }\n  return [rtan, ltan];\n}\nfunction isAbove(point1, point2, point3) {\n  return isLeft(point1, point2, point3) > 0;\n}\nfunction isBelow(point1, point2, point3) {\n  return isLeft(point1, point2, point3) < 0;\n}\nfunction isLeft(point1, point2, point3) {\n  return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);\n}\nvar turf_polygon_tangents_default = polygonTangents;\nexport { turf_polygon_tangents_default as default, polygonTangents };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}