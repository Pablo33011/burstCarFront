{"ast":null,"code":"// index.ts\nimport { area } from \"@turf/area\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { getCoord } from \"@turf/invariant\";\nimport { squareGrid } from \"@turf/square-grid\";\nfunction quadratAnalysis(pointFeatureSet, options) {\n  options = options || {};\n  const studyBbox = options.studyBbox || turfBBox(pointFeatureSet);\n  const confidenceLevel = options.confidenceLevel || 20;\n  const points = pointFeatureSet.features;\n  const numOfPoints = points.length;\n  const sizeOfArea = area(bboxPolygon(studyBbox));\n  const lengthOfSide = Math.sqrt(sizeOfArea / numOfPoints * 2);\n  const grid = squareGrid(studyBbox, lengthOfSide, {\n    units: \"meters\"\n  });\n  const quadrats = grid.features;\n  const quadratIdDict = {};\n  for (let i = 0; i < quadrats.length; i++) {\n    quadratIdDict[i] = {\n      box: turfBBox(quadrats[i]),\n      cnt: 0\n    };\n  }\n  let sumOfPoint = 0;\n  for (const pt of points) {\n    for (const key of Object.keys(quadratIdDict)) {\n      const box = quadratIdDict[key].box;\n      if (inBBox(getCoord(pt), box)) {\n        quadratIdDict[key].cnt += 1;\n        sumOfPoint += 1;\n        break;\n      }\n    }\n  }\n  let maxCnt = 0;\n  for (const key of Object.keys(quadratIdDict)) {\n    const cnt = quadratIdDict[key].cnt;\n    if (cnt > maxCnt) {\n      maxCnt = cnt;\n    }\n  }\n  const expectedDistribution = [];\n  const numOfQuadrat = Object.keys(quadratIdDict).length;\n  const lambda = sumOfPoint / numOfQuadrat;\n  let cumulativeProbility = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    cumulativeProbility += Math.exp(-lambda) * Math.pow(lambda, x) / factorial(x);\n    expectedDistribution.push(cumulativeProbility);\n  }\n  const observedDistribution = [];\n  let cumulativeObservedQuads = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    for (const key of Object.keys(quadratIdDict)) {\n      if (quadratIdDict[key].cnt === x) {\n        cumulativeObservedQuads += 1;\n      }\n    }\n    const p = cumulativeObservedQuads / numOfQuadrat;\n    observedDistribution.push(p);\n  }\n  let maxDifference = 0;\n  for (let x = 0; x < maxCnt + 1; x++) {\n    const difference = Math.abs(expectedDistribution[x] - observedDistribution[x]);\n    if (difference > maxDifference) {\n      maxDifference = difference;\n    }\n  }\n  const k = K_TABLE[confidenceLevel];\n  const criticalValue = k / Math.sqrt(numOfQuadrat);\n  const result = {\n    criticalValue,\n    isRandom: true,\n    maxAbsoluteDifference: maxDifference,\n    observedDistribution\n  };\n  if (maxDifference > criticalValue) {\n    result.isRandom = false;\n  }\n  return result;\n}\nvar K_TABLE = {\n  20: 1.07275,\n  15: 1.13795,\n  10: 1.22385,\n  5: 1.3581,\n  2: 1.51743,\n  1: 1.62762\n};\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}\nfunction factorial(num) {\n  const f = [];\n  function inner(n) {\n    if (n === 0 || n === 1) {\n      return 1;\n    }\n    if (f[n] > 0) {\n      return f[n];\n    }\n    return f[n] = inner(n - 1) * n;\n  }\n  return inner(num);\n}\nvar turf_quadrat_analysis_default = quadratAnalysis;\nexport { turf_quadrat_analysis_default as default, quadratAnalysis };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}