{"ast":null,"code":"// index.ts\nimport { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\nfunction cleanCoords(geojson, options = {}) {\n  var mutate = typeof options === \"object\" ? options.mutate : options;\n  if (!geojson) throw new Error(\"geojson is required\");\n  var type = getType(geojson);\n  var newCoords = [];\n  switch (type) {\n    case \"LineString\":\n      newCoords = cleanLine(geojson, type);\n      break;\n    case \"MultiLineString\":\n    case \"Polygon\":\n      getCoords(geojson).forEach(function (line) {\n        newCoords.push(cleanLine(line, type));\n      });\n      break;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (polygons) {\n        var polyPoints = [];\n        polygons.forEach(function (ring) {\n          polyPoints.push(cleanLine(ring, type));\n        });\n        newCoords.push(polyPoints);\n      });\n      break;\n    case \"Point\":\n      return geojson;\n    case \"MultiPoint\":\n      var existing = {};\n      getCoords(geojson).forEach(function (coord) {\n        var key = coord.join(\"-\");\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n          newCoords.push(coord);\n          existing[key] = true;\n        }\n      });\n      break;\n    default:\n      throw new Error(type + \" geometry not supported\");\n  }\n  if (geojson.coordinates) {\n    if (mutate === true) {\n      geojson.coordinates = newCoords;\n      return geojson;\n    }\n    return {\n      type,\n      coordinates: newCoords\n    };\n  } else {\n    if (mutate === true) {\n      geojson.geometry.coordinates = newCoords;\n      return geojson;\n    }\n    return feature({\n      type,\n      coordinates: newCoords\n    }, geojson.properties, {\n      bbox: geojson.bbox,\n      id: geojson.id\n    });\n  }\n}\nfunction cleanLine(line, type) {\n  var points = getCoords(line);\n  if (points.length === 2 && !equals(points[0], points[1])) return points;\n  var newPoints = [];\n  var secondToLast = points.length - 1;\n  var newPointsLength = newPoints.length;\n  newPoints.push(points[0]);\n  for (var i = 1; i < secondToLast; i++) {\n    var prevAddedPoint = newPoints[newPoints.length - 1];\n    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;else {\n      newPoints.push(points[i]);\n      newPointsLength = newPoints.length;\n      if (newPointsLength > 2) {\n        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n      }\n    }\n  }\n  newPoints.push(points[points.length - 1]);\n  newPointsLength = newPoints.length;\n  if ((type === \"Polygon\" || type === \"MultiPolygon\") && equals(points[0], points[points.length - 1]) && newPointsLength < 4) {\n    throw new Error(\"invalid polygon\");\n  }\n  if (type === \"LineString\" && newPointsLength < 3) {\n    return newPoints;\n  }\n  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n  return newPoints;\n}\nfunction equals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\nfunction isPointOnLineSegment(start, end, point) {\n  var x = point[0],\n    y = point[1];\n  var startX = start[0],\n    startY = start[1];\n  var endX = end[0],\n    endY = end[1];\n  var dxc = x - startX;\n  var dyc = y - startY;\n  var dxl = endX - startX;\n  var dyl = endY - startY;\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nvar turf_clean_coords_default = cleanCoords;\nexport { cleanCoords, turf_clean_coords_default as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}