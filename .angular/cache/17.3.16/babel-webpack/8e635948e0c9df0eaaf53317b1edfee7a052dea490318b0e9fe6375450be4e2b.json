{"ast":null,"code":"// index.ts\nimport { convertLength, feature, lineString, point } from \"@turf/helpers\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nfunction pointToLineDistance(pt, line, options = {}) {\n  var _a, _b;\n  const method = (_a = options.method) != null ? _a : \"geodesic\";\n  const units = (_b = options.units) != null ? _b : \"kilometers\";\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n  let distance = Infinity;\n  const p = pt.geometry.coordinates;\n  segmentEach(line, segment => {\n    if (segment) {\n      const a = segment.geometry.coordinates[0];\n      const b = segment.geometry.coordinates[1];\n      const d = distanceToSegment(p, a, b, {\n        method\n      });\n      if (d < distance) {\n        distance = d;\n      }\n    }\n  });\n  return convertLength(distance, \"degrees\", units);\n}\nfunction distanceToSegment(p, a, b, options) {\n  if (options.method === \"geodesic\") {\n    const nearest = nearestPointOnLine(lineString([a, b]).geometry, p, {\n      units: \"degrees\"\n    });\n    return nearest.properties.dist;\n  }\n  const v = [b[0] - a[0], b[1] - a[1]];\n  const w = [p[0] - a[0], p[1] - a[1]];\n  const c1 = dot(w, v);\n  if (c1 <= 0) {\n    return rhumbDistance(p, a, {\n      units: \"degrees\"\n    });\n  }\n  const c2 = dot(v, v);\n  if (c2 <= c1) {\n    return rhumbDistance(p, b, {\n      units: \"degrees\"\n    });\n  }\n  const b2 = c1 / c2;\n  const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return rhumbDistance(p, Pb, {\n    units: \"degrees\"\n  });\n}\nfunction dot(u, v) {\n  return u[0] * v[0] + u[1] * v[1];\n}\nvar turf_point_to_line_distance_default = pointToLineDistance;\nexport { turf_point_to_line_distance_default as default, pointToLineDistance };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}