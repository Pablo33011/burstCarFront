{"ast":null,"code":"\"use strict\";\n\nvar Distance = require(\"./distance.js\"),\n  eudist = Distance.eudist,\n  dist = Distance.dist;\nmodule.exports = {\n  kmrand: function kmrand(data, k) {\n    var map = {},\n      ks = [],\n      t = k << 2;\n    var len = data.length;\n    var multi = data[0].length > 0;\n    while (ks.length < k && t-- > 0) {\n      var d = data[Math.floor(Math.random() * len)];\n      var key = multi ? d.join(\"_\") : \"\" + d;\n      if (!map[key]) {\n        map[key] = true;\n        ks.push(d);\n      }\n    }\n    if (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n  },\n  /**\n   * K-means++ initial centroid selection\n   */\n  kmpp: function kmpp(data, k) {\n    var distance = data[0].length ? eudist : dist;\n    var ks = [],\n      len = data.length;\n    var multi = data[0].length > 0;\n    var map = {};\n\n    // First random centroid\n    var c = data[Math.floor(Math.random() * len)];\n    var key = multi ? c.join(\"_\") : \"\" + c;\n    ks.push(c);\n    map[key] = true;\n\n    // Retrieve next centroids\n    while (ks.length < k) {\n      // Min Distances between current centroids and data points\n      var dists = [],\n        lk = ks.length;\n      var dsum = 0,\n        prs = [];\n      for (var i = 0; i < len; i++) {\n        var min = Infinity;\n        for (var j = 0; j < lk; j++) {\n          var _dist = distance(data[i], ks[j]);\n          if (_dist <= min) min = _dist;\n        }\n        dists[i] = min;\n      }\n\n      // Sum all min distances\n      for (var _i = 0; _i < len; _i++) {\n        dsum += dists[_i];\n      }\n\n      // Probabilities and cummulative prob (cumsum)\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        prs[_i2] = {\n          i: _i2,\n          v: data[_i2],\n          pr: dists[_i2] / dsum,\n          cs: 0\n        };\n      }\n\n      // Sort Probabilities\n      prs.sort(function (a, b) {\n        return a.pr - b.pr;\n      });\n\n      // Cummulative Probabilities\n      prs[0].cs = prs[0].pr;\n      for (var _i3 = 1; _i3 < len; _i3++) {\n        prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n      }\n\n      // Randomize\n      var rnd = Math.random();\n\n      // Gets only the items whose cumsum >= rnd\n      var idx = 0;\n      while (idx < len - 1 && prs[idx++].cs < rnd) {}\n      ks.push(prs[idx - 1].v);\n      /*\n      let done = false;\n      while(!done) {\n      \t// this is our new centroid\n      \tc = prs[idx-1].v\n      \tkey = multi? c.join(\"_\") : `${c}`;\n      \tif(!map[key]) {\n      \t\tmap[key] = true;\n      \t\tks.push(c);\n      \t\tdone = true;\n      \t}\n      \telse {\n      \t\tidx++;\n      \t}\n      }\n      */\n    }\n    return ks;\n  }\n};\n//# sourceMappingURL=kinit.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}