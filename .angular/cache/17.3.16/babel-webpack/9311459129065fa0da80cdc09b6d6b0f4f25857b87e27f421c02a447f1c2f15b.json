{"ast":null,"code":"// index.ts\nimport { featureCollection, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\nfunction lineSegment(geojson) {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n  const results = [];\n  flattenEach(geojson, feature => {\n    lineSegmentFeature(feature, results);\n  });\n  return featureCollection(results);\n}\nfunction lineSegmentFeature(geojson, results) {\n  let coords = [];\n  const geometry = geojson.geometry;\n  if (geometry !== null) {\n    switch (geometry.type) {\n      case \"Polygon\":\n        coords = getCoords(geometry);\n        break;\n      case \"LineString\":\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(coord => {\n      const segments = createSegments(coord, geojson.properties);\n      segments.forEach(segment => {\n        segment.id = results.length;\n        results.push(segment);\n      });\n    });\n  }\n}\nfunction createSegments(coords, properties) {\n  const segments = [];\n  coords.reduce((previousCoords, currentCoords) => {\n    const segment = lineString([previousCoords, currentCoords], properties);\n    segment.bbox = bbox(previousCoords, currentCoords);\n    segments.push(segment);\n    return currentCoords;\n  });\n  return segments;\n}\nfunction bbox(coords1, coords2) {\n  const x1 = coords1[0];\n  const y1 = coords1[1];\n  const x2 = coords2[0];\n  const y2 = coords2[1];\n  const west = x1 < x2 ? x1 : x2;\n  const south = y1 < y2 ? y1 : y2;\n  const east = x1 > x2 ? x1 : x2;\n  const north = y1 > y2 ? y1 : y2;\n  return [west, south, east, north];\n}\nvar turf_line_segment_default = lineSegment;\nexport { turf_line_segment_default as default, lineSegment };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}