{"ast":null,"code":"// index.ts\nimport { explode } from \"@turf/explode\";\nimport { center as centroid } from \"@turf/center\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, feature, point } from \"@turf/helpers\";\nfunction pointOnFeature(geojson) {\n  const fc = normalize(geojson);\n  const cent = centroid(fc);\n  let onSurface = false;\n  let i = 0;\n  while (!onSurface && i < fc.features.length) {\n    const geom = fc.features[i].geometry;\n    let x, y, x1, y1, x2, y2;\n    let onLine = false;\n    if (geom.type === \"Point\") {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      let onMultiPoint = false;\n      let k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      let k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      let j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        let k = 0;\n        const line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    const vertices = featureCollection([]);\n    for (let f = 0; f < fc.features.length; f++) {\n      vertices.features = vertices.features.concat(explode(fc.features[f]).features);\n    }\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  const ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  const ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  const pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\nvar turf_point_on_feature_default = pointOnFeature;\nexport { turf_point_on_feature_default as default, pointOnFeature };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}