{"ast":null,"code":"import { orient2d } from 'robust-predicates';\nfunction pointInPolygon(p, polygon) {\n  var i;\n  var ii;\n  var k = 0;\n  var f;\n  var u1;\n  var v1;\n  var u2;\n  var v2;\n  var currentP;\n  var nextP;\n  var x = p[0];\n  var y = p[1];\n  var numContours = polygon.length;\n  for (i = 0; i < numContours; i++) {\n    ii = 0;\n    var contour = polygon[i];\n    var contourLen = contour.length - 1;\n    currentP = contour[0];\n    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {\n      throw new Error('First and last coordinates in a ring must be the same');\n    }\n    u1 = currentP[0] - x;\n    v1 = currentP[1] - y;\n    for (ii; ii < contourLen; ii++) {\n      nextP = contour[ii + 1];\n      u2 = nextP[0] - x;\n      v2 = nextP[1] - y;\n      if (v1 === 0 && v2 === 0) {\n        if (u2 <= 0 && u1 >= 0 || u1 <= 0 && u2 >= 0) {\n          return 0;\n        }\n      } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {\n        f = orient2d(u1, u2, v1, v2, 0, 0);\n        if (f === 0) {\n          return 0;\n        }\n        if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {\n          k++;\n        }\n      }\n      currentP = nextP;\n      v1 = v2;\n      u1 = u2;\n    }\n  }\n  if (k % 2 === 0) {\n    return false;\n  }\n  return true;\n}\nexport { pointInPolygon as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}