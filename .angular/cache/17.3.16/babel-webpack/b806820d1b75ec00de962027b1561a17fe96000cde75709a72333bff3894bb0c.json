{"ast":null,"code":"// index.ts\nimport { area } from \"@turf/area\";\nimport { bbox } from \"@turf/bbox\";\nimport { bboxPolygon } from \"@turf/bbox-polygon\";\nimport { centroid } from \"@turf/centroid\";\nimport { distance } from \"@turf/distance\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { featureEach } from \"@turf/meta\";\nimport { convertArea, featureCollection } from \"@turf/helpers\";\nfunction nearestNeighborAnalysis(dataset, options) {\n  options = options || {};\n  const studyArea = options.studyArea || bboxPolygon(bbox(dataset));\n  const properties = options.properties || {};\n  const units = options.units || \"kilometers\";\n  const features = [];\n  featureEach(dataset, feature => {\n    features.push(centroid(feature));\n  });\n  const n = features.length;\n  const observedMeanDistance = features.map((feature, index) => {\n    const otherFeatures = featureCollection(features.filter((f, i) => {\n      return i !== index;\n    }));\n    return distance(feature, nearestPoint(feature, otherFeatures).geometry.coordinates, {\n      units\n    });\n  }).reduce((sum, value) => {\n    return sum + value;\n  }, 0) / n;\n  const populationDensity = n / convertArea(area(studyArea), \"meters\", units);\n  const expectedMeanDistance = 1 / (2 * Math.sqrt(populationDensity));\n  const variance = 0.26136 / Math.sqrt(n * populationDensity);\n  properties.nearestNeighborAnalysis = {\n    units,\n    arealUnits: units + \"\\xB2\",\n    observedMeanDistance,\n    expectedMeanDistance,\n    nearestNeighborIndex: observedMeanDistance / expectedMeanDistance,\n    numberOfPoints: n,\n    zScore: (observedMeanDistance - expectedMeanDistance) / variance\n  };\n  studyArea.properties = properties;\n  return studyArea;\n}\nvar turf_nearest_neighbor_analysis_default = nearestNeighborAnalysis;\nexport { turf_nearest_neighbor_analysis_default as default, nearestNeighborAnalysis };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}