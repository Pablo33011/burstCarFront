{"ast":null,"code":"// index.js\nimport { geojsonRbush as rbush } from \"@turf/geojson-rbush\";\nimport { square } from \"@turf/square\";\nimport { bbox } from \"@turf/bbox\";\nimport { truncate } from \"@turf/truncate\";\nimport { lineSegment } from \"@turf/line-segment\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { nearestPointOnLine } from \"@turf/nearest-point-on-line\";\nimport { getCoords, getCoord, getType } from \"@turf/invariant\";\nimport { featureEach, featureReduce, flattenEach } from \"@turf/meta\";\nimport { lineString, featureCollection } from \"@turf/helpers\";\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\") throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\") throw new Error(\"splitter cannot be a GeometryCollection\");\n  var truncatedSplitter = truncate(splitter, {\n    precision: 7\n  });\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter, {\n        ignoreSelfIntersections: true\n      }));\n  }\n}\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n  flattenEach(splitter, function (point) {\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    });\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features;\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results));\n    } else {\n      var search = tree.search(point);\n      if (search.features.length) {\n        var closestLine = findClosestFeature(point, search);\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine);\n        featureEach(splitLineWithPoint(closestLine, point), function (line2) {\n          results.push(line2);\n          tree.insert(line2);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\nfunction splitLineWithPoint(line, splitter) {\n  var results = [];\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter))) return featureCollection([line]);\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments);\n  var search = tree.search(splitter);\n  if (!search.features.length) return featureCollection([line]);\n  var closestSegment = findClosestFeature(splitter, search);\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(segments, function (previous, current, index) {\n    var currentCoords = getCoords(current)[1];\n    var splitterCoords = getCoord(splitter);\n    if (index === closestSegment.id) {\n      previous.push(splitterCoords);\n      results.push(lineString(previous));\n      if (pointsEquals(splitterCoords, currentCoords)) return [splitterCoords];\n      return [splitterCoords, currentCoords];\n    } else {\n      previous.push(currentCoords);\n      return previous;\n    }\n  }, initialValue);\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  if (lines.features.length === 1) return lines.features[0];\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\nvar turf_line_split_default = lineSplit;\nexport { turf_line_split_default as default, lineSplit };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}