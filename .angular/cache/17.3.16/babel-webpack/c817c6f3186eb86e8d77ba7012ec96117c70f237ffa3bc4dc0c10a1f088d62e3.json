{"ast":null,"code":"/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\nimport { p as printIonWarning } from './index-9b0d46f4.js';\n\n/**\r\n * Returns true if the selected day is equal to the reference day\r\n */\nconst isSameDay = (baseParts, compareParts) => {\n  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;\n};\n/**\r\n * Returns true is the selected day is before the reference day.\r\n */\nconst isBefore = (baseParts, compareParts) => {\n  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);\n};\n/**\r\n * Returns true is the selected day is after the reference day.\r\n */\nconst isAfter = (baseParts, compareParts) => {\n  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);\n};\nconst warnIfValueOutOfBounds = (value, min, max) => {\n  const valueArray = Array.isArray(value) ? value : [value];\n  for (const val of valueArray) {\n    if (min !== undefined && isBefore(val, min) || max !== undefined && isAfter(val, max)) {\n      printIonWarning('The value provided to ion-datetime is out of bounds.\\n\\n' + `Min: ${JSON.stringify(min)}\\n` + `Max: ${JSON.stringify(max)}\\n` + `Value: ${JSON.stringify(value)}`);\n      break;\n    }\n  }\n};\n\n/**\r\n * Determines if given year is a\r\n * leap year. Returns `true` if year\r\n * is a leap year. Returns `false`\r\n * otherwise.\r\n */\nconst isLeapYear = year => {\n  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n};\n/**\r\n * Determines the hour cycle for a user.\r\n * If the hour cycle is explicitly defined, just use that.\r\n * Otherwise, we try to derive it from either the specified\r\n * locale extension tags or from Intl.DateTimeFormat directly.\r\n */\nconst getHourCycle = (locale, hourCycle) => {\n  /**\r\n   * If developer has explicitly enabled 24-hour time\r\n   * then return early and do not look at the system default.\r\n   */\n  if (hourCycle !== undefined) {\n    return hourCycle;\n  }\n  /**\r\n   * If hourCycle was not specified, check the locale\r\n   * that is set on the user's device. We first check the\r\n   * Intl.DateTimeFormat hourCycle option as developers can encode this\r\n   * option into the locale string. Example: `en-US-u-hc-h23`\r\n   */\n  const formatted = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric'\n  });\n  const options = formatted.resolvedOptions();\n  if (options.hourCycle !== undefined) {\n    return options.hourCycle;\n  }\n  /**\r\n   * If hourCycle is not specified (either through lack\r\n   * of browser support or locale information) then fall\r\n   * back to this slower hourCycle check.\r\n   */\n  const date = new Date('5/18/2021 00:00');\n  const parts = formatted.formatToParts(date);\n  const hour = parts.find(p => p.type === 'hour');\n  if (!hour) {\n    throw new Error('Hour value not found from DateTimeFormat');\n  }\n  /**\r\n   * Midnight for h11 starts at 0:00am\r\n   * Midnight for h12 starts at 12:00am\r\n   * Midnight for h23 starts at 00:00\r\n   * Midnight for h24 starts at 24:00\r\n   */\n  switch (hour.value) {\n    case '0':\n      return 'h11';\n    case '12':\n      return 'h12';\n    case '00':\n      return 'h23';\n    case '24':\n      return 'h24';\n    default:\n      throw new Error(`Invalid hour cycle \"${hourCycle}\"`);\n  }\n};\n/**\r\n * Determine if the hour cycle uses a 24-hour format.\r\n * Returns true for h23 and h24. Returns false otherwise.\r\n * If you don't know the hourCycle, use getHourCycle above\r\n * and pass the result into this function.\r\n */\nconst is24Hour = hourCycle => {\n  return hourCycle === 'h23' || hourCycle === 'h24';\n};\n/**\r\n * Given a date object, returns the number\r\n * of days in that month.\r\n * Month value begin at 1, not 0.\r\n * i.e. January = month 1.\r\n */\nconst getNumDaysInMonth = (month, year) => {\n  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;\n};\n/**\r\n * Certain locales display month then year while\r\n * others display year then month.\r\n * We can use Intl.DateTimeFormat to determine\r\n * the ordering for each locale.\r\n * The formatOptions param can be used to customize\r\n * which pieces of a date to compare against the month\r\n * with. For example, some locales render dd/mm/yyyy\r\n * while others render mm/dd/yyyy. This function can be\r\n * used for variations of the same \"month first\" check.\r\n */\nconst isMonthFirstLocale = (locale, formatOptions = {\n  month: 'numeric',\n  year: 'numeric'\n}) => {\n  /**\r\n   * By setting month and year we guarantee that only\r\n   * month, year, and literal (slashes '/', for example)\r\n   * values are included in the formatToParts results.\r\n   *\r\n   * The ordering of the parts will be determined by\r\n   * the locale. So if the month is the first value,\r\n   * then we know month should be shown first. If the\r\n   * year is the first value, then we know year should be shown first.\r\n   *\r\n   * This ordering can be controlled by customizing the locale property.\r\n   */\n  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());\n  return parts[0].type === 'month';\n};\n/**\r\n * Determines if the given locale formats the day period (am/pm) to the\r\n * left or right of the hour.\r\n * @param locale The locale to check.\r\n * @returns `true` if the locale formats the day period to the left of the hour.\r\n */\nconst isLocaleDayPeriodRTL = locale => {\n  const parts = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric'\n  }).formatToParts(new Date());\n  return parts[0].type === 'dayPeriod';\n};\nconst ISO_8601_REGEXP =\n// eslint-disable-next-line no-useless-escape\n/^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\n// eslint-disable-next-line no-useless-escape\nconst TIME_REGEXP = /^((\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\n/**\r\n * Use to convert a string of comma separated numbers or\r\n * an array of numbers, and clean up any user input\r\n */\nconst convertToArrayOfNumbers = input => {\n  if (input === undefined) {\n    return;\n  }\n  let processedInput = input;\n  if (typeof input === 'string') {\n    // convert the string to an array of strings\n    // auto remove any whitespace and [] characters\n    processedInput = input.replace(/\\[|\\]|\\s/g, '').split(',');\n  }\n  let values;\n  if (Array.isArray(processedInput)) {\n    // ensure each value is an actual number in the returned array\n    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);\n  } else {\n    values = [processedInput];\n  }\n  return values;\n};\n/**\r\n * Extracts date information\r\n * from a .calendar-day element\r\n * into DatetimeParts.\r\n */\nconst getPartsFromCalendarDay = el => {\n  return {\n    month: parseInt(el.getAttribute('data-month'), 10),\n    day: parseInt(el.getAttribute('data-day'), 10),\n    year: parseInt(el.getAttribute('data-year'), 10),\n    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)\n  };\n};\nfunction parseDate(val) {\n  if (Array.isArray(val)) {\n    const parsedArray = [];\n    for (const valStr of val) {\n      const parsedVal = parseDate(valStr);\n      /**\r\n       * If any of the values weren't parsed correctly, consider\r\n       * the entire batch incorrect. This simplifies the type\r\n       * signatures by having \"undefined\" be a general error case\r\n       * instead of returning (Datetime | undefined)[], which is\r\n       * harder for TS to perform type narrowing on.\r\n       */\n      if (!parsedVal) {\n        return undefined;\n      }\n      parsedArray.push(parsedVal);\n    }\n    return parsedArray;\n  }\n  // manually parse IS0 cuz Date.parse cannot be trusted\n  // ISO 8601 format: 1994-12-15T13:47:20Z\n  let parse = null;\n  if (val != null && val !== '') {\n    // try parsing for just time first, HH:MM\n    parse = TIME_REGEXP.exec(val);\n    if (parse) {\n      // adjust the array so it fits nicely with the datetime parse\n      parse.unshift(undefined, undefined);\n      parse[2] = parse[3] = undefined;\n    } else {\n      // try parsing for full ISO datetime\n      parse = ISO_8601_REGEXP.exec(val);\n    }\n  }\n  if (parse === null) {\n    // wasn't able to parse the ISO datetime\n    printIonWarning(`Unable to parse date string: ${val}. Please provide a valid ISO 8601 datetime string.`);\n    return undefined;\n  }\n  // ensure all the parse values exist with at least 0\n  for (let i = 1; i < 8; i++) {\n    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;\n  }\n  // can also get second and millisecond from parse[6] and parse[7] if needed\n  return {\n    year: parse[1],\n    month: parse[2],\n    day: parse[3],\n    hour: parse[4],\n    minute: parse[5],\n    ampm: parse[4] < 12 ? 'am' : 'pm'\n  };\n}\nconst clampDate = (dateParts, minParts, maxParts) => {\n  if (minParts && isBefore(dateParts, minParts)) {\n    return minParts;\n  } else if (maxParts && isAfter(dateParts, maxParts)) {\n    return maxParts;\n  }\n  return dateParts;\n};\n/**\r\n * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).\r\n * @param hour The hour to format, should be 0-23\r\n * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.\r\n */\nconst parseAmPm = hour => {\n  return hour >= 12 ? 'pm' : 'am';\n};\n/**\r\n * Takes a max date string and creates a DatetimeParts\r\n * object, filling in any missing information.\r\n * For example, max=\"2012\" would fill in the missing\r\n * month, day, hour, and minute information.\r\n */\nconst parseMaxParts = (max, todayParts) => {\n  const result = parseDate(max);\n  /**\r\n   * If min was not a valid date then return undefined.\r\n   */\n  if (result === undefined) {\n    return;\n  }\n  const {\n    month,\n    day,\n    year,\n    hour,\n    minute\n  } = result;\n  /**\r\n   * When passing in `max` or `min`, developers\r\n   * can pass in any ISO-8601 string. This means\r\n   * that not all of the date/time fields are defined.\r\n   * For example, passing max=\"2012\" is valid even though\r\n   * there is no month, day, hour, or minute data.\r\n   * However, all of this data is required when clamping the date\r\n   * so that the correct initial value can be selected. As a result,\r\n   * we need to fill in any omitted data with the min or max values.\r\n   */\n  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;\n  const monthValue = month !== null && month !== void 0 ? month : 12;\n  return {\n    month: monthValue,\n    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),\n    /**\r\n     * Passing in \"HH:mm\" is a valid ISO-8601\r\n     * string, so we just default to the current year\r\n     * in this case.\r\n     */\n    year: yearValue,\n    hour: hour !== null && hour !== void 0 ? hour : 23,\n    minute: minute !== null && minute !== void 0 ? minute : 59\n  };\n};\n/**\r\n * Takes a min date string and creates a DatetimeParts\r\n * object, filling in any missing information.\r\n * For example, min=\"2012\" would fill in the missing\r\n * month, day, hour, and minute information.\r\n */\nconst parseMinParts = (min, todayParts) => {\n  const result = parseDate(min);\n  /**\r\n   * If min was not a valid date then return undefined.\r\n   */\n  if (result === undefined) {\n    return;\n  }\n  const {\n    month,\n    day,\n    year,\n    hour,\n    minute\n  } = result;\n  /**\r\n   * When passing in `max` or `min`, developers\r\n   * can pass in any ISO-8601 string. This means\r\n   * that not all of the date/time fields are defined.\r\n   * For example, passing max=\"2012\" is valid even though\r\n   * there is no month, day, hour, or minute data.\r\n   * However, all of this data is required when clamping the date\r\n   * so that the correct initial value can be selected. As a result,\r\n   * we need to fill in any omitted data with the min or max values.\r\n   */\n  return {\n    month: month !== null && month !== void 0 ? month : 1,\n    day: day !== null && day !== void 0 ? day : 1,\n    /**\r\n     * Passing in \"HH:mm\" is a valid ISO-8601\r\n     * string, so we just default to the current year\r\n     * in this case.\r\n     */\n    year: year !== null && year !== void 0 ? year : todayParts.year,\n    hour: hour !== null && hour !== void 0 ? hour : 0,\n    minute: minute !== null && minute !== void 0 ? minute : 0\n  };\n};\nconst twoDigit = val => {\n  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);\n};\nconst fourDigit = val => {\n  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);\n};\nfunction convertDataToISO(data) {\n  if (Array.isArray(data)) {\n    return data.map(parts => convertDataToISO(parts));\n  }\n  // https://www.w3.org/TR/NOTE-datetime\n  let rtn = '';\n  if (data.year !== undefined) {\n    // YYYY\n    rtn = fourDigit(data.year);\n    if (data.month !== undefined) {\n      // YYYY-MM\n      rtn += '-' + twoDigit(data.month);\n      if (data.day !== undefined) {\n        // YYYY-MM-DD\n        rtn += '-' + twoDigit(data.day);\n        if (data.hour !== undefined) {\n          // YYYY-MM-DDTHH:mm:SS\n          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;\n        }\n      }\n    }\n  } else if (data.hour !== undefined) {\n    // HH:mm\n    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);\n  }\n  return rtn;\n}\n/**\r\n * Converts an 12 hour value to 24 hours.\r\n */\nconst convert12HourTo24Hour = (hour, ampm) => {\n  if (ampm === undefined) {\n    return hour;\n  }\n  /**\r\n   * If AM and 12am\r\n   * then return 00:00.\r\n   * Otherwise just return\r\n   * the hour since it is\r\n   * already in 24 hour format.\r\n   */\n  if (ampm === 'am') {\n    if (hour === 12) {\n      return 0;\n    }\n    return hour;\n  }\n  /**\r\n   * If PM and 12pm\r\n   * just return 12:00\r\n   * since it is already\r\n   * in 24 hour format.\r\n   * Otherwise add 12 hours\r\n   * to the time.\r\n   */\n  if (hour === 12) {\n    return 12;\n  }\n  return hour + 12;\n};\nconst getStartOfWeek = refParts => {\n  const {\n    dayOfWeek\n  } = refParts;\n  if (dayOfWeek === null || dayOfWeek === undefined) {\n    throw new Error('No day of week provided');\n  }\n  return subtractDays(refParts, dayOfWeek);\n};\nconst getEndOfWeek = refParts => {\n  const {\n    dayOfWeek\n  } = refParts;\n  if (dayOfWeek === null || dayOfWeek === undefined) {\n    throw new Error('No day of week provided');\n  }\n  return addDays(refParts, 6 - dayOfWeek);\n};\nconst getNextDay = refParts => {\n  return addDays(refParts, 1);\n};\nconst getPreviousDay = refParts => {\n  return subtractDays(refParts, 1);\n};\nconst getPreviousWeek = refParts => {\n  return subtractDays(refParts, 7);\n};\nconst getNextWeek = refParts => {\n  return addDays(refParts, 7);\n};\n/**\r\n * Given datetime parts, subtract\r\n * numDays from the date.\r\n * Returns a new DatetimeParts object\r\n * Currently can only go backward at most 1 month.\r\n */\nconst subtractDays = (refParts, numDays) => {\n  const {\n    month,\n    day,\n    year\n  } = refParts;\n  if (day === null) {\n    throw new Error('No day provided');\n  }\n  const workingParts = {\n    month,\n    day,\n    year\n  };\n  workingParts.day = day - numDays;\n  /**\r\n   * If wrapping to previous month\r\n   * update days and decrement month\r\n   */\n  if (workingParts.day < 1) {\n    workingParts.month -= 1;\n  }\n  /**\r\n   * If moving to previous year, reset\r\n   * month to December and decrement year\r\n   */\n  if (workingParts.month < 1) {\n    workingParts.month = 12;\n    workingParts.year -= 1;\n  }\n  /**\r\n   * Determine how many days are in the current\r\n   * month\r\n   */\n  if (workingParts.day < 1) {\n    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);\n    /**\r\n     * Take num days in month and add the\r\n     * number of underflow days. This number will\r\n     * be negative.\r\n     * Example: 1 week before Jan 2, 2021 is\r\n     * December 26, 2021 so:\r\n     * 2 - 7 = -5\r\n     * 31 + (-5) = 26\r\n     */\n    workingParts.day = daysInMonth + workingParts.day;\n  }\n  return workingParts;\n};\n/**\r\n * Given datetime parts, add\r\n * numDays to the date.\r\n * Returns a new DatetimeParts object\r\n * Currently can only go forward at most 1 month.\r\n */\nconst addDays = (refParts, numDays) => {\n  const {\n    month,\n    day,\n    year\n  } = refParts;\n  if (day === null) {\n    throw new Error('No day provided');\n  }\n  const workingParts = {\n    month,\n    day,\n    year\n  };\n  const daysInMonth = getNumDaysInMonth(month, year);\n  workingParts.day = day + numDays;\n  /**\r\n   * If wrapping to next month\r\n   * update days and increment month\r\n   */\n  if (workingParts.day > daysInMonth) {\n    workingParts.day -= daysInMonth;\n    workingParts.month += 1;\n  }\n  /**\r\n   * If moving to next year, reset\r\n   * month to January and increment year\r\n   */\n  if (workingParts.month > 12) {\n    workingParts.month = 1;\n    workingParts.year += 1;\n  }\n  return workingParts;\n};\n/**\r\n * Given DatetimeParts, generate the previous month.\r\n */\nconst getPreviousMonth = refParts => {\n  /**\r\n   * If current month is January, wrap backwards\r\n   *  to December of the previous year.\r\n   */\n  const month = refParts.month === 1 ? 12 : refParts.month - 1;\n  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return {\n    month,\n    year,\n    day\n  };\n};\n/**\r\n * Given DatetimeParts, generate the next month.\r\n */\nconst getNextMonth = refParts => {\n  /**\r\n   * If current month is December, wrap forwards\r\n   *  to January of the next year.\r\n   */\n  const month = refParts.month === 12 ? 1 : refParts.month + 1;\n  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return {\n    month,\n    year,\n    day\n  };\n};\nconst changeYear = (refParts, yearDelta) => {\n  const month = refParts.month;\n  const year = refParts.year + yearDelta;\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;\n  return {\n    month,\n    year,\n    day\n  };\n};\n/**\r\n * Given DatetimeParts, generate the previous year.\r\n */\nconst getPreviousYear = refParts => {\n  return changeYear(refParts, -1);\n};\n/**\r\n * Given DatetimeParts, generate the next year.\r\n */\nconst getNextYear = refParts => {\n  return changeYear(refParts, 1);\n};\n/**\r\n * If PM, then internal value should\r\n * be converted to 24-hr time.\r\n * Does not apply when public\r\n * values are already 24-hr time.\r\n */\nconst getInternalHourValue = (hour, use24Hour, ampm) => {\n  if (use24Hour) {\n    return hour;\n  }\n  return convert12HourTo24Hour(hour, ampm);\n};\n/**\r\n * Unless otherwise stated, all month values are\r\n * 1 indexed instead of the typical 0 index in JS Date.\r\n * Example:\r\n *   January = Month 0 when using JS Date\r\n *   January = Month 1 when using this datetime util\r\n */\n/**\r\n * Given the current datetime parts and a new AM/PM value\r\n * calculate what the hour should be in 24-hour time format.\r\n * Used when toggling the AM/PM segment since we store our hours\r\n * in 24-hour time format internally.\r\n */\nconst calculateHourFromAMPM = (currentParts, newAMPM) => {\n  const {\n    ampm: currentAMPM,\n    hour\n  } = currentParts;\n  let newHour = hour;\n  /**\r\n   * If going from AM --> PM, need to update the\r\n   *\r\n   */\n  if (currentAMPM === 'am' && newAMPM === 'pm') {\n    newHour = convert12HourTo24Hour(newHour, 'pm');\n    /**\r\n     * If going from PM --> AM\r\n     */\n  } else if (currentAMPM === 'pm' && newAMPM === 'am') {\n    newHour = Math.abs(newHour - 12);\n  }\n  return newHour;\n};\n/**\r\n * Updates parts to ensure that month and day\r\n * values are valid. For days that do not exist,\r\n * or are outside the min/max bounds, the closest\r\n * valid day is used.\r\n */\nconst validateParts = (parts, minParts, maxParts) => {\n  const {\n    month,\n    day,\n    year\n  } = parts;\n  const partsCopy = clampDate(Object.assign({}, parts), minParts, maxParts);\n  const numDays = getNumDaysInMonth(month, year);\n  /**\r\n   * If the max number of days\r\n   * is greater than the day we want\r\n   * to set, update the DatetimeParts\r\n   * day field to be the max days.\r\n   */\n  if (day !== null && numDays < day) {\n    partsCopy.day = numDays;\n  }\n  /**\r\n   * If value is same day as min day,\r\n   * make sure the time value is in bounds.\r\n   */\n  if (minParts !== undefined && isSameDay(partsCopy, minParts)) {\n    /**\r\n     * If the hour is out of bounds,\r\n     * update both the hour and minute.\r\n     * This is done so that the new time\r\n     * is closest to what the user selected.\r\n     */\n    if (partsCopy.hour !== undefined && minParts.hour !== undefined) {\n      if (partsCopy.hour < minParts.hour) {\n        partsCopy.hour = minParts.hour;\n        partsCopy.minute = minParts.minute;\n        /**\r\n         * If only the minute is out of bounds,\r\n         * set it to the min minute.\r\n         */\n      } else if (partsCopy.hour === minParts.hour && partsCopy.minute !== undefined && minParts.minute !== undefined && partsCopy.minute < minParts.minute) {\n        partsCopy.minute = minParts.minute;\n      }\n    }\n  }\n  /**\r\n   * If value is same day as max day,\r\n   * make sure the time value is in bounds.\r\n   */\n  if (maxParts !== undefined && isSameDay(parts, maxParts)) {\n    /**\r\n     * If the hour is out of bounds,\r\n     * update both the hour and minute.\r\n     * This is done so that the new time\r\n     * is closest to what the user selected.\r\n     */\n    if (partsCopy.hour !== undefined && maxParts.hour !== undefined) {\n      if (partsCopy.hour > maxParts.hour) {\n        partsCopy.hour = maxParts.hour;\n        partsCopy.minute = maxParts.minute;\n        /**\r\n         * If only the minute is out of bounds,\r\n         * set it to the max minute.\r\n         */\n      } else if (partsCopy.hour === maxParts.hour && partsCopy.minute !== undefined && maxParts.minute !== undefined && partsCopy.minute > maxParts.minute) {\n        partsCopy.minute = maxParts.minute;\n      }\n    }\n  }\n  return partsCopy;\n};\n/**\r\n * Returns the closest date to refParts\r\n * that also meets the constraints of\r\n * the *Values params.\r\n */\nconst getClosestValidDate = ({\n  refParts,\n  monthValues,\n  dayValues,\n  yearValues,\n  hourValues,\n  minuteValues,\n  minParts,\n  maxParts\n}) => {\n  const {\n    hour,\n    minute,\n    day,\n    month,\n    year\n  } = refParts;\n  const copyParts = Object.assign(Object.assign({}, refParts), {\n    dayOfWeek: undefined\n  });\n  if (yearValues !== undefined) {\n    // Filters out years that are out of the min/max bounds\n    const filteredYears = yearValues.filter(year => {\n      if (minParts !== undefined && year < minParts.year) {\n        return false;\n      }\n      if (maxParts !== undefined && year > maxParts.year) {\n        return false;\n      }\n      return true;\n    });\n    copyParts.year = findClosestValue(year, filteredYears);\n  }\n  if (monthValues !== undefined) {\n    // Filters out months that are out of the min/max bounds\n    const filteredMonths = monthValues.filter(month => {\n      if (minParts !== undefined && copyParts.year === minParts.year && month < minParts.month) {\n        return false;\n      }\n      if (maxParts !== undefined && copyParts.year === maxParts.year && month > maxParts.month) {\n        return false;\n      }\n      return true;\n    });\n    copyParts.month = findClosestValue(month, filteredMonths);\n  }\n  // Day is nullable but cannot be undefined\n  if (day !== null && dayValues !== undefined) {\n    // Filters out days that are out of the min/max bounds\n    const filteredDays = dayValues.filter(day => {\n      if (minParts !== undefined && isBefore(Object.assign(Object.assign({}, copyParts), {\n        day\n      }), minParts)) {\n        return false;\n      }\n      if (maxParts !== undefined && isAfter(Object.assign(Object.assign({}, copyParts), {\n        day\n      }), maxParts)) {\n        return false;\n      }\n      return true;\n    });\n    copyParts.day = findClosestValue(day, filteredDays);\n  }\n  if (hour !== undefined && hourValues !== undefined) {\n    // Filters out hours that are out of the min/max bounds\n    const filteredHours = hourValues.filter(hour => {\n      if ((minParts === null || minParts === void 0 ? void 0 : minParts.hour) !== undefined && isSameDay(copyParts, minParts) && hour < minParts.hour) {\n        return false;\n      }\n      if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.hour) !== undefined && isSameDay(copyParts, maxParts) && hour > maxParts.hour) {\n        return false;\n      }\n      return true;\n    });\n    copyParts.hour = findClosestValue(hour, filteredHours);\n    copyParts.ampm = parseAmPm(copyParts.hour);\n  }\n  if (minute !== undefined && minuteValues !== undefined) {\n    // Filters out minutes that are out of the min/max bounds\n    const filteredMinutes = minuteValues.filter(minute => {\n      if ((minParts === null || minParts === void 0 ? void 0 : minParts.minute) !== undefined && isSameDay(copyParts, minParts) && copyParts.hour === minParts.hour && minute < minParts.minute) {\n        return false;\n      }\n      if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.minute) !== undefined && isSameDay(copyParts, maxParts) && copyParts.hour === maxParts.hour && minute > maxParts.minute) {\n        return false;\n      }\n      return true;\n    });\n    copyParts.minute = findClosestValue(minute, filteredMinutes);\n  }\n  return copyParts;\n};\n/**\r\n * Finds the value in \"values\" that is\r\n * numerically closest to \"reference\".\r\n * This function assumes that \"values\" is\r\n * already sorted in ascending order.\r\n * @param reference The reference number to use\r\n * when finding the closest value\r\n * @param values The allowed values that will be\r\n * searched to find the closest value to \"reference\"\r\n */\nconst findClosestValue = (reference, values) => {\n  let closestValue = values[0];\n  let rank = Math.abs(closestValue - reference);\n  for (let i = 1; i < values.length; i++) {\n    const value = values[i];\n    /**\r\n     * This code prioritizes the first\r\n     * closest result. Given two values\r\n     * with the same distance from reference,\r\n     * this code will prioritize the smaller of\r\n     * the two values.\r\n     */\n    const valueRank = Math.abs(value - reference);\n    if (valueRank < rank) {\n      closestValue = value;\n      rank = valueRank;\n    }\n  }\n  return closestValue;\n};\nconst getFormattedDayPeriod = dayPeriod => {\n  if (dayPeriod === undefined) {\n    return '';\n  }\n  return dayPeriod.toUpperCase();\n};\n/**\r\n * Including time zone options may lead to the rendered text showing a\r\n * different time from what was selected in the Datetime, which could cause\r\n * confusion.\r\n */\nconst stripTimeZone = formatOptions => {\n  return Object.assign(Object.assign({}, formatOptions), {\n    /**\r\n     * Setting the time zone to UTC ensures that the value shown is always the\r\n     * same as what was selected and safeguards against older Safari bugs with\r\n     * Intl.DateTimeFormat.\r\n     */\n    timeZone: 'UTC',\n    /**\r\n     * We do not want to display the time zone name\r\n     */\n    timeZoneName: undefined\n  });\n};\nconst getLocalizedTime = (locale, refParts, hourCycle, formatOptions = {\n  hour: 'numeric',\n  minute: 'numeric'\n}) => {\n  const timeParts = {\n    hour: refParts.hour,\n    minute: refParts.minute\n  };\n  if (timeParts.hour === undefined || timeParts.minute === undefined) {\n    return 'Invalid Time';\n  }\n  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, stripTimeZone(formatOptions)), {\n    /**\r\n     * We use hourCycle here instead of hour12 due to:\r\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2\r\n     */\n    hourCycle\n  })).format(new Date(convertDataToISO(Object.assign({\n    /**\r\n     * JS uses a simplified ISO 8601 format which allows for\r\n     * date-only formats and date-time formats, but not\r\n     * time-only formats: https://tc39.es/ecma262/#sec-date-time-string-format\r\n     * As a result, developers who only pass a time will get\r\n     * an \"Invalid Date\" error. To account for this, we make sure that\r\n     * year/day/month values are set when passing to new Date().\r\n     * The Intl.DateTimeFormat call above only uses the hour/minute\r\n     * values, so passing these date values should have no impact\r\n     * on the time output.\r\n     */\n    year: 2023,\n    day: 1,\n    month: 1\n  }, timeParts)) + 'Z'));\n};\n/**\r\n * Adds padding to a time value so\r\n * that it is always 2 digits.\r\n */\nconst addTimePadding = value => {\n  const valueToString = value.toString();\n  if (valueToString.length > 1) {\n    return valueToString;\n  }\n  return `0${valueToString}`;\n};\n/**\r\n * Formats 24 hour times so that\r\n * it always has 2 digits. For\r\n * 12 hour times it ensures that\r\n * hour 0 is formatted as '12'.\r\n */\nconst getFormattedHour = (hour, hourCycle) => {\n  /**\r\n   * Midnight for h11 starts at 0:00am\r\n   * Midnight for h12 starts at 12:00am\r\n   * Midnight for h23 starts at 00:00\r\n   * Midnight for h24 starts at 24:00\r\n   */\n  if (hour === 0) {\n    switch (hourCycle) {\n      case 'h11':\n        return '0';\n      case 'h12':\n        return '12';\n      case 'h23':\n        return '00';\n      case 'h24':\n        return '24';\n      default:\n        throw new Error(`Invalid hour cycle \"${hourCycle}\"`);\n    }\n  }\n  const use24Hour = is24Hour(hourCycle);\n  /**\r\n   * h23 and h24 use 24 hour times.\r\n   */\n  if (use24Hour) {\n    return addTimePadding(hour);\n  }\n  return hour.toString();\n};\n/**\r\n * Generates an aria-label to be read by screen readers\r\n * given a local, a date, and whether or not that date is\r\n * today's date.\r\n */\nconst generateDayAriaLabel = (locale, today, refParts) => {\n  if (refParts.day === null) {\n    return null;\n  }\n  /**\r\n   * MM/DD/YYYY will return midnight in the user's timezone.\r\n   */\n  const date = getNormalizedDate(refParts);\n  const labelString = new Intl.DateTimeFormat(locale, {\n    weekday: 'long',\n    month: 'long',\n    day: 'numeric',\n    timeZone: 'UTC'\n  }).format(date);\n  /**\r\n   * If date is today, prepend \"Today\" so screen readers indicate\r\n   * that the date is today.\r\n   */\n  return today ? `Today, ${labelString}` : labelString;\n};\n/**\r\n * Given a locale and a date object,\r\n * return a formatted string that includes\r\n * the month name and full year.\r\n * Example: May 2021\r\n */\nconst getMonthAndYear = (locale, refParts) => {\n  const date = getNormalizedDate(refParts);\n  return new Intl.DateTimeFormat(locale, {\n    month: 'long',\n    year: 'numeric',\n    timeZone: 'UTC'\n  }).format(date);\n};\n/**\r\n * Given a locale and a date object,\r\n * return a formatted string that includes\r\n * the numeric day.\r\n * Note: Some languages will add literal characters\r\n * to the end. This function removes those literals.\r\n * Example: 29\r\n */\nconst getDay = (locale, refParts) => {\n  return getLocalizedDateTimeParts(locale, refParts, {\n    day: 'numeric'\n  }).find(obj => obj.type === 'day').value;\n};\n/**\r\n * Given a locale and a date object,\r\n * return a formatted string that includes\r\n * the numeric year.\r\n * Example: 2022\r\n */\nconst getYear = (locale, refParts) => {\n  return getLocalizedDateTime(locale, refParts, {\n    year: 'numeric'\n  });\n};\n/**\r\n * Given reference parts, return a JS Date object\r\n * with a normalized time.\r\n */\nconst getNormalizedDate = refParts => {\n  var _a, _b, _c;\n  const timeString = refParts.hour !== undefined && refParts.minute !== undefined ? ` ${refParts.hour}:${refParts.minute}` : '';\n  /**\r\n   * We use / notation here for the date\r\n   * so we do not need to do extra work and pad values with zeroes.\r\n   * Values such as YYYY-MM are still valid, so\r\n   * we add fallback values so we still get\r\n   * a valid date otherwise we will pass in a string\r\n   * like \"//2023\". Some browsers, such as Chrome, will\r\n   * account for this and still return a valid date. However,\r\n   * this is not a consistent behavior across all browsers.\r\n   */\n  return new Date(`${(_a = refParts.month) !== null && _a !== void 0 ? _a : 1}/${(_b = refParts.day) !== null && _b !== void 0 ? _b : 1}/${(_c = refParts.year) !== null && _c !== void 0 ? _c : 2023}${timeString} GMT+0000`);\n};\n/**\r\n * Given a locale, DatetimeParts, and options\r\n * format the DatetimeParts according to the options\r\n * and locale combination. This returns a string. If\r\n * you want an array of the individual pieces\r\n * that make up the localized date string, use\r\n * getLocalizedDateTimeParts.\r\n */\nconst getLocalizedDateTime = (locale, refParts, options) => {\n  const date = getNormalizedDate(refParts);\n  return getDateTimeFormat(locale, stripTimeZone(options)).format(date);\n};\n/**\r\n * Given a locale, DatetimeParts, and options\r\n * format the DatetimeParts according to the options\r\n * and locale combination. This returns an array of\r\n * each piece of the date.\r\n */\nconst getLocalizedDateTimeParts = (locale, refParts, options) => {\n  const date = getNormalizedDate(refParts);\n  return getDateTimeFormat(locale, options).formatToParts(date);\n};\n/**\r\n * Wrapper function for Intl.DateTimeFormat.\r\n * Allows developers to apply an allowed format to DatetimeParts.\r\n * This function also has built in safeguards for older browser bugs\r\n * with Intl.DateTimeFormat.\r\n */\nconst getDateTimeFormat = (locale, options) => {\n  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {\n    timeZone: 'UTC'\n  }));\n};\n/**\r\n * Gets a localized version of \"Today\"\r\n * Falls back to \"Today\" in English for\r\n * browsers that do not support RelativeTimeFormat.\r\n */\nconst getTodayLabel = locale => {\n  if ('RelativeTimeFormat' in Intl) {\n    const label = new Intl.RelativeTimeFormat(locale, {\n      numeric: 'auto'\n    }).format(0, 'day');\n    return label.charAt(0).toUpperCase() + label.slice(1);\n  } else {\n    return 'Today';\n  }\n};\n/**\r\n * When calling toISOString(), the browser\r\n * will convert the date to UTC time by either adding\r\n * or subtracting the time zone offset.\r\n * To work around this, we need to either add\r\n * or subtract the time zone offset to the Date\r\n * object prior to calling toISOString().\r\n * This allows us to get an ISO string\r\n * that is in the user's time zone.\r\n *\r\n * Example:\r\n * Time zone offset is 240\r\n * Meaning: The browser needs to add 240 minutes\r\n * to the Date object to get UTC time.\r\n * What Ionic does: We subtract 240 minutes\r\n * from the Date object. The browser then adds\r\n * 240 minutes in toISOString(). The result\r\n * is a time that is in the user's time zone\r\n * and not UTC.\r\n *\r\n * Note: Some timezones include minute adjustments\r\n * such as 30 or 45 minutes. This is why we use setMinutes\r\n * instead of setHours.\r\n * Example: India Standard Time\r\n * Timezone offset: -330 = -5.5 hours.\r\n *\r\n * List of timezones with 30 and 45 minute timezones:\r\n * https://www.timeanddate.com/time/time-zones-interesting.html\r\n */\nconst removeDateTzOffset = date => {\n  const tzOffset = date.getTimezoneOffset();\n  date.setMinutes(date.getMinutes() - tzOffset);\n  return date;\n};\nconst DATE_AM = removeDateTzOffset(new Date('2022T01:00'));\nconst DATE_PM = removeDateTzOffset(new Date('2022T13:00'));\n/**\r\n * Formats the locale's string representation of the day period (am/pm) for a given\r\n * ref parts day period.\r\n *\r\n * @param locale The locale to format the day period in.\r\n * @param value The date string, in ISO format.\r\n * @returns The localized day period (am/pm) representation of the given value.\r\n */\nconst getLocalizedDayPeriod = (locale, dayPeriod) => {\n  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;\n  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {\n    hour: 'numeric',\n    timeZone: 'UTC'\n  }).formatToParts(date).find(part => part.type === 'dayPeriod');\n  if (localizedDayPeriod) {\n    return localizedDayPeriod.value;\n  }\n  return getFormattedDayPeriod(dayPeriod);\n};\n/**\r\n * Formats the datetime's value to a string, for use in the native input.\r\n *\r\n * @param value The value to format, either an ISO string or an array thereof.\r\n */\nconst formatValue = value => {\n  return Array.isArray(value) ? value.join(',') : value;\n};\n\n/**\r\n * Returns the current date as\r\n * an ISO string in the user's\r\n * time zone.\r\n */\nconst getToday = () => {\n  /**\r\n   * ion-datetime intentionally does not\r\n   * parse time zones/do automatic time zone\r\n   * conversion when accepting user input.\r\n   * However when we get today's date string,\r\n   * we want it formatted relative to the user's\r\n   * time zone.\r\n   *\r\n   * When calling toISOString(), the browser\r\n   * will convert the date to UTC time by either adding\r\n   * or subtracting the time zone offset.\r\n   * To work around this, we need to either add\r\n   * or subtract the time zone offset to the Date\r\n   * object prior to calling toISOString().\r\n   * This allows us to get an ISO string\r\n   * that is in the user's time zone.\r\n   */\n  return removeDateTzOffset(new Date()).toISOString();\n};\nconst minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];\n// h11 hour system uses 0-11. Midnight starts at 0:00am.\nconst hour11 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n// h12 hour system uses 0-12. Midnight starts at 12:00am.\nconst hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n// h23 hour system uses 0-23. Midnight starts at 0:00.\nconst hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];\n// h24 hour system uses 1-24. Midnight starts at 24:00.\nconst hour24 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 0];\n/**\r\n * Given a locale and a mode,\r\n * return an array with formatted days\r\n * of the week. iOS should display days\r\n * such as \"Mon\" or \"Tue\".\r\n * MD should display days such as \"M\"\r\n * or \"T\".\r\n */\nconst getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {\n  /**\r\n   * Nov 1st, 2020 starts on a Sunday.\r\n   * ion-datetime assumes weeks start on Sunday,\r\n   * but is configurable via `firstDayOfWeek`.\r\n   */\n  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';\n  const intl = new Intl.DateTimeFormat(locale, {\n    weekday: weekdayFormat\n  });\n  const startDate = new Date('11/01/2020');\n  const daysOfWeek = [];\n  /**\r\n   * For each day of the week,\r\n   * get the day name.\r\n   */\n  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {\n    const currentDate = new Date(startDate);\n    currentDate.setDate(currentDate.getDate() + i);\n    daysOfWeek.push(intl.format(currentDate));\n  }\n  return daysOfWeek;\n};\n/**\r\n * Returns an array containing all of the\r\n * days in a month for a given year. Values are\r\n * aligned with a week calendar starting on\r\n * the firstDayOfWeek value (Sunday by default)\r\n * using null values.\r\n */\nconst getDaysOfMonth = (month, year, firstDayOfWeek) => {\n  const numDays = getNumDaysInMonth(month, year);\n  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();\n  /**\r\n   * To get the first day of the month aligned on the correct\r\n   * day of the week, we need to determine how many \"filler\" days\r\n   * to generate. These filler days as empty/disabled buttons\r\n   * that fill the space of the days of the week before the first\r\n   * of the month.\r\n   *\r\n   * There are two cases here:\r\n   *\r\n   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset\r\n   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,\r\n   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have\r\n   * the first day of the month.\r\n   *\r\n   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset\r\n   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,\r\n   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have\r\n   * the first day of the month.\r\n   */\n  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);\n  let days = [];\n  for (let i = 1; i <= numDays; i++) {\n    days.push({\n      day: i,\n      dayOfWeek: (offset + i) % 7\n    });\n  }\n  for (let i = 0; i <= offset; i++) {\n    days = [{\n      day: null,\n      dayOfWeek: null\n    }, ...days];\n  }\n  return days;\n};\n/**\r\n * Returns an array of pre-defined hour\r\n * values based on the provided hourCycle.\r\n */\nconst getHourData = hourCycle => {\n  switch (hourCycle) {\n    case 'h11':\n      return hour11;\n    case 'h12':\n      return hour12;\n    case 'h23':\n      return hour23;\n    case 'h24':\n      return hour24;\n    default:\n      throw new Error(`Invalid hour cycle \"${hourCycle}\"`);\n  }\n};\n/**\r\n * Given a local, reference datetime parts and option\r\n * max/min bound datetime parts, calculate the acceptable\r\n * hour and minute values according to the bounds and locale.\r\n */\nconst generateTime = (locale, refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {\n  const computedHourCycle = getHourCycle(locale, hourCycle);\n  const use24Hour = is24Hour(computedHourCycle);\n  let processedHours = getHourData(computedHourCycle);\n  let processedMinutes = minutes;\n  let isAMAllowed = true;\n  let isPMAllowed = true;\n  if (hourValues) {\n    processedHours = processedHours.filter(hour => hourValues.includes(hour));\n  }\n  if (minuteValues) {\n    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));\n  }\n  if (minParts) {\n    /**\r\n     * If ref day is the same as the\r\n     * minimum allowed day, filter hour/minute\r\n     * values according to min hour and minute.\r\n     */\n    if (isSameDay(refParts, minParts)) {\n      /**\r\n       * Users may not always set the hour/minute for\r\n       * min value (i.e. 2021-06-02) so we should allow\r\n       * all hours/minutes in that case.\r\n       */\n      if (minParts.hour !== undefined) {\n        processedHours = processedHours.filter(hour => {\n          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;\n          return (use24Hour ? hour : convertedHour) >= minParts.hour;\n        });\n        isAMAllowed = minParts.hour < 13;\n      }\n      if (minParts.minute !== undefined) {\n        /**\r\n         * The minimum minute range should not be enforced when\r\n         * the hour is greater than the min hour.\r\n         *\r\n         * For example with a minimum range of 09:30, users\r\n         * should be able to select 10:00-10:29 and beyond.\r\n         */\n        let isPastMinHour = false;\n        if (minParts.hour !== undefined && refParts.hour !== undefined) {\n          if (refParts.hour > minParts.hour) {\n            isPastMinHour = true;\n          }\n        }\n        processedMinutes = processedMinutes.filter(minute => {\n          if (isPastMinHour) {\n            return true;\n          }\n          return minute >= minParts.minute;\n        });\n      }\n      /**\r\n       * If ref day is before minimum\r\n       * day do not render any hours/minute values\r\n       */\n    } else if (isBefore(refParts, minParts)) {\n      processedHours = [];\n      processedMinutes = [];\n      isAMAllowed = isPMAllowed = false;\n    }\n  }\n  if (maxParts) {\n    /**\r\n     * If ref day is the same as the\r\n     * maximum allowed day, filter hour/minute\r\n     * values according to max hour and minute.\r\n     */\n    if (isSameDay(refParts, maxParts)) {\n      /**\r\n       * Users may not always set the hour/minute for\r\n       * max value (i.e. 2021-06-02) so we should allow\r\n       * all hours/minutes in that case.\r\n       */\n      if (maxParts.hour !== undefined) {\n        processedHours = processedHours.filter(hour => {\n          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;\n          return (use24Hour ? hour : convertedHour) <= maxParts.hour;\n        });\n        isPMAllowed = maxParts.hour >= 12;\n      }\n      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {\n        // The available minutes should only be filtered when the hour is the same as the max hour.\n        // For example if the max hour is 10:30 and the current hour is 10:00,\n        // users should be able to select 00-30 minutes.\n        // If the current hour is 09:00, users should be able to select 00-60 minutes.\n        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);\n      }\n      /**\r\n       * If ref day is after minimum\r\n       * day do not render any hours/minute values\r\n       */\n    } else if (isAfter(refParts, maxParts)) {\n      processedHours = [];\n      processedMinutes = [];\n      isAMAllowed = isPMAllowed = false;\n    }\n  }\n  return {\n    hours: processedHours,\n    minutes: processedMinutes,\n    am: isAMAllowed,\n    pm: isPMAllowed\n  };\n};\n/**\r\n * Given DatetimeParts, generate the previous,\r\n * current, and and next months.\r\n */\nconst generateMonths = (refParts, forcedDate) => {\n  const current = {\n    month: refParts.month,\n    year: refParts.year,\n    day: refParts.day\n  };\n  /**\r\n   * If we're forcing a month to appear, and it's different from the current month,\r\n   * ensure it appears by replacing the next or previous month as appropriate.\r\n   */\n  if (forcedDate !== undefined && (refParts.month !== forcedDate.month || refParts.year !== forcedDate.year)) {\n    const forced = {\n      month: forcedDate.month,\n      year: forcedDate.year,\n      day: forcedDate.day\n    };\n    const forcedMonthIsBefore = isBefore(forced, current);\n    return forcedMonthIsBefore ? [forced, current, getNextMonth(refParts)] : [getPreviousMonth(refParts), current, forced];\n  }\n  return [getPreviousMonth(refParts), current, getNextMonth(refParts)];\n};\nconst getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {\n  month: 'long'\n}) => {\n  const {\n    year\n  } = refParts;\n  const months = [];\n  if (monthValues !== undefined) {\n    let processedMonths = monthValues;\n    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {\n      processedMonths = processedMonths.filter(month => month <= maxParts.month);\n    }\n    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {\n      processedMonths = processedMonths.filter(month => month >= minParts.month);\n    }\n    processedMonths.forEach(processedMonth => {\n      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);\n      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      months.push({\n        text: monthString,\n        value: processedMonth\n      });\n    });\n  } else {\n    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;\n    const minMonth = minParts && minParts.year === year ? minParts.month : 1;\n    for (let i = minMonth; i <= maxMonth; i++) {\n      /**\r\n       *\r\n       * There is a bug on iOS 14 where\r\n       * Intl.DateTimeFormat takes into account\r\n       * the local timezone offset when formatting dates.\r\n       *\r\n       * Forcing the timezone to 'UTC' fixes the issue. However,\r\n       * we should keep this workaround as it is safer. In the event\r\n       * this breaks in another browser, we will not be impacted\r\n       * because all dates will be interpreted in UTC.\r\n       *\r\n       * Example:\r\n       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // \"March\"\r\n       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // \"April\"\r\n       *\r\n       * In certain timezones, iOS 14 shows the wrong\r\n       * date for .toUTCString(). To combat this, we\r\n       * force all of the timezones to GMT+0000 (UTC).\r\n       *\r\n       * Example:\r\n       * Time Zone: Central European Standard Time\r\n       * new Date('1/1/1992').toUTCString() // \"Tue, 31 Dec 1991 23:00:00 GMT\"\r\n       * new Date('1/1/1992 GMT+0000').toUTCString() // \"Wed, 01 Jan 1992 00:00:00 GMT\"\r\n       */\n      const date = new Date(`${i}/1/${year} GMT+0000`);\n      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      months.push({\n        text: monthString,\n        value: i\n      });\n    }\n  }\n  return months;\n};\n/**\r\n * Returns information regarding\r\n * selectable dates (i.e 1st, 2nd, 3rd, etc)\r\n * within a reference month.\r\n * @param locale The locale to format the date with\r\n * @param refParts The reference month/year to generate dates for\r\n * @param minParts The minimum bound on the date that can be returned\r\n * @param maxParts The maximum bound on the date that can be returned\r\n * @param dayValues The allowed date values\r\n * @returns Date data to be used in ion-picker-column-internal\r\n */\nconst getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {\n  day: 'numeric'\n}) => {\n  const {\n    month,\n    year\n  } = refParts;\n  const days = [];\n  /**\r\n   * If we have max/min bounds that in the same\r\n   * month/year as the refParts, we should\r\n   * use the define day as the max/min day.\r\n   * Otherwise, fallback to the max/min days in a month.\r\n   */\n  const numDaysInMonth = getNumDaysInMonth(month, year);\n  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== undefined && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;\n  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== undefined && minParts.year === year && minParts.month === month ? minParts.day : 1;\n  if (dayValues !== undefined) {\n    let processedDays = dayValues;\n    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);\n    processedDays.forEach(processedDay => {\n      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);\n      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      days.push({\n        text: dayString,\n        value: processedDay\n      });\n    });\n  } else {\n    for (let i = minDay; i <= maxDay; i++) {\n      const date = new Date(`${month}/${i}/${year} GMT+0000`);\n      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {\n        timeZone: 'UTC'\n      })).format(date);\n      days.push({\n        text: dayString,\n        value: i\n      });\n    }\n  }\n  return days;\n};\nconst getYearColumnData = (locale, refParts, minParts, maxParts, yearValues) => {\n  var _a, _b;\n  let processedYears = [];\n  if (yearValues !== undefined) {\n    processedYears = yearValues;\n    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {\n      processedYears = processedYears.filter(year => year <= maxParts.year);\n    }\n    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {\n      processedYears = processedYears.filter(year => year >= minParts.year);\n    }\n  } else {\n    const {\n      year\n    } = refParts;\n    const maxYear = (_a = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a !== void 0 ? _a : year;\n    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;\n    for (let i = minYear; i <= maxYear; i++) {\n      processedYears.push(i);\n    }\n  }\n  return processedYears.map(year => ({\n    text: getYear(locale, {\n      year,\n      month: refParts.month,\n      day: refParts.day\n    }),\n    value: year\n  }));\n};\n/**\r\n * Given a starting date and an upper bound,\r\n * this functions returns an array of all\r\n * month objects in that range.\r\n */\nconst getAllMonthsInRange = (currentParts, maxParts) => {\n  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {\n    return [currentParts];\n  }\n  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];\n};\n/**\r\n * Creates and returns picker items\r\n * that represent the days in a month.\r\n * Example: \"Thu, Jun 2\"\r\n */\nconst getCombinedDateColumnData = (locale, todayParts, minParts, maxParts, dayValues, monthValues) => {\n  let items = [];\n  let parts = [];\n  /**\r\n   * Get all month objects from the min date\r\n   * to the max date. Note: Do not use getMonthColumnData\r\n   * as that function only generates dates within a\r\n   * single year.\r\n   */\n  let months = getAllMonthsInRange(minParts, maxParts);\n  /**\r\n   * Filter out any disallowed month values.\r\n   */\n  if (monthValues) {\n    months = months.filter(({\n      month\n    }) => monthValues.includes(month));\n  }\n  /**\r\n   * Get all of the days in the month.\r\n   * From there, generate an array where\r\n   * each item has the month, date, and day\r\n   * of work as the text.\r\n   */\n  months.forEach(monthObject => {\n    const referenceMonth = {\n      month: monthObject.month,\n      day: null,\n      year: monthObject.year\n    };\n    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {\n      month: 'short',\n      day: 'numeric',\n      weekday: 'short'\n    });\n    const dateParts = [];\n    const dateColumnItems = [];\n    monthDays.forEach(dayObject => {\n      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {\n        day: dayObject.value\n      }), todayParts);\n      /**\r\n       * Today's date should read as \"Today\" (localized)\r\n       * not the actual date string\r\n       */\n      dateColumnItems.push({\n        text: isToday ? getTodayLabel(locale) : dayObject.text,\n        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`\n      });\n      /**\r\n       * When selecting a date in the wheel picker\r\n       * we need access to the raw datetime parts data.\r\n       * The picker column only accepts values of\r\n       * type string or number, so we need to return\r\n       * two sets of data: A data set to be passed\r\n       * to the picker column, and a data set to\r\n       * be used to reference the raw data when\r\n       * updating the picker column value.\r\n       */\n      dateParts.push({\n        month: referenceMonth.month,\n        year: referenceMonth.year,\n        day: dayObject.value\n      });\n    });\n    parts = [...parts, ...dateParts];\n    items = [...items, ...dateColumnItems];\n  });\n  return {\n    parts,\n    items\n  };\n};\nconst getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues) => {\n  const computedHourCycle = getHourCycle(locale, hourCycle);\n  const use24Hour = is24Hour(computedHourCycle);\n  const {\n    hours,\n    minutes,\n    am,\n    pm\n  } = generateTime(locale, refParts, computedHourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues);\n  const hoursItems = hours.map(hour => {\n    return {\n      text: getFormattedHour(hour, computedHourCycle),\n      value: getInternalHourValue(hour, use24Hour, refParts.ampm)\n    };\n  });\n  const minutesItems = minutes.map(minute => {\n    return {\n      text: addTimePadding(minute),\n      value: minute\n    };\n  });\n  const dayPeriodItems = [];\n  if (am && !use24Hour) {\n    dayPeriodItems.push({\n      text: getLocalizedDayPeriod(locale, 'am'),\n      value: 'am'\n    });\n  }\n  if (pm && !use24Hour) {\n    dayPeriodItems.push({\n      text: getLocalizedDayPeriod(locale, 'pm'),\n      value: 'pm'\n    });\n  }\n  return {\n    minutesData: minutesItems,\n    hoursData: hoursItems,\n    dayPeriodData: dayPeriodItems\n  };\n};\nexport { getNumDaysInMonth as A, getCombinedDateColumnData as B, getMonthColumnData as C, getDayColumnData as D, getYearColumnData as E, isMonthFirstLocale as F, getTimeColumnsData as G, isLocaleDayPeriodRTL as H, getDaysOfWeek as I, getMonthAndYear as J, getDaysOfMonth as K, getHourCycle as L, getLocalizedTime as M, getLocalizedDateTime as N, formatValue as O, clampDate as P, parseAmPm as Q, calculateHourFromAMPM as R, getDay as a, isAfter as b, isSameDay as c, getPreviousMonth as d, getNextMonth as e, getPartsFromCalendarDay as f, generateDayAriaLabel as g, getNextYear as h, isBefore as i, getPreviousYear as j, getEndOfWeek as k, getStartOfWeek as l, getPreviousDay as m, getNextDay as n, getPreviousWeek as o, getNextWeek as p, parseMinParts as q, parseMaxParts as r, parseDate as s, convertToArrayOfNumbers as t, convertDataToISO as u, validateParts as v, warnIfValueOutOfBounds as w, getToday as x, getClosestValidDate as y, generateMonths as z };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}