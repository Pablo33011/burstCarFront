{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\n// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { area } from \"@turf/area\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { explode } from \"@turf/explode\";\nimport { collectionOf as collectionOf2 } from \"@turf/invariant\";\nimport { polygon, multiPolygon, featureCollection, isObject as isObject2 } from \"@turf/helpers\";\n\n// lib/grid-to-matrix.js\nimport { getCoords, collectionOf } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nfunction gridToMatrix(grid, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = [];\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0);\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n  return matrix;\n}\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n\n// index.ts\nimport { isoBands } from \"marchingsquares\";\nfunction isobands(pointGrid, breaks, options) {\n  options = options || {};\n  if (!isObject2(options)) throw new Error(\"options is invalid\");\n  const zProperty = options.zProperty || \"elevation\";\n  const commonProperties = options.commonProperties || {};\n  const breaksProperties = options.breaksProperties || [];\n  collectionOf2(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks is not an Array\");\n  if (!isObject2(commonProperties)) throw new Error(\"commonProperties is not an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties is not an Array\");\n  const matrix = gridToMatrix(pointGrid, {\n    zProperty,\n    flip: true\n  });\n  let contours = createContourLines(matrix, breaks, zProperty);\n  contours = rescaleContours(contours, matrix, pointGrid);\n  const multipolygons = contours.map((contour, index) => {\n    if (breaksProperties[index] && !isObject2(breaksProperties[index])) {\n      throw new Error(\"Each mappedProperty is required to be an Object\");\n    }\n    const contourProperties = __spreadValues(__spreadValues({}, commonProperties), breaksProperties[index]);\n    contourProperties[zProperty] = contour[zProperty];\n    const multiP = multiPolygon(contour.groupedRings, contourProperties);\n    return multiP;\n  });\n  return featureCollection(multipolygons);\n}\nfunction createContourLines(matrix, breaks, property) {\n  const contours = [];\n  for (let i = 1; i < breaks.length; i++) {\n    const lowerBand = +breaks[i - 1];\n    const upperBand = +breaks[i];\n    const isobandsCoords = isoBands(matrix, lowerBand, upperBand - lowerBand);\n    const nestedRings = orderByArea(isobandsCoords);\n    const groupedRings = groupNestedRings(nestedRings);\n    contours.push({\n      groupedRings,\n      [property]: lowerBand + \"-\" + upperBand\n    });\n  }\n  return contours;\n}\nfunction rescaleContours(contours, matrix, points) {\n  const gridBbox = bbox(points);\n  const originalWidth = gridBbox[2] - gridBbox[0];\n  const originalHeigth = gridBbox[3] - gridBbox[1];\n  const x0 = gridBbox[0];\n  const y0 = gridBbox[1];\n  const matrixWidth = matrix[0].length - 1;\n  const matrixHeight = matrix.length - 1;\n  const scaleX = originalWidth / matrixWidth;\n  const scaleY = originalHeigth / matrixHeight;\n  return contours.map(function (contour) {\n    contour.groupedRings = contour.groupedRings.map(function (lineRingSet) {\n      return lineRingSet.map(function (lineRing) {\n        return lineRing.map(point => [point[0] * scaleX + x0, point[1] * scaleY + y0]);\n      });\n    });\n    return contour;\n  });\n}\nfunction orderByArea(ringsCoords) {\n  const ringsWithArea = ringsCoords.map(function (coords) {\n    return {\n      ring: coords,\n      area: area(polygon([coords]))\n    };\n  });\n  ringsWithArea.sort(function (a, b) {\n    return b.area - a.area;\n  });\n  return ringsWithArea.map(function (x) {\n    return x.ring;\n  });\n}\nfunction groupNestedRings(orderedLinearRings) {\n  const lrList = orderedLinearRings.map(lr => {\n    return {\n      lrCoordinates: lr,\n      grouped: false\n    };\n  });\n  const groupedLinearRingsCoords = [];\n  while (!allGrouped(lrList)) {\n    for (let i = 0; i < lrList.length; i++) {\n      if (!lrList[i].grouped) {\n        const group = [];\n        group.push(lrList[i].lrCoordinates);\n        lrList[i].grouped = true;\n        const outerMostPoly = polygon([lrList[i].lrCoordinates]);\n        for (let j = i + 1; j < lrList.length; j++) {\n          if (!lrList[j].grouped) {\n            const lrPoly = polygon([lrList[j].lrCoordinates]);\n            if (isInside(lrPoly, outerMostPoly)) {\n              group.push(lrList[j].lrCoordinates);\n              lrList[j].grouped = true;\n            }\n          }\n        }\n        groupedLinearRingsCoords.push(group);\n      }\n    }\n  }\n  return groupedLinearRingsCoords;\n}\nfunction isInside(testPolygon, targetPolygon) {\n  const points = explode(testPolygon);\n  for (let i = 0; i < points.features.length; i++) {\n    if (!booleanPointInPolygon(points.features[i], targetPolygon)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction allGrouped(list) {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].grouped === false) {\n      return false;\n    }\n  }\n  return true;\n}\nvar turf_isobands_default = isobands;\nexport { turf_isobands_default as default, isobands };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}