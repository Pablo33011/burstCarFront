{"ast":null,"code":"/*!\n* MarchingSquaresJS\n* version 1.3.3\n* https://github.com/RaumZeit/MarchingSquares.js\n*\n* @license GNU Affero General Public License.\n* Copyright (c) 2015-2019 Ronny Lorenz <ronny@tbi.univie.ac.at>\n*/\n\n/*\n *  Compute the distance of a value 'v' from 'a' through linear interpolation\n *  between the values of 'a' and 'b'\n *\n *  Note, that we assume that 'a' and 'b' have unit distance (i.e. 1)\n */\nfunction linear(a, b, v) {\n  if (a < b) return (v - a) / (b - a);\n  return (a - v) / (a - b);\n}\n\n/*\n *  Compute the distance of a pair of values ('v0', 'v1') from 'a' through linear interpolation\n *  between the values of 'a' and 'b'\n *\n *  This function assumes that exactly one value, 'v0' or 'v1', is actually located\n *  between 'a' and 'b', and choses the right one automagically\n *\n *  Note, that we assume that 'a' and 'b' have unit distance (i.e. 1)\n */\nfunction linear_ab(a, b, v0, v1) {\n  var tmp;\n  if (v0 > v1) {\n    tmp = v0;\n    v0 = v1;\n    v1 = tmp;\n  }\n  if (a < b) {\n    if (a < v0) return (v0 - a) / (b - a);else return (v1 - a) / (b - a);\n  } else if (a > v1) {\n    return (a - v1) / (a - b);\n  }\n  return (a - v0) / (a - b);\n}\n\n/*\n *  Compute the distance of a pair of values ('v0', 'v1') from 'a' through linear interpolation\n *  between the values of 'a' and 'b'\n *\n *  This function automagically choses the value 'vN' that is closer to 'a'\n *\n *  Note, that we assume that 'a' and 'b' have unit distance (i.e. 1)\n */\nfunction linear_a(a, b, minV, maxV) {\n  if (a < b) return (minV - a) / (b - a);\n  return (a - maxV) / (a - b);\n}\n\n/*\n *  Compute the distance of a pair of values ('v0', 'v1') from 'a' through linear interpolation\n *  between the values of 'a' and 'b'\n *\n *  This function automagically choses the value 'vN' that is closer to 'b'\n *\n *  Note, that we assume that 'a' and 'b' have unit distance (i.e. 1)\n */\nfunction linear_b(a, b, minV, maxV) {\n  if (a < b) return (maxV - a) / (b - a);\n  return (a - minV) / (a - b);\n}\nfunction Options() {\n  /* Settings common to all implemented algorithms */\n  this.successCallback = null;\n  this.verbose = false;\n  this.polygons = false;\n  this.polygons_full = false;\n  this.linearRing = true;\n  this.noQuadTree = false;\n  this.noFrame = false;\n}\n\n/* Compose settings specific to IsoBands algorithm */\nfunction isoBandOptions(userSettings) {\n  var i, key, val, bandOptions, optionKeys;\n  bandOptions = new Options();\n  userSettings = userSettings ? userSettings : {};\n  optionKeys = Object.keys(bandOptions);\n  for (i = 0; i < optionKeys.length; i++) {\n    key = optionKeys[i];\n    val = userSettings[key];\n    if (typeof val !== 'undefined' && val !== null) bandOptions[key] = val;\n  }\n\n  /* restore compatibility */\n  bandOptions.polygons_full = !bandOptions.polygons;\n\n  /* add interpolation functions (not yet user customizable) */\n  bandOptions.interpolate = linear_ab;\n  bandOptions.interpolate_a = linear_a;\n  bandOptions.interpolate_b = linear_b;\n  return bandOptions;\n}\n\n/* Compose settings specific to IsoLines algorithm */\nfunction isoLineOptions(userSettings) {\n  var i, key, val, lineOptions, optionKeys;\n  lineOptions = new Options();\n  userSettings = userSettings ? userSettings : {};\n  optionKeys = Object.keys(lineOptions);\n  for (i = 0; i < optionKeys.length; i++) {\n    key = optionKeys[i];\n    val = userSettings[key];\n    if (typeof val !== 'undefined' && val !== null) lineOptions[key] = val;\n  }\n\n  /* restore compatibility */\n  lineOptions.polygons_full = !lineOptions.polygons;\n\n  /* add interpolation functions (not yet user customizable) */\n  lineOptions.interpolate = linear;\n  return lineOptions;\n}\nfunction cell2Polygons(cell, x, y, settings) {\n  var polygons = [];\n  cell.polygons.forEach(function (p) {\n    p.forEach(function (pp) {\n      pp[0] += x;\n      pp[1] += y;\n    });\n    if (settings.linearRing) p.push(p[0]);\n    polygons.push(p);\n  });\n  return polygons;\n}\nfunction entry_coordinate(x, y, mode, path) {\n  if (mode === 0) {\n    /* down */\n    x += 1;\n    y += path[0][1];\n  } else if (mode === 1) {\n    /* left */\n    x += path[0][0];\n  } else if (mode === 2) {\n    /* up */\n    y += path[0][1];\n  } else if (mode === 3) {\n    /* right */\n    x += path[0][0];\n    y += 1;\n  }\n  return [x, y];\n}\nfunction skip_coordinate(x, y, mode) {\n  if (mode === 0) {\n    /* down */\n    x++;\n  } else if (mode === 1) ;else if (mode === 2) {\n    /* up */\n    y++;\n  } else if (mode === 3) {\n    /* right */\n    x++;\n    y++;\n  }\n  return [x, y];\n}\nfunction requireFrame(data, lowerBound, upperBound) {\n  var frameRequired, cols, rows, i, j;\n  frameRequired = true;\n  cols = data[0].length;\n  rows = data.length;\n  for (j = 0; j < rows; j++) {\n    if (data[j][0] < lowerBound || data[j][0] > upperBound || data[j][cols - 1] < lowerBound || data[j][cols - 1] > upperBound) {\n      frameRequired = false;\n      break;\n    }\n  }\n  if (frameRequired && (data[rows - 1][0] < lowerBound || data[rows - 1][0] > upperBound || data[rows - 1][cols - 1] < lowerBound || data[rows - 1][cols - 1] > upperBound)) {\n    frameRequired = false;\n  }\n  if (frameRequired) for (i = 0; i < cols - 1; i++) {\n    if (data[0][i] < lowerBound || data[0][i] > upperBound || data[rows - 1][i] < lowerBound || data[rows - 1][i] > upperBound) {\n      frameRequired = false;\n      break;\n    }\n  }\n  return frameRequired;\n}\nfunction requireLineFrame(data, threshold) {\n  var frameRequired, cols, rows, i, j;\n  frameRequired = true;\n  cols = data[0].length;\n  rows = data.length;\n  for (j = 0; j < rows; j++) {\n    if (data[j][0] >= threshold || data[j][cols - 1] >= threshold) {\n      frameRequired = false;\n      break;\n    }\n  }\n  if (frameRequired && (data[rows - 1][0] >= threshold || data[rows - 1][cols - 1] >= threshold)) {\n    frameRequired = false;\n  }\n  if (frameRequired) for (i = 0; i < cols - 1; i++) {\n    if (data[0][i] >= threshold || data[rows - 1][i] > threshold) {\n      frameRequired = false;\n      break;\n    }\n  }\n  return frameRequired;\n}\nfunction traceBandPaths(data, cellGrid, settings) {\n  var nextedge, path, e, ee, s, ve, enter, x, y, finalized, origin, cc, dir, count, point, found_entry;\n  var polygons = [];\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n\n  /*\n   * directions for out-of-grid moves are:\n   * 0 ... \"down\",\n   * 1 ... \"left\",\n   * 2 ... \"up\",\n   * 3 ... \"right\"\n   */\n  var valid_entries = [['rt', 'rb'], /* down */\n  ['br', 'bl'], /* left */\n  ['lb', 'lt'], /* up */\n  ['tl', 'tr'] /* right */];\n  var add_x = [0, -1, 0, 1];\n  var add_y = [-1, 0, 1, 0];\n  var available_starts = ['bl', 'lb', 'lt', 'tl', 'tr', 'rt', 'rb', 'br'];\n  var entry_dir = {\n    bl: 1,\n    br: 1,\n    lb: 2,\n    lt: 2,\n    tl: 3,\n    tr: 3,\n    rt: 0,\n    rb: 0\n  };\n  if (requireFrame(data, settings.minV, settings.maxV)) {\n    if (settings.linearRing) polygons.push([[0, 0], [0, rows], [cols, rows], [cols, 0], [0, 0]]);else polygons.push([[0, 0], [0, rows], [cols, rows], [cols, 0]]);\n  }\n\n  /* finally, start tracing back first polygon(s) */\n  cellGrid.forEach(function (a, i) {\n    a.forEach(function (cell, j) {\n      nextedge = null;\n\n      /* trace paths for all available edges that go through this cell */\n      for (e = 0; e < 8; e++) {\n        nextedge = available_starts[e];\n        if (typeof cell.edges[nextedge] !== 'object') continue;\n\n        /* start a new, full path */\n        path = [];\n        ee = cell.edges[nextedge];\n        enter = nextedge;\n        x = i;\n        y = j;\n        finalized = false;\n        origin = [i + ee.path[0][0], j + ee.path[0][1]];\n\n        /* add start coordinate */\n        path.push(origin);\n\n        /* start traceback */\n        while (!finalized) {\n          cc = cellGrid[x][y];\n          if (typeof cc.edges[enter] !== 'object') break;\n          ee = cc.edges[enter];\n\n          /* remove edge from cell */\n          delete cc.edges[enter];\n\n          /* add last point of edge to path arra, since we extend a polygon */\n          point = ee.path[1];\n          point[0] += x;\n          point[1] += y;\n          path.push(point);\n          enter = ee.move.enter;\n          x = x + ee.move.x;\n          y = y + ee.move.y;\n\n          /* handle out-of-grid moves */\n          if (typeof cellGrid[x] === 'undefined' || typeof cellGrid[x][y] === 'undefined') {\n            dir = 0;\n            count = 0;\n            if (x === cols) {\n              x--;\n              dir = 0; /* move downwards */\n            } else if (x < 0) {\n              x++;\n              dir = 2; /* move upwards */\n            } else if (y === rows) {\n              y--;\n              dir = 3; /* move right */\n            } else if (y < 0) {\n              y++;\n              dir = 1; /* move left */\n            } else {\n              throw new Error('Left the grid somewhere in the interior!');\n            }\n            if (x === i && y === j && dir === entry_dir[nextedge]) {\n              finalized = true;\n              enter = nextedge;\n              break;\n            }\n            while (1) {\n              found_entry = false;\n              if (count > 4) throw new Error('Direction change counter overflow! This should never happen!');\n              if (!(typeof cellGrid[x] === 'undefined' || typeof cellGrid[x][y] === 'undefined')) {\n                cc = cellGrid[x][y];\n\n                /* check for re-entry */\n                for (s = 0; s < valid_entries[dir].length; s++) {\n                  ve = valid_entries[dir][s];\n                  if (typeof cc.edges[ve] === 'object') {\n                    /* found re-entry */\n                    ee = cc.edges[ve];\n                    path.push(entry_coordinate(x, y, dir, ee.path));\n                    enter = ve;\n                    found_entry = true;\n                    break;\n                  }\n                }\n              }\n              if (found_entry) {\n                break;\n              } else {\n                path.push(skip_coordinate(x, y, dir));\n                x += add_x[dir];\n                y += add_y[dir];\n\n                /* change direction if we'e moved out of grid again */\n                if (typeof cellGrid[x] === 'undefined' || typeof cellGrid[x][y] === 'undefined') {\n                  if (dir === 0 && y < 0 || dir === 1 && x < 0 || dir === 2 && y === rows || dir === 3 && x === cols) {\n                    x -= add_x[dir];\n                    y -= add_y[dir];\n                    dir = (dir + 1) % 4;\n                    count++;\n                  }\n                }\n                if (x === i && y === j && dir === entry_dir[nextedge]) {\n                  /* we are back where we started off, so finalize the polygon */\n                  finalized = true;\n                  enter = nextedge;\n                  break;\n                }\n              }\n            }\n          }\n        }\n        if (settings.linearRing && (path[path.length - 1][0] !== origin[0] || path[path.length - 1][1] !== origin[1])) path.push(origin);\n        polygons.push(path);\n      } /* end forall entry sites */\n    }); /* end foreach i */\n  }); /* end foreach j */\n\n  return polygons;\n}\nfunction traceLinePaths(data, cellGrid, settings) {\n  var nextedge, e, ee, cc, path, enter, x, y, finalized, origin, point, dir, count, found_entry, ve;\n  var polygons = [];\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n\n  /*\n   * directions for out-of-grid moves are:\n   * 0 ... \"down\",\n   * 1 ... \"left\",\n   * 2 ... \"up\",\n   * 3 ... \"right\"\n   */\n  var valid_entries = ['right', /* down */\n  'bottom', /* left */\n  'left', /* up */\n  'top' /* right */];\n  var add_x = [0, -1, 0, 1];\n  var add_y = [-1, 0, 1, 0];\n  var entry_dir = {\n    bottom: 1,\n    left: 2,\n    top: 3,\n    right: 0\n  };\n\n  /* first, detect whether we need any outer frame */\n  if (!settings.noFrame) if (requireLineFrame(data, settings.threshold)) {\n    if (settings.linearRing) polygons.push([[0, 0], [0, rows], [cols, rows], [cols, 0], [0, 0]]);else polygons.push([[0, 0], [0, rows], [cols, rows], [cols, 0]]);\n  }\n\n  /* finally, start tracing back first polygon(s) */\n\n  cellGrid.forEach(function (a, i) {\n    a.forEach(function (cell, j) {\n      nextedge = null;\n\n      /* trace paths for all available edges that go through this cell */\n      for (e = 0; e < 4; e++) {\n        nextedge = valid_entries[e];\n        if (typeof cell.edges[nextedge] !== 'object') continue;\n\n        /* start a new, full path */\n        path = [];\n        ee = cell.edges[nextedge];\n        enter = nextedge;\n        x = i;\n        y = j;\n        finalized = false;\n        origin = [i + ee.path[0][0], j + ee.path[0][1]];\n\n        /* add start coordinate */\n        path.push(origin);\n\n        /* start traceback */\n        while (!finalized) {\n          cc = cellGrid[x][y];\n          if (typeof cc.edges[enter] !== 'object') break;\n          ee = cc.edges[enter];\n\n          /* remove edge from cell */\n          delete cc.edges[enter];\n\n          /* add last point of edge to path arra, since we extend a polygon */\n          point = ee.path[1];\n          point[0] += x;\n          point[1] += y;\n          path.push(point);\n          enter = ee.move.enter;\n          x = x + ee.move.x;\n          y = y + ee.move.y;\n\n          /* handle out-of-grid moves */\n          if (typeof cellGrid[x] === 'undefined' || typeof cellGrid[x][y] === 'undefined') {\n            if (!settings.linearRing) break;\n            dir = 0;\n            count = 0;\n            if (x === cols) {\n              x--;\n              dir = 0; /* move downwards */\n            } else if (x < 0) {\n              x++;\n              dir = 2; /* move upwards */\n            } else if (y === rows) {\n              y--;\n              dir = 3; /* move right */\n            } else if (y < 0) {\n              y++;\n              dir = 1; /* move left */\n            }\n            if (x === i && y === j && dir === entry_dir[nextedge]) {\n              finalized = true;\n              enter = nextedge;\n              break;\n            }\n            while (1) {\n              found_entry = false;\n              if (count > 4) throw new Error('Direction change counter overflow! This should never happen!');\n              if (!(typeof cellGrid[x] === 'undefined' || typeof cellGrid[x][y] === 'undefined')) {\n                cc = cellGrid[x][y];\n\n                /* check for re-entry */\n                ve = valid_entries[dir];\n                if (typeof cc.edges[ve] === 'object') {\n                  /* found re-entry */\n                  ee = cc.edges[ve];\n                  path.push(entry_coordinate(x, y, dir, ee.path));\n                  enter = ve;\n                  found_entry = true;\n                  break;\n                }\n              }\n              if (found_entry) {\n                break;\n              } else {\n                path.push(skip_coordinate(x, y, dir));\n                x += add_x[dir];\n                y += add_y[dir];\n\n                /* change direction if we'e moved out of grid again */\n                if (typeof cellGrid[x] === 'undefined' || typeof cellGrid[x][y] === 'undefined') {\n                  if (dir === 0 && y < 0 || dir === 1 && x < 0 || dir === 2 && y === rows || dir === 3 && x === cols) {\n                    x -= add_x[dir];\n                    y -= add_y[dir];\n                    dir = (dir + 1) % 4;\n                    count++;\n                  }\n                }\n                if (x === i && y === j && dir === entry_dir[nextedge]) {\n                  /* we are back where we started off, so finalize the polygon */\n                  finalized = true;\n                  enter = nextedge;\n                  break;\n                }\n              }\n            }\n          }\n        }\n        if (settings.linearRing && (path[path.length - 1][0] !== origin[0] || path[path.length - 1][1] !== origin[1])) path.push(origin);\n        polygons.push(path);\n      } /* end forall entry sites */\n    }); /* end foreach i */\n  }); /* end foreach j */\n\n  return polygons;\n}\n\n/* quadTree node constructor */\nfunction TreeNode(data, x, y, dx, dy) {\n  var dx_tmp = dx,\n    dy_tmp = dy,\n    msb_x = 0,\n    msb_y = 0;\n\n  /* left-bottom corner of current quadrant */\n  this.x = x;\n  this.y = y;\n\n  /* minimum value in subtree under this node */\n  this.lowerBound = null;\n  /* maximum value in subtree under this node */\n  this.upperBound = null;\n\n  /*\n   *  child nodes are layed out in the following way:\n   *\n   *  (x, y + 1) ---- (x + 1, y + 1)\n   *  |             |              |\n   *  |      D      |      C       |\n   *  |             |              |\n   *  |----------------------------|\n   *  |             |              |\n   *  |      A      |      B       |\n   *  |             |              |\n   *  (x, y) ------------ (x + 1, y)\n   */\n  this.childA = null;\n  this.childB = null;\n  this.childC = null;\n  this.childD = null;\n  if (dx === 1 && dy === 1) {\n    /* do not further subdivision */\n    this.lowerBound = Math.min(data[y][x], data[y][x + 1], data[y + 1][x + 1], data[y + 1][x]);\n    this.upperBound = Math.max(data[y][x], data[y][x + 1], data[y + 1][x + 1], data[y + 1][x]);\n  } else {\n    /* get most significant bit from dx */\n    if (dx > 1) {\n      while (dx_tmp !== 0) {\n        dx_tmp = dx_tmp >> 1;\n        msb_x++;\n      }\n      if (dx === 1 << msb_x - 1) msb_x--;\n      dx_tmp = 1 << msb_x - 1;\n    }\n\n    /* get most significant bit from dx */\n    if (dy > 1) {\n      while (dy_tmp !== 0) {\n        dy_tmp = dy_tmp >> 1;\n        msb_y++;\n      }\n      if (dy === 1 << msb_y - 1) msb_y--;\n      dy_tmp = 1 << msb_y - 1;\n    }\n    this.childA = new TreeNode(data, x, y, dx_tmp, dy_tmp);\n    this.lowerBound = this.childA.lowerBound;\n    this.upperBound = this.childA.upperBound;\n    if (dx - dx_tmp > 0) {\n      this.childB = new TreeNode(data, x + dx_tmp, y, dx - dx_tmp, dy_tmp);\n      this.lowerBound = Math.min(this.lowerBound, this.childB.lowerBound);\n      this.upperBound = Math.max(this.upperBound, this.childB.upperBound);\n      if (dy - dy_tmp > 0) {\n        this.childC = new TreeNode(data, x + dx_tmp, y + dy_tmp, dx - dx_tmp, dy - dy_tmp);\n        this.lowerBound = Math.min(this.lowerBound, this.childC.lowerBound);\n        this.upperBound = Math.max(this.upperBound, this.childC.upperBound);\n      }\n    }\n    if (dy - dy_tmp > 0) {\n      this.childD = new TreeNode(data, x, y + dy_tmp, dx_tmp, dy - dy_tmp);\n      this.lowerBound = Math.min(this.lowerBound, this.childD.lowerBound);\n      this.upperBound = Math.max(this.upperBound, this.childD.upperBound);\n    }\n  }\n}\n\n/**\n *  Retrieve a list of cells within a particular range of values by\n *  recursivly traversing the quad tree to it's leaves.\n *\n *  @param  subsumed  If 'true' include all cells that are completely\n *                    subsumed within the specified range. Otherwise,\n *                    return only cells where at least one corner is\n *                    outside the specified range.\n *\n *  @return   An array of objects 'o' where each object has exactly two\n *            properties: 'o.x' and 'o.y' denoting the left-bottom corner\n *            of the corresponding cell.\n */\nTreeNode.prototype.cellsInBand = function (lowerBound, upperBound, subsumed) {\n  var cells = [];\n  subsumed = typeof subsumed === 'undefined' ? true : subsumed;\n  if (this.lowerBound > upperBound || this.upperBound < lowerBound) return cells;\n  if (!(this.childA || this.childB || this.childC || this.childD)) {\n    if (subsumed || this.lowerBound <= lowerBound || this.upperBound >= upperBound) {\n      cells.push({\n        x: this.x,\n        y: this.y\n      });\n    }\n  } else {\n    if (this.childA) cells = cells.concat(this.childA.cellsInBand(lowerBound, upperBound, subsumed));\n    if (this.childB) cells = cells.concat(this.childB.cellsInBand(lowerBound, upperBound, subsumed));\n    if (this.childD) cells = cells.concat(this.childD.cellsInBand(lowerBound, upperBound, subsumed));\n    if (this.childC) cells = cells.concat(this.childC.cellsInBand(lowerBound, upperBound, subsumed));\n  }\n  return cells;\n};\nTreeNode.prototype.cellsBelowThreshold = function (threshold, subsumed) {\n  var cells = [];\n  subsumed = typeof subsumed === 'undefined' ? true : subsumed;\n  if (this.lowerBound > threshold) return cells;\n  if (!(this.childA || this.childB || this.childC || this.childD)) {\n    if (subsumed || this.upperBound >= threshold) {\n      cells.push({\n        x: this.x,\n        y: this.y\n      });\n    }\n  } else {\n    if (this.childA) cells = cells.concat(this.childA.cellsBelowThreshold(threshold, subsumed));\n    if (this.childB) cells = cells.concat(this.childB.cellsBelowThreshold(threshold, subsumed));\n    if (this.childD) cells = cells.concat(this.childD.cellsBelowThreshold(threshold, subsumed));\n    if (this.childC) cells = cells.concat(this.childC.cellsBelowThreshold(threshold, subsumed));\n  }\n  return cells;\n};\n\n/*\n * Given a scalar field `data` construct a QuadTree\n * to efficiently lookup those parts of the scalar\n * field where values are within a particular\n * range of [lowerbound, upperbound] limits.\n */\nfunction QuadTree(data) {\n  var i, cols;\n\n  /* do some input checking */\n  if (!data) throw new Error('data is required');\n  if (!Array.isArray(data) || !Array.isArray(data[0])) throw new Error('data must be scalar field, i.e. array of arrays');\n  if (data.length < 2) throw new Error('data must contain at least two rows');\n\n  /* check if we've got a regular grid */\n  cols = data[0].length;\n  if (cols < 2) throw new Error('data must contain at least two columns');\n  for (i = 1; i < data.length; i++) {\n    if (!Array.isArray(data[i])) throw new Error('Row ' + i + ' is not an array');\n    if (data[i].length != cols) throw new Error('unequal row lengths detected, please provide a regular grid');\n  }\n\n  /* create pre-processing object */\n  this.data = data;\n  /* root node, i.e. entry to the data */\n  this.root = new TreeNode(data, 0, 0, data[0].length - 1, data.length - 1);\n}\n\n/* eslint no-console: [\"error\", { allow: [\"log\"] }] */\n\n/*\n * Compute the iso lines for a scalar 2D field given\n * a certain threshold by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n */\n\nfunction isoLines(input, threshold, options) {\n  var settings,\n    i,\n    j,\n    useQuadTree = false,\n    multiLine = false,\n    tree = null,\n    root = null,\n    data = null,\n    cellGrid = null,\n    linePolygons = null,\n    ret = [];\n\n  /* validation */\n  if (!input) throw new Error('data is required');\n  if (threshold === undefined || threshold === null) throw new Error('threshold is required');\n  if (!!options && typeof options !== 'object') throw new Error('options must be an object');\n\n  /* process options */\n  settings = isoLineOptions(options);\n\n  /* check for input data */\n  if (input instanceof QuadTree) {\n    tree = input;\n    root = input.root;\n    data = input.data;\n    if (!settings.noQuadTree) useQuadTree = true;\n  } else if (Array.isArray(input) && Array.isArray(input[0])) {\n    data = input;\n  } else {\n    throw new Error('input is neither array of arrays nor object retrieved from \\'QuadTree()\\'');\n  }\n\n  /* check and prepare input threshold(s) */\n  if (Array.isArray(threshold)) {\n    multiLine = true;\n\n    /* activate QuadTree optimization if not explicitly forbidden by user settings */\n    if (!settings.noQuadTree) useQuadTree = true;\n\n    /* check if all minV are numbers */\n    for (i = 0; i < threshold.length; i++) if (isNaN(+threshold[i])) throw new Error('threshold[' + i + '] is not a number');\n  } else {\n    if (isNaN(+threshold)) throw new Error('threshold must be a number or array of numbers');\n    threshold = [threshold];\n  }\n\n  /* create QuadTree root node if not already present */\n  if (useQuadTree && !root) {\n    tree = new QuadTree(data);\n    root = tree.root;\n    data = tree.data;\n  }\n  if (settings.verbose) {\n    if (settings.polygons) console.log('MarchingSquaresJS-isoLines: returning single lines (polygons) for each grid cell');else console.log('MarchingSquaresJS-isoLines: returning line paths (polygons) for entire data grid');\n    if (multiLine) console.log('MarchingSquaresJS-isoLines: multiple lines requested, returning array of line paths instead of lines for a single threshold');\n  }\n\n  /* Done with all input validation, now let's start computing stuff */\n\n  /* loop over all threhsold values */\n  threshold.forEach(function (t, i) {\n    linePolygons = [];\n\n    /* store bounds for current computation in settings object */\n    settings.threshold = t;\n    if (settings.verbose) console.log('MarchingSquaresJS-isoLines: computing iso lines for threshold ' + t);\n    if (settings.polygons) {\n      /* compose list of polygons for each single cell */\n      if (useQuadTree) {\n        /* go through list of cells retrieved from QuadTree */\n        root.cellsBelowThreshold(settings.threshold, true).forEach(function (c) {\n          linePolygons = linePolygons.concat(cell2Polygons(prepareCell(data, c.x, c.y, settings), c.x, c.y, settings));\n        });\n      } else {\n        /* go through entire array of input data */\n        for (j = 0; j < data.length - 1; ++j) {\n          for (i = 0; i < data[0].length - 1; ++i) linePolygons = linePolygons.concat(cell2Polygons(prepareCell(data, i, j, settings), i, j, settings));\n        }\n      }\n    } else {\n      /* sparse grid of input data cells */\n      cellGrid = [];\n      for (i = 0; i < data[0].length - 1; ++i) cellGrid[i] = [];\n\n      /* compose list of polygons for entire input grid */\n      if (useQuadTree) {\n        /* collect the cells */\n        root.cellsBelowThreshold(settings.threshold, false).forEach(function (c) {\n          cellGrid[c.x][c.y] = prepareCell(data, c.x, c.y, settings);\n        });\n      } else {\n        /* prepare cells */\n        for (i = 0; i < data[0].length - 1; ++i) {\n          for (j = 0; j < data.length - 1; ++j) {\n            cellGrid[i][j] = prepareCell(data, i, j, settings);\n          }\n        }\n      }\n      linePolygons = traceLinePaths(data, cellGrid, settings);\n    }\n\n    /* finally, add polygons to output array */\n    if (multiLine) ret.push(linePolygons);else ret = linePolygons;\n    if (typeof settings.successCallback === 'function') settings.successCallback(ret, t);\n  });\n  return ret;\n}\n\n/*\n * Thats all for the public interface, below follows the actual\n * implementation\n */\n\n/*\n * ################################\n * Isocontour implementation below\n * ################################\n */\n\nfunction prepareCell(grid, x, y, settings) {\n  var left, right, top, bottom, average, cell;\n  var cval = 0;\n  var x3 = grid[y + 1][x];\n  var x2 = grid[y + 1][x + 1];\n  var x1 = grid[y][x + 1];\n  var x0 = grid[y][x];\n  var threshold = settings.threshold;\n\n  /*\n   * Note that missing data within the grid will result\n   * in horribly failing to trace full polygon paths\n   */\n  if (isNaN(x0) || isNaN(x1) || isNaN(x2) || isNaN(x3)) {\n    return;\n  }\n\n  /*\n   * Here we detect the type of the cell\n   *\n   * x3 ---- x2\n   * |      |\n   * |      |\n   * x0 ---- x1\n   *\n   * with edge points\n   *\n   * x0 = (x,y),\n   * x1 = (x + 1, y),\n   * x2 = (x + 1, y + 1), and\n   * x3 = (x, y + 1)\n   *\n   * and compute the polygon intersections with the edges\n   * of the cell. Each edge value may be (i) smaller, or (ii)\n   * greater or equal to the iso line threshold. We encode\n   * this property using 1 bit of information, where\n   *\n   * 0 ... below,\n   * 1 ... above or equal\n   *\n   * Then we store the cells value as vector\n   *\n   * cval = (x0, x1, x2, x3)\n   *\n   * where x0 is the least significant bit (0th),\n   * x1 the 2nd bit, and so on. This essentially\n   * enables us to work with a single integer number\n   */\n\n  cval |= x3 >= threshold ? 8 : 0;\n  cval |= x2 >= threshold ? 4 : 0;\n  cval |= x1 >= threshold ? 2 : 0;\n  cval |= x0 >= threshold ? 1 : 0;\n\n  /* make sure cval is a number */\n  cval = +cval;\n\n  /* compose the cell object */\n  cell = {\n    cval: cval,\n    polygons: [],\n    edges: {},\n    x0: x0,\n    x1: x1,\n    x2: x2,\n    x3: x3\n  };\n\n  /*\n   * Compute interpolated intersections of the polygon(s)\n   * with the cell borders and (i) add edges for polygon\n   * trace-back, or (ii) a list of small closed polygons\n   */\n  switch (cval) {\n    case 0:\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, 0]]);\n      break;\n    case 15:\n      /* cell is outside (above) threshold, no polygons */\n      break;\n    case 14:\n      /* 1110 */\n      left = settings.interpolate(x0, x3, threshold);\n      bottom = settings.interpolate(x0, x1, threshold);\n      if (settings.polygons_full) {\n        cell.edges.left = {\n          path: [[0, left], [bottom, 0]],\n          move: {\n            x: 0,\n            y: -1,\n            enter: 'top'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, left], [bottom, 0]]);\n      break;\n    case 13:\n      /* 1101 */\n      bottom = settings.interpolate(x0, x1, threshold);\n      right = settings.interpolate(x1, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.bottom = {\n          path: [[bottom, 0], [1, right]],\n          move: {\n            x: 1,\n            y: 0,\n            enter: 'left'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[bottom, 0], [1, right], [1, 0]]);\n      break;\n    case 11:\n      /* 1011 */\n      right = settings.interpolate(x1, x2, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.right = {\n          path: [[1, right], [top, 1]],\n          move: {\n            x: 0,\n            y: 1,\n            enter: 'bottom'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[1, right], [top, 1], [1, 1]]);\n      break;\n    case 7:\n      /* 0111 */\n      left = settings.interpolate(x0, x3, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.top = {\n          path: [[top, 1], [0, left]],\n          move: {\n            x: -1,\n            y: 0,\n            enter: 'right'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[top, 1], [0, left], [0, 1]]);\n      break;\n    case 1:\n      /* 0001 */\n      left = settings.interpolate(x0, x3, threshold);\n      bottom = settings.interpolate(x0, x1, threshold);\n      if (settings.polygons_full) {\n        cell.edges.bottom = {\n          path: [[bottom, 0], [0, left]],\n          move: {\n            x: -1,\n            y: 0,\n            enter: 'right'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[bottom, 0], [0, left], [0, 1], [1, 1], [1, 0]]);\n      break;\n    case 2:\n      /* 0010 */\n      bottom = settings.interpolate(x0, x1, threshold);\n      right = settings.interpolate(x1, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.right = {\n          path: [[1, right], [bottom, 0]],\n          move: {\n            x: 0,\n            y: -1,\n            enter: 'top'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, right], [bottom, 0]]);\n      break;\n    case 4:\n      /* 0100 */\n      right = settings.interpolate(x1, x2, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.top = {\n          path: [[top, 1], [1, right]],\n          move: {\n            x: 1,\n            y: 0,\n            enter: 'left'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, 1], [top, 1], [1, right], [1, 0]]);\n      break;\n    case 8:\n      /* 1000 */\n      left = settings.interpolate(x0, x3, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.left = {\n          path: [[0, left], [top, 1]],\n          move: {\n            x: 0,\n            y: 1,\n            enter: 'bottom'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, left], [top, 1], [1, 1], [1, 0]]);\n      break;\n    case 12:\n      /* 1100 */\n      left = settings.interpolate(x0, x3, threshold);\n      right = settings.interpolate(x1, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.left = {\n          path: [[0, left], [1, right]],\n          move: {\n            x: 1,\n            y: 0,\n            enter: 'left'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, left], [1, right], [1, 0]]);\n      break;\n    case 9:\n      /* 1001 */\n      bottom = settings.interpolate(x0, x1, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.bottom = {\n          path: [[bottom, 0], [top, 1]],\n          move: {\n            x: 0,\n            y: 1,\n            enter: 'bottom'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[bottom, 0], [top, 1], [1, 1], [1, 0]]);\n      break;\n    case 3:\n      /* 0011 */\n      left = settings.interpolate(x0, x3, threshold);\n      right = settings.interpolate(x1, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.right = {\n          path: [[1, right], [0, left]],\n          move: {\n            x: -1,\n            y: 0,\n            enter: 'right'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, left], [0, 1], [1, 1], [1, right]]);\n      break;\n    case 6:\n      /* 0110 */\n      bottom = settings.interpolate(x0, x1, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      if (settings.polygons_full) {\n        cell.edges.top = {\n          path: [[top, 1], [bottom, 0]],\n          move: {\n            x: 0,\n            y: -1,\n            enter: 'top'\n          }\n        };\n      }\n      if (settings.polygons) cell.polygons.push([[0, 0], [0, 1], [top, 1], [bottom, 0]]);\n      break;\n    case 10:\n      /* 1010 */\n      left = settings.interpolate(x0, x3, threshold);\n      right = settings.interpolate(x1, x2, threshold);\n      bottom = settings.interpolate(x0, x1, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      average = (x0 + x1 + x2 + x3) / 4;\n      if (settings.polygons_full) {\n        if (average < threshold) {\n          cell.edges.left = {\n            path: [[0, left], [top, 1]],\n            move: {\n              x: 0,\n              y: 1,\n              enter: 'bottom'\n            }\n          };\n          cell.edges.right = {\n            path: [[1, right], [bottom, 0]],\n            move: {\n              x: 0,\n              y: -1,\n              enter: 'top'\n            }\n          };\n        } else {\n          cell.edges.right = {\n            path: [[1, right], [top, 1]],\n            move: {\n              x: 0,\n              y: 1,\n              enter: 'bottom'\n            }\n          };\n          cell.edges.left = {\n            path: [[0, left], [bottom, 0]],\n            move: {\n              x: 0,\n              y: -1,\n              enter: 'top'\n            }\n          };\n        }\n      }\n      if (settings.polygons) {\n        if (average < threshold) {\n          cell.polygons.push([[0, 0], [0, left], [top, 1], [1, 1], [1, right], [bottom, 0]]);\n        } else {\n          cell.polygons.push([[0, 0], [0, left], [bottom, 0]]);\n          cell.polygons.push([[top, 1], [1, 1], [1, right]]);\n        }\n      }\n      break;\n    case 5:\n      /* 0101 */\n      left = settings.interpolate(x0, x3, threshold);\n      right = settings.interpolate(x1, x2, threshold);\n      bottom = settings.interpolate(x0, x1, threshold);\n      top = settings.interpolate(x3, x2, threshold);\n      average = (x0 + x1 + x2 + x3) / 4;\n      if (settings.polygons_full) {\n        if (average < threshold) {\n          cell.edges.bottom = {\n            path: [[bottom, 0], [0, left]],\n            move: {\n              x: -1,\n              y: 0,\n              enter: 'right'\n            }\n          };\n          cell.edges.top = {\n            path: [[top, 1], [1, right]],\n            move: {\n              x: 1,\n              y: 0,\n              enter: 'left'\n            }\n          };\n        } else {\n          cell.edges.top = {\n            path: [[top, 1], [0, left]],\n            move: {\n              x: -1,\n              y: 0,\n              enter: 'right'\n            }\n          };\n          cell.edges.bottom = {\n            path: [[bottom, 0], [1, right]],\n            move: {\n              x: 1,\n              y: 0,\n              enter: 'left'\n            }\n          };\n        }\n      }\n      if (settings.polygons) {\n        if (average < threshold) {\n          cell.polygons.push([[0, left], [0, 1], [top, 1], [1, right], [1, 0], [bottom, 0]]);\n        } else {\n          cell.polygons.push([[0, left], [0, 1], [top, 1]]);\n          cell.polygons.push([[bottom, 0], [1, right], [1, 0]]);\n        }\n      }\n      break;\n  }\n  return cell;\n}\n\n/* eslint no-console: [\"error\", { allow: [\"log\"] }] */\n\n/*\n * lookup table to generate polygon paths or edges required to\n * trace the full polygon(s)\n */\nvar shapeCoordinates = {\n  square: function (cell, x0, x1, x2, x3, opt) {\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, 0]]);\n  },\n  triangle_bl: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, leftbottom], [bottomleft, 0], [0, 0]]);\n  },\n  triangle_br: function (cell, x0, x1, x2, x3, opt) {\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomright, 0], [1, rightbottom], [1, 0]]);\n  },\n  triangle_tr: function (cell, x0, x1, x2, x3, opt) {\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.rt = {\n        path: [[1, righttop], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[1, righttop], [topright, 1], [1, 1]]);\n  },\n  triangle_tl: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tl = {\n        path: [[topleft, 1], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, lefttop], [0, 1], [topleft, 1]]);\n  },\n  tetragon_t: function (cell, x0, x1, x2, x3, opt) {\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.rt = {\n        path: [[1, righttop], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, lefttop], [0, 1], [1, 1], [1, righttop]]);\n  },\n  tetragon_r: function (cell, x0, x1, x2, x3, opt) {\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomright, 0], [topright, 1], [1, 1], [1, 0]]);\n  },\n  tetragon_b: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [1, rightbottom], [1, 0]]);\n  },\n  tetragon_l: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tl = {\n        path: [[topleft, 1], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, 1], [topleft, 1], [bottomleft, 0]]);\n  },\n  tetragon_bl: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [0, leftbottom], [0, lefttop], [bottomright, 0]]);\n  },\n  tetragon_br: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [1, righttop], [1, rightbottom], [bottomright, 0]]);\n  },\n  tetragon_tr: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.rb = {\n        path: [[1, rightbottom], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[1, rightbottom], [topleft, 1], [topright, 1], [1, righttop]]);\n  },\n  tetragon_tl: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tr = {\n        path: [[topright, 1], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[topright, 1], [0, leftbottom], [0, lefttop], [topleft, 1]]);\n  },\n  tetragon_lr: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lt = {\n        path: [[0, lefttop], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, leftbottom], [0, lefttop], [1, righttop], [1, rightbottom]]);\n  },\n  tetragon_tb: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tr = {\n        path: [[topright, 1], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [topleft, 1], [topright, 1], [bottomright, 0]]);\n  },\n  pentagon_tr: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tl = {\n        path: [[topleft, 1], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, 1], [topleft, 1], [1, rightbottom], [1, 0]]);\n  },\n  pentagon_tl: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [topright, 1], [1, 1], [1, 0]]);\n  },\n  pentagon_br: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.rt = {\n        path: [[1, righttop], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, 1], [1, 1], [1, righttop], [bottomleft, 0]]);\n  },\n  pentagon_bl: function (cell, x0, x1, x2, x3, opt) {\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, lefttop], [0, 1], [1, 1], [1, 0], [bottomright, 0]]);\n  },\n  pentagon_tr_rl: function (cell, x0, x1, x2, x3, opt) {\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tl = {\n        path: [[topleft, 1], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, lefttop], [0, 1], [topleft, 1], [1, righttop], [1, rightbottom]]);\n  },\n  pentagon_rb_bt: function (cell, x0, x1, x2, x3, opt) {\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.rt = {\n        path: [[1, righttop], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[topright, 1], [1, 1], [1, righttop], [bottomright, 0], [bottomleft, 0]]);\n  },\n  pentagon_bl_lr: function (cell, x0, x1, x2, x3, opt) {\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomright, 0], [0, leftbottom], [0, lefttop], [1, rightbottom], [1, 0]]);\n  },\n  pentagon_lt_tb: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [topleft, 1], [topright, 1], [bottomleft, 0]]);\n  },\n  pentagon_bl_tb: function (cell, x0, x1, x2, x3, opt) {\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n      cell.edges.tl = {\n        path: [[topleft, 1], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, lefttop], [0, 1], [topleft, 1], [bottomright, 0], [bottomleft, 0]]);\n  },\n  pentagon_lt_rl: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate(x1, x3, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lt = {\n        path: [[0, lefttop], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n      cell.edges.rt = {\n        path: [[1, righttop], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, leftbottom], [0, lefttop], [topright, 1], [1, 1], [1, righttop]]);\n  },\n  pentagon_tr_bt: function (cell, x0, x1, x2, x3, opt) {\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[topleft, 1], [topright, 1], [1, rightbottom], [1, 0], [bottomright, 0]]);\n  },\n  pentagon_rb_lr: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [1, righttop], [1, rightbottom], [bottomleft, 0]]);\n  },\n  hexagon_lt_tr: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [topleft, 1], [topright, 1], [1, rightbottom], [1, 0]]);\n  },\n  hexagon_bl_lt: function (cell, x0, x1, x2, x3, opt) {\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomright, 0], [0, leftbottom], [0, lefttop], [topright, 1], [1, 1], [1, 0]]);\n  },\n  hexagon_bl_rb: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n      cell.edges.rt = {\n        path: [[1, righttop], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [0, lefttop], [0, 1], [1, 1], [1, righttop], [bottomright, 0]]);\n  },\n  hexagon_tr_rb: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.tl = {\n        path: [[topleft, 1], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, 1], [topleft, 1], [1, righttop], [1, rightbottom], [bottomleft, 0]]);\n  },\n  hexagon_lt_rb: function (cell, x0, x1, x2, x3, opt) {\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n      cell.edges.rt = {\n        path: [[1, righttop], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [topright, 1], [1, 1], [1, righttop], [bottomleft, 0]]);\n  },\n  hexagon_bl_tr: function (cell, x0, x1, x2, x3, opt) {\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n      cell.edges.tl = {\n        path: [[topleft, 1], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomright, 0], [0, lefttop], [0, 1], [topleft, 1], [1, rightbottom], [1, 0]]);\n  },\n  heptagon_tr: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var topright = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [topright, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'br'\n        }\n      };\n      cell.edges.rt = {\n        path: [[1, righttop], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [0, leftbottom], [0, lefttop], [topright, 1], [1, 1], [1, righttop], [bottomright, 0]]);\n  },\n  heptagon_bl: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.lb = {\n        path: [[0, leftbottom], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [bottomleft, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tl'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[0, 0], [0, leftbottom], [topleft, 1], [topright, 1], [1, righttop], [1, rightbottom], [bottomleft, 0]]);\n  },\n  heptagon_tl: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [0, lefttop]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rt'\n        }\n      };\n      cell.edges.tl = {\n        path: [[topleft, 1], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [0, lefttop], [0, 1], [topleft, 1], [1, righttop], [1, rightbottom], [bottomright, 0]]);\n  },\n  heptagon_br: function (cell, x0, x1, x2, x3, opt) {\n    var bottomright = opt.interpolate(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.br = {\n        path: [[bottomright, 0], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [1, rightbottom]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lb'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomright, 0], [0, leftbottom], [0, lefttop], [topleft, 1], [topright, 1], [1, rightbottom], [1, 0]]);\n  },\n  octagon: function (cell, x0, x1, x2, x3, opt) {\n    var bottomleft = opt.interpolate_a(x0, x1, opt.minV, opt.maxV);\n    var bottomright = opt.interpolate_b(x0, x1, opt.minV, opt.maxV);\n    var leftbottom = opt.interpolate_a(x0, x3, opt.minV, opt.maxV);\n    var lefttop = opt.interpolate_b(x0, x3, opt.minV, opt.maxV);\n    var topleft = opt.interpolate_a(x3, x2, opt.minV, opt.maxV);\n    var topright = opt.interpolate_b(x3, x2, opt.minV, opt.maxV);\n    var righttop = opt.interpolate_b(x1, x2, opt.minV, opt.maxV);\n    var rightbottom = opt.interpolate_a(x1, x2, opt.minV, opt.maxV);\n    if (opt.polygons_full) {\n      cell.edges.bl = {\n        path: [[bottomleft, 0], [0, leftbottom]],\n        move: {\n          x: -1,\n          y: 0,\n          enter: 'rb'\n        }\n      };\n      cell.edges.lt = {\n        path: [[0, lefttop], [topleft, 1]],\n        move: {\n          x: 0,\n          y: 1,\n          enter: 'bl'\n        }\n      };\n      cell.edges.tr = {\n        path: [[topright, 1], [1, righttop]],\n        move: {\n          x: 1,\n          y: 0,\n          enter: 'lt'\n        }\n      };\n      cell.edges.rb = {\n        path: [[1, rightbottom], [bottomright, 0]],\n        move: {\n          x: 0,\n          y: -1,\n          enter: 'tr'\n        }\n      };\n    }\n    if (opt.polygons) cell.polygons.push([[bottomleft, 0], [0, leftbottom], [0, lefttop], [topleft, 1], [topright, 1], [1, righttop], [1, rightbottom], [bottomright, 0]]);\n  }\n};\n\n/*\n * Compute isobands(s) for a scalar 2D field given a certain\n * threshold and a bandwidth by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n * either for individual polygons within each grid cell, or the\n * outline of connected polygons.\n */\nfunction isoBands(input, minV, bandWidth, options) {\n  var i,\n    j,\n    settings,\n    useQuadTree = false,\n    tree = null,\n    root = null,\n    data = null,\n    cellGrid = null,\n    multiBand = false,\n    bw = [],\n    bandPolygons = [],\n    ret = [];\n\n  /* basic input validation */\n  if (!input) throw new Error('data is required');\n  if (minV === undefined || minV === null) throw new Error('lowerBound is required');\n  if (bandWidth === undefined || bandWidth === null) throw new Error('bandWidth is required');\n  if (!!options && typeof options !== 'object') throw new Error('options must be an object');\n  settings = isoBandOptions(options);\n\n  /* check for input data */\n  if (input instanceof QuadTree) {\n    tree = input;\n    root = input.root;\n    data = input.data;\n    if (!settings.noQuadTree) useQuadTree = true;\n  } else if (Array.isArray(input) && Array.isArray(input[0])) {\n    data = input;\n  } else {\n    throw new Error('input is neither array of arrays nor object retrieved from \\'QuadTree()\\'');\n  }\n\n  /* check and prepare input thresholds */\n  if (Array.isArray(minV)) {\n    multiBand = true;\n\n    /* activate QuadTree optimization if not explicitly forbidden by user settings */\n    if (!settings.noQuadTree) useQuadTree = true;\n\n    /* check if all minV are numbers */\n    for (i = 0; i < minV.length; i++) if (isNaN(+minV[i])) throw new Error('lowerBound[' + i + '] is not a number');\n    if (Array.isArray(bandWidth)) {\n      if (minV.length !== bandWidth.length) throw new Error('lowerBound and bandWidth have unequal lengths');\n\n      /* check bandwidth values */\n      for (i = 0; i < bandWidth.length; i++) if (isNaN(+bandWidth[i])) throw new Error('bandWidth[' + i + '] is not a number');\n    } else {\n      if (isNaN(+bandWidth)) throw new Error('bandWidth must be a number');\n      bw = [];\n      for (i = 0; i < minV.length; i++) {\n        bw.push(bandWidth);\n      }\n      bandWidth = bw;\n    }\n  } else {\n    if (isNaN(+minV)) throw new Error('lowerBound must be a number');\n    minV = [minV];\n    if (isNaN(+bandWidth)) throw new Error('bandWidth must be a number');\n    bandWidth = [bandWidth];\n  }\n\n  /* create QuadTree root node if not already present */\n  if (useQuadTree && !root) {\n    tree = new QuadTree(data);\n    root = tree.root;\n    data = tree.data;\n  }\n  if (settings.verbose) {\n    if (settings.polygons) console.log('MarchingSquaresJS-isoBands: returning single polygons for each grid cell');else console.log('MarchingSquaresJS-isoBands: returning polygon paths for entire data grid');\n    if (multiBand) console.log('MarchingSquaresJS-isoBands: multiple bands requested, returning array of band polygons instead of polygons for a single band');\n  }\n\n  /* Done with all input validation, now let's start computing stuff */\n\n  /* loop over all minV values */\n  minV.forEach(function (lowerBound, b) {\n    bandPolygons = [];\n\n    /* store bounds for current computation in settings object */\n    settings.minV = lowerBound;\n    settings.maxV = lowerBound + bandWidth[b];\n    if (settings.verbose) console.log('MarchingSquaresJS-isoBands: computing isobands for [' + lowerBound + ':' + (lowerBound + bandWidth[b]) + ']');\n    if (settings.polygons) {\n      /* compose list of polygons for each single cell */\n      if (useQuadTree) {\n        /* go through list of cells retrieved from QuadTree */\n        root.cellsInBand(settings.minV, settings.maxV, true).forEach(function (c) {\n          bandPolygons = bandPolygons.concat(cell2Polygons(prepareCell$1(data, c.x, c.y, settings), c.x, c.y, settings));\n        });\n      } else {\n        /* go through entire array of input data */\n        for (j = 0; j < data.length - 1; ++j) {\n          for (i = 0; i < data[0].length - 1; ++i) bandPolygons = bandPolygons.concat(cell2Polygons(prepareCell$1(data, i, j, settings), i, j, settings));\n        }\n      }\n    } else {\n      /* sparse grid of input data cells */\n      cellGrid = [];\n      for (i = 0; i < data[0].length - 1; ++i) cellGrid[i] = [];\n\n      /* compose list of polygons for entire input grid */\n      if (useQuadTree) {\n        /* collect the cells */\n        root.cellsInBand(settings.minV, settings.maxV, false).forEach(function (c) {\n          cellGrid[c.x][c.y] = prepareCell$1(data, c.x, c.y, settings);\n        });\n      } else {\n        /* prepare cells */\n        for (i = 0; i < data[0].length - 1; ++i) {\n          for (j = 0; j < data.length - 1; ++j) {\n            cellGrid[i][j] = prepareCell$1(data, i, j, settings);\n          }\n        }\n      }\n      bandPolygons = traceBandPaths(data, cellGrid, settings);\n    }\n\n    /* finally, add polygons to output array */\n    if (multiBand) ret.push(bandPolygons);else ret = bandPolygons;\n    if (typeof settings.successCallback === 'function') settings.successCallback(ret, lowerBound, bandWidth[b]);\n  });\n  return ret;\n}\n\n/*\n * Thats all for the public interface, below follows the actual\n * implementation\n */\n\n/*\n *  For isoBands, each square is defined by the three states\n * of its corner points. However, since computers use power-2\n * values, we use 2bits per trit, i.e.:\n *\n * 00 ... below minV\n * 01 ... between minV and maxV\n * 10 ... above maxV\n *\n * Hence we map the 4-trit configurations as follows:\n *\n * 0000 => 0\n * 0001 => 1\n * 0002 => 2\n * 0010 => 4\n * 0011 => 5\n * 0012 => 6\n * 0020 => 8\n * 0021 => 9\n * 0022 => 10\n * 0100 => 16\n * 0101 => 17\n * 0102 => 18\n * 0110 => 20\n * 0111 => 21\n * 0112 => 22\n * 0120 => 24\n * 0121 => 25\n * 0122 => 26\n * 0200 => 32\n * 0201 => 33\n * 0202 => 34\n * 0210 => 36\n * 0211 => 37\n * 0212 => 38\n * 0220 => 40\n * 0221 => 41\n * 0222 => 42\n * 1000 => 64\n * 1001 => 65\n * 1002 => 66\n * 1010 => 68\n * 1011 => 69\n * 1012 => 70\n * 1020 => 72\n * 1021 => 73\n * 1022 => 74\n * 1100 => 80\n * 1101 => 81\n * 1102 => 82\n * 1110 => 84\n * 1111 => 85\n * 1112 => 86\n * 1120 => 88\n * 1121 => 89\n * 1122 => 90\n * 1200 => 96\n * 1201 => 97\n * 1202 => 98\n * 1210 => 100\n * 1211 => 101\n * 1212 => 102\n * 1220 => 104\n * 1221 => 105\n * 1222 => 106\n * 2000 => 128\n * 2001 => 129\n * 2002 => 130\n * 2010 => 132\n * 2011 => 133\n * 2012 => 134\n * 2020 => 136\n * 2021 => 137\n * 2022 => 138\n * 2100 => 144\n * 2101 => 145\n * 2102 => 146\n * 2110 => 148\n * 2111 => 149\n * 2112 => 150\n * 2120 => 152\n * 2121 => 153\n * 2122 => 154\n * 2200 => 160\n * 2201 => 161\n * 2202 => 162\n * 2210 => 164\n * 2211 => 165\n * 2212 => 166\n * 2220 => 168\n * 2221 => 169\n * 2222 => 170\n */\n\n/*\n * ####################################\n * Some small helper functions\n * ####################################\n */\n\nfunction computeCenterAverage(bl, br, tr, tl, minV, maxV) {\n  var average = (tl + tr + br + bl) / 4;\n  if (average > maxV) return 2; /* above isoband limits */\n\n  if (average < minV) return 0; /* below isoband limits */\n\n  return 1; /* within isoband limits */\n}\nfunction prepareCell$1(grid, x, y, opt) {\n  var cell, center_avg;\n\n  /*  compose the 4-trit corner representation */\n  var cval = 0;\n  var x3 = grid[y + 1][x];\n  var x2 = grid[y + 1][x + 1];\n  var x1 = grid[y][x + 1];\n  var x0 = grid[y][x];\n  var minV = opt.minV;\n  var maxV = opt.maxV;\n\n  /*\n   * Note that missing data within the grid will result\n   * in horribly failing to trace full polygon paths\n   */\n  if (isNaN(x0) || isNaN(x1) || isNaN(x2) || isNaN(x3)) {\n    return;\n  }\n\n  /*\n   * Here we detect the type of the cell\n   *\n   * x3 ---- x2\n   * |      |\n   * |      |\n   * x0 ---- x1\n   *\n   * with edge points\n   *\n   * x0 = (x,y),\n   * x1 = (x + 1, y),\n   * x2 = (x + 1, y + 1), and\n   * x3 = (x, y + 1)\n   *\n   * and compute the polygon intersections with the edges\n   * of the cell. Each edge value may be (i) below, (ii) within,\n   * or (iii) above the values of the isoband limits. We\n   * encode this property using 2 bits of information, where\n   *\n   * 00 ... below,\n   * 01 ... within, and\n   * 10 ... above\n   *\n   * Then we store the cells value as vector\n   *\n   * cval = (x0, x1, x2, x3)\n   *\n   * where x0 are the two least significant bits (0th, 1st),\n   * x1 the 2nd and 3rd bit, and so on. This essentially\n   * enables us to work with a single integer number\n   */\n\n  cval |= x3 < minV ? 0 : x3 > maxV ? 128 : 64;\n  cval |= x2 < minV ? 0 : x2 > maxV ? 32 : 16;\n  cval |= x1 < minV ? 0 : x1 > maxV ? 8 : 4;\n  cval |= x0 < minV ? 0 : x0 > maxV ? 2 : 1;\n\n  /* make sure cval is a number */\n  cval = +cval;\n\n  /*\n   * cell center average trit for ambiguous cases, where\n   * 0 ... below iso band\n   * 1 ... within iso band\n   * 2 ... above isoband\n   */\n  center_avg = 0;\n  cell = {\n    cval: cval,\n    polygons: [],\n    edges: {},\n    x0: x0,\n    x1: x1,\n    x2: x2,\n    x3: x3,\n    x: x,\n    y: y\n  };\n\n  /*\n   * Compute interpolated intersections of the polygon(s)\n   * with the cell borders and (i) add edges for polygon\n   * trace-back, or (ii) a list of small closed polygons\n   * according to look-up table\n   */\n  switch (cval) {\n    case 85:\n      /* 1111 */\n      shapeCoordinates.square(cell, x0, x1, x2, x3, opt);\n    /* fall through */\n    case 0: /* 0000 */\n    /* fall through */\n    case 170:\n      /* 2222 */\n      break;\n\n    /* single triangle cases */\n\n    case 169:\n      /* 2221 */\n      shapeCoordinates.triangle_bl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 166:\n      /* 2212 */\n      shapeCoordinates.triangle_br(cell, x0, x1, x2, x3, opt);\n      break;\n    case 154:\n      /* 2122 */\n      shapeCoordinates.triangle_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 106:\n      /* 1222 */\n      shapeCoordinates.triangle_tl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 1:\n      /* 0001 */\n      shapeCoordinates.triangle_bl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 4:\n      /* 0010 */\n      shapeCoordinates.triangle_br(cell, x0, x1, x2, x3, opt);\n      break;\n    case 16:\n      /* 0100 */\n      shapeCoordinates.triangle_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 64:\n      /* 1000 */\n      shapeCoordinates.triangle_tl(cell, x0, x1, x2, x3, opt);\n      break;\n\n    /* single trapezoid cases */\n\n    case 168:\n      /* 2220 */\n      shapeCoordinates.tetragon_bl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 162:\n      /* 2202 */\n      shapeCoordinates.tetragon_br(cell, x0, x1, x2, x3, opt);\n      break;\n    case 138:\n      /* 2022 */\n      shapeCoordinates.tetragon_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 42:\n      /* 0222 */\n      shapeCoordinates.tetragon_tl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 2:\n      /* 0002 */\n      shapeCoordinates.tetragon_bl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 8:\n      /* 0020 */\n      shapeCoordinates.tetragon_br(cell, x0, x1, x2, x3, opt);\n      break;\n    case 32:\n      /* 0200 */\n      shapeCoordinates.tetragon_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 128:\n      /* 2000 */\n      shapeCoordinates.tetragon_tl(cell, x0, x1, x2, x3, opt);\n      break;\n\n    /* single rectangle cases */\n\n    case 5:\n      /* 0011 */\n      shapeCoordinates.tetragon_b(cell, x0, x1, x2, x3, opt);\n      break;\n    case 20:\n      /* 0110 */\n      shapeCoordinates.tetragon_r(cell, x0, x1, x2, x3, opt);\n      break;\n    case 80:\n      /* 1100 */\n      shapeCoordinates.tetragon_t(cell, x0, x1, x2, x3, opt);\n      break;\n    case 65:\n      /* 1001 */\n      shapeCoordinates.tetragon_l(cell, x0, x1, x2, x3, opt);\n      break;\n    case 165:\n      /* 2211 */\n      shapeCoordinates.tetragon_b(cell, x0, x1, x2, x3, opt);\n      break;\n    case 150:\n      /* 2112 */\n      shapeCoordinates.tetragon_r(cell, x0, x1, x2, x3, opt);\n      break;\n    case 90:\n      /* 1122 */\n      shapeCoordinates.tetragon_t(cell, x0, x1, x2, x3, opt);\n      break;\n    case 105:\n      /* 1221 */\n      shapeCoordinates.tetragon_l(cell, x0, x1, x2, x3, opt);\n      break;\n    case 160:\n      /* 2200 */\n      shapeCoordinates.tetragon_lr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 130:\n      /* 2002 */\n      shapeCoordinates.tetragon_tb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 10:\n      /* 0022 */\n      shapeCoordinates.tetragon_lr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 40:\n      /* 0220 */\n      shapeCoordinates.tetragon_tb(cell, x0, x1, x2, x3, opt);\n      break;\n\n    /* single pentagon cases */\n\n    case 101:\n      /* 1211 */\n      shapeCoordinates.pentagon_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 149:\n      /* 2111 */\n      shapeCoordinates.pentagon_tl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 86:\n      /* 1112 */\n      shapeCoordinates.pentagon_bl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 89:\n      /* 1121 */\n      shapeCoordinates.pentagon_br(cell, x0, x1, x2, x3, opt);\n      break;\n    case 69:\n      /* 1011 */\n      shapeCoordinates.pentagon_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 21:\n      /* 0111 */\n      shapeCoordinates.pentagon_tl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 84:\n      /* 1110 */\n      shapeCoordinates.pentagon_bl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 81:\n      /* 1101 */\n      shapeCoordinates.pentagon_br(cell, x0, x1, x2, x3, opt);\n      break;\n    case 96:\n      /* 1200 */\n      shapeCoordinates.pentagon_tr_rl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 24:\n      /* 0120 */\n      shapeCoordinates.pentagon_rb_bt(cell, x0, x1, x2, x3, opt);\n      break;\n    case 6:\n      /* 0012 */\n      shapeCoordinates.pentagon_bl_lr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 129:\n      /* 2001 */\n      shapeCoordinates.pentagon_lt_tb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 74:\n      /* 1022 */\n      shapeCoordinates.pentagon_tr_rl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 146:\n      /* 2102 */\n      shapeCoordinates.pentagon_rb_bt(cell, x0, x1, x2, x3, opt);\n      break;\n    case 164:\n      /* 2210 */\n      shapeCoordinates.pentagon_bl_lr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 41:\n      /* 0221 */\n      shapeCoordinates.pentagon_lt_tb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 66:\n      /* 1002 */\n      shapeCoordinates.pentagon_bl_tb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 144:\n      /* 2100 */\n      shapeCoordinates.pentagon_lt_rl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 36:\n      /* 0210 */\n      shapeCoordinates.pentagon_tr_bt(cell, x0, x1, x2, x3, opt);\n      break;\n    case 9:\n      /* 0021 */\n      shapeCoordinates.pentagon_rb_lr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 104:\n      /* 1220 */\n      shapeCoordinates.pentagon_bl_tb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 26:\n      /* 0122 */\n      shapeCoordinates.pentagon_lt_rl(cell, x0, x1, x2, x3, opt);\n      break;\n    case 134:\n      /* 2012 */\n      shapeCoordinates.pentagon_tr_bt(cell, x0, x1, x2, x3, opt);\n      break;\n    case 161:\n      /* 2201 */\n      shapeCoordinates.pentagon_rb_lr(cell, x0, x1, x2, x3, opt);\n      break;\n\n    /* single hexagon cases */\n\n    case 37:\n      /* 0211 */\n      shapeCoordinates.hexagon_lt_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 148:\n      /* 2110 */\n      shapeCoordinates.hexagon_bl_lt(cell, x0, x1, x2, x3, opt);\n      break;\n    case 82:\n      /* 1102 */\n      shapeCoordinates.hexagon_bl_rb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 73:\n      /* 1021 */\n      shapeCoordinates.hexagon_tr_rb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 133:\n      /* 2011 */\n      shapeCoordinates.hexagon_lt_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 22:\n      /* 0112 */\n      shapeCoordinates.hexagon_bl_lt(cell, x0, x1, x2, x3, opt);\n      break;\n    case 88:\n      /* 1120 */\n      shapeCoordinates.hexagon_bl_rb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 97:\n      /* 1201 */\n      shapeCoordinates.hexagon_tr_rb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 145:\n      /* 2101 */\n      shapeCoordinates.hexagon_lt_rb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 25:\n      /* 0121 */\n      shapeCoordinates.hexagon_lt_rb(cell, x0, x1, x2, x3, opt);\n      break;\n    case 70:\n      /* 1012 */\n      shapeCoordinates.hexagon_bl_tr(cell, x0, x1, x2, x3, opt);\n      break;\n    case 100:\n      /* 1210 */\n      shapeCoordinates.hexagon_bl_tr(cell, x0, x1, x2, x3, opt);\n      break;\n\n    /* 6-sided saddles */\n\n    case 17:\n      /* 0101 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 2 */\n      if (center_avg === 0) {\n        shapeCoordinates.triangle_bl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.triangle_tr(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.hexagon_lt_rb(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 68:\n      /* 1010 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 2 */\n      if (center_avg === 0) {\n        shapeCoordinates.triangle_tl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.triangle_br(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.hexagon_bl_tr(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 153:\n      /* 2121 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 0 */\n      if (center_avg === 2) {\n        shapeCoordinates.triangle_bl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.triangle_tr(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.hexagon_lt_rb(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 102:\n      /* 1212 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 0 */\n      if (center_avg === 2) {\n        shapeCoordinates.triangle_tl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.triangle_br(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.hexagon_bl_tr(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n\n    /* 7-sided saddles */\n\n    case 152:\n      /* 2120 */\n\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 0 */\n      if (center_avg === 2) {\n        shapeCoordinates.triangle_tr(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_bl(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_tr(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 137:\n      /* 2021 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 0 */\n      if (center_avg === 2) {\n        shapeCoordinates.triangle_bl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_tr(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_bl(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 98:\n      /* 1202 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 0 */\n      if (center_avg === 2) {\n        shapeCoordinates.triangle_tl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_br(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_tl(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 38:\n      /* 0212 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 0 */\n      if (center_avg === 2) {\n        shapeCoordinates.triangle_br(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_tl(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_br(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 18:\n      /* 0102 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 2 */\n      if (center_avg === 0) {\n        shapeCoordinates.triangle_tr(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_bl(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_tr(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 33:\n      /* 0201 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 2 */\n      if (center_avg === 0) {\n        shapeCoordinates.triangle_bl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_tr(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_bl(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 72:\n      /* 1020 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 2 */\n      if (center_avg === 0) {\n        shapeCoordinates.triangle_tl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_br(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_tl(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 132:\n      /* 2010 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      /* should never be center_avg === 2 */\n      if (center_avg === 0) {\n        shapeCoordinates.triangle_br(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_tl(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.heptagon_br(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n\n    /* 8-sided saddles */\n\n    case 136:\n      /* 2020 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      if (center_avg === 0) {\n        shapeCoordinates.tetragon_tl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_br(cell, x0, x1, x2, x3, opt);\n      } else if (center_avg === 1) {\n        shapeCoordinates.octagon(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.tetragon_bl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_tr(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n    case 34:\n      /* 0202 */\n      center_avg = computeCenterAverage(x0, x1, x2, x3, minV, maxV);\n      if (center_avg === 0) {\n        shapeCoordinates.tetragon_bl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_tr(cell, x0, x1, x2, x3, opt);\n      } else if (center_avg === 1) {\n        shapeCoordinates.octagon(cell, x0, x1, x2, x3, opt);\n      } else {\n        shapeCoordinates.tetragon_tl(cell, x0, x1, x2, x3, opt);\n        shapeCoordinates.tetragon_br(cell, x0, x1, x2, x3, opt);\n      }\n      break;\n  }\n  return cell;\n}\nexport { isoLines, isoLines as isoContours, isoBands, QuadTree, QuadTree as quadTree };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}