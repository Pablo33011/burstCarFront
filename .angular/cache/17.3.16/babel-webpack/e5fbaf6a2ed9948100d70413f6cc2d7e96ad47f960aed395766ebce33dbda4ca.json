{"ast":null,"code":"\"use strict\";\n\n/*jshint esversion: 6 */\nvar Distance = require(\"./distance.js\"),\n  ClusterInit = require(\"./kinit.js\"),\n  eudist = Distance.eudist,\n  mandist = Distance.mandist,\n  dist = Distance.dist,\n  kmrand = ClusterInit.kmrand,\n  kmpp = ClusterInit.kmpp;\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n  v = v || [];\n  for (var i = 0; i < len; i++) {\n    v[i] = val;\n  }\n  return v;\n}\nfunction skmeans(data, k, initial, maxit) {\n  var ks = [],\n    old = [],\n    idxs = [],\n    dist = [];\n  var conv = false,\n    it = maxit || MAX;\n  var len = data.length,\n    vlen = data[0].length,\n    multi = vlen > 0;\n  var count = [];\n  if (!initial) {\n    var _idxs = {};\n    while (ks.length < k) {\n      var idx = Math.floor(Math.random() * len);\n      if (!_idxs[idx]) {\n        _idxs[idx] = true;\n        ks.push(data[idx]);\n      }\n    }\n  } else if (initial == \"kmrand\") {\n    ks = kmrand(data, k);\n  } else if (initial == \"kmpp\") {\n    ks = kmpp(data, k);\n  } else {\n    ks = initial;\n  }\n  do {\n    // Reset k count\n    init(k, 0, count);\n\n    // For each value in data, find the nearest centroid\n    for (var i = 0; i < len; i++) {\n      var min = Infinity,\n        _idx = 0;\n      for (var j = 0; j < k; j++) {\n        // Multidimensional or unidimensional\n        var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n        if (dist <= min) {\n          min = dist;\n          _idx = j;\n        }\n      }\n      idxs[i] = _idx; // Index of the selected centroid for that value\n      count[_idx]++; // Number of values for this centroid\n    }\n\n    // Recalculate centroids\n    var sum = [],\n      old = [],\n      dif = 0;\n    for (var _j = 0; _j < k; _j++) {\n      // Multidimensional or unidimensional\n      sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n      old[_j] = ks[_j];\n    }\n\n    // If multidimensional\n    if (multi) {\n      for (var _j2 = 0; _j2 < k; _j2++) {\n        ks[_j2] = [];\n      } // Sum values and count for each centroid\n      for (var _i = 0; _i < len; _i++) {\n        var _idx2 = idxs[_i],\n          // Centroid for that item\n          vsum = sum[_idx2],\n          // Sum values for this centroid\n          vect = data[_i]; // Current vector\n\n        // Accumulate value on the centroid for current vector\n        for (var h = 0; h < vlen; h++) {\n          vsum[h] += vect[h];\n        }\n      }\n      // Calculate the average for each centroid\n      conv = true;\n      for (var _j3 = 0; _j3 < k; _j3++) {\n        var ksj = ks[_j3],\n          // Current centroid\n          sumj = sum[_j3],\n          // Accumulated centroid values\n          oldj = old[_j3],\n          // Old centroid value\n          cj = count[_j3]; // Number of elements for this centroid\n\n        // New average\n        for (var _h = 0; _h < vlen; _h++) {\n          ksj[_h] = sumj[_h] / cj || 0; // New centroid\n        }\n\n        // Find if centroids have moved\n        if (conv) {\n          for (var _h2 = 0; _h2 < vlen; _h2++) {\n            if (oldj[_h2] != ksj[_h2]) {\n              conv = false;\n              break;\n            }\n          }\n        }\n      }\n    }\n    // If unidimensional\n    else {\n      // Sum values and count for each centroid\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        var _idx3 = idxs[_i2];\n        sum[_idx3] += data[_i2];\n      }\n      // Calculate the average for each centroid\n      for (var _j4 = 0; _j4 < k; _j4++) {\n        ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n      }\n      // Find if centroids have moved\n      conv = true;\n      for (var _j5 = 0; _j5 < k; _j5++) {\n        if (old[_j5] != ks[_j5]) {\n          conv = false;\n          break;\n        }\n      }\n    }\n    conv = conv || --it <= 0;\n  } while (!conv);\n  return {\n    it: MAX - it,\n    k: k,\n    idxs: idxs,\n    centroids: ks\n  };\n}\nmodule.exports = skmeans;\n//# sourceMappingURL=main.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}