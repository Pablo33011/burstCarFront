{"ast":null,"code":"// index.ts\nimport { featureCollection } from \"@turf/helpers\";\n\n// lib/util.ts\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\";\nfunction mathSign(x) {\n  return (x > 0) - (x < 0) || +x;\n}\nfunction orientationIndex(p1, p2, q) {\n  const dx1 = p2[0] - p1[0],\n    dy1 = p2[1] - p1[1],\n    dx2 = q[0] - p2[0],\n    dy2 = q[1] - p2[1];\n  return mathSign(dx1 * dy2 - dx2 * dy1);\n}\nfunction envelopeIsEqual(env1, env2) {\n  const envX1 = env1.geometry.coordinates[0].map(c => c[0]),\n    envY1 = env1.geometry.coordinates[0].map(c => c[1]),\n    envX2 = env2.geometry.coordinates[0].map(c => c[0]),\n    envY2 = env2.geometry.coordinates[0].map(c => c[1]);\n  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);\n}\nfunction envelopeContains(self, env) {\n  return env.geometry.coordinates[0].every(c => booleanPointInPolygon(point(c), self));\n}\nfunction coordinatesEqual(coord1, coord2) {\n  return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}\n\n// lib/Node.ts\nvar Node = class _Node {\n  static buildId(coordinates) {\n    return coordinates.join(\",\");\n  }\n  constructor(coordinates) {\n    this.id = _Node.buildId(coordinates);\n    this.coordinates = coordinates;\n    this.innerEdges = [];\n    this.outerEdges = [];\n    this.outerEdgesSorted = false;\n  }\n  removeInnerEdge(edge) {\n    this.innerEdges = this.innerEdges.filter(e => e.from.id !== edge.from.id);\n  }\n  removeOuterEdge(edge) {\n    this.outerEdges = this.outerEdges.filter(e => e.to.id !== edge.to.id);\n  }\n  /**\n   * Outer edges are stored CCW order.\n   *\n   * @memberof Node\n   * @param {Edge} edge - Edge to add as an outerEdge.\n   */\n  addOuterEdge(edge) {\n    this.outerEdges.push(edge);\n    this.outerEdgesSorted = false;\n  }\n  /**\n   * Sorts outer edges in CCW way.\n   *\n   * @memberof Node\n   * @private\n   */\n  sortOuterEdges() {\n    if (!this.outerEdgesSorted) {\n      this.outerEdges.sort((a, b) => {\n        const aNode = a.to,\n          bNode = b.to;\n        if (aNode.coordinates[0] - this.coordinates[0] >= 0 && bNode.coordinates[0] - this.coordinates[0] < 0) return 1;\n        if (aNode.coordinates[0] - this.coordinates[0] < 0 && bNode.coordinates[0] - this.coordinates[0] >= 0) return -1;\n        if (aNode.coordinates[0] - this.coordinates[0] === 0 && bNode.coordinates[0] - this.coordinates[0] === 0) {\n          if (aNode.coordinates[1] - this.coordinates[1] >= 0 || bNode.coordinates[1] - this.coordinates[1] >= 0) return aNode.coordinates[1] - bNode.coordinates[1];\n          return bNode.coordinates[1] - aNode.coordinates[1];\n        }\n        const det = orientationIndex(this.coordinates, aNode.coordinates, bNode.coordinates);\n        if (det < 0) return 1;\n        if (det > 0) return -1;\n        const d1 = Math.pow(aNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - this.coordinates[1], 2),\n          d2 = Math.pow(bNode.coordinates[0] - this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - this.coordinates[1], 2);\n        return d1 - d2;\n      });\n      this.outerEdgesSorted = true;\n    }\n  }\n  /**\n   * Retrieves outer edges.\n   *\n   * They are sorted if they aren't in the CCW order.\n   *\n   * @memberof Node\n   * @returns {Edge[]} - List of outer edges sorted in a CCW order.\n   */\n  getOuterEdges() {\n    this.sortOuterEdges();\n    return this.outerEdges;\n  }\n  getOuterEdge(i) {\n    this.sortOuterEdges();\n    return this.outerEdges[i];\n  }\n  addInnerEdge(edge) {\n    this.innerEdges.push(edge);\n  }\n};\n\n// lib/Edge.ts\nimport { lineString } from \"@turf/helpers\";\nvar Edge = class _Edge {\n  /**\n   * Creates or get the symetric Edge.\n   *\n   * @returns {Edge} - Symetric Edge.\n   */\n  getSymetric() {\n    if (!this.symetric) {\n      this.symetric = new _Edge(this.to, this.from);\n      this.symetric.symetric = this;\n    }\n    return this.symetric;\n  }\n  /**\n   * @param {Node} from - start node of the Edge\n   * @param {Node} to - end node of the edge\n   */\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n    this.next = void 0;\n    this.label = void 0;\n    this.symetric = void 0;\n    this.ring = void 0;\n    this.from.addOuterEdge(this);\n    this.to.addInnerEdge(this);\n  }\n  /**\n   * Removes edge from from and to nodes.\n   */\n  deleteEdge() {\n    this.from.removeOuterEdge(this);\n    this.to.removeInnerEdge(this);\n  }\n  /**\n   * Compares Edge equallity.\n   *\n   * An edge is equal to another, if the from and to nodes are the same.\n   *\n   * @param {Edge} edge - Another Edge\n   * @returns {boolean} - True if Edges are equal, False otherwise\n   */\n  isEqual(edge) {\n    return this.from.id === edge.from.id && this.to.id === edge.to.id;\n  }\n  toString() {\n    return `Edge { ${this.from.id} -> ${this.to.id} }`;\n  }\n  /**\n   * Returns a LineString representation of the Edge\n   *\n   * @returns {Feature<LineString>} - LineString representation of the Edge\n   */\n  toLineString() {\n    return lineString([this.from.coordinates, this.to.coordinates]);\n  }\n  /**\n   * Comparator of two edges.\n   *\n   * Implementation of geos::planargraph::DirectedEdge::compareTo.\n   *\n   * @param {Edge} edge - Another edge to compare with this one\n   * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,\n   *          0 if the Edges are colinear,\n   *          1 otherwise\n   */\n  compareTo(edge) {\n    return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);\n  }\n};\n\n// lib/EdgeRing.ts\nimport { multiPoint, polygon, point as point2 } from \"@turf/helpers\";\nimport { envelope } from \"@turf/envelope\";\nimport { booleanPointInPolygon as booleanPointInPolygon2 } from \"@turf/boolean-point-in-polygon\";\nvar EdgeRing = class {\n  constructor() {\n    this.edges = [];\n    this.polygon = void 0;\n    this.envelope = void 0;\n  }\n  /**\n   * Add an edge to the ring, inserting it in the last position.\n   *\n   * @memberof EdgeRing\n   * @param {Edge} edge - Edge to be inserted\n   */\n  push(edge) {\n    this.edges.push(edge);\n    this.polygon = this.envelope = void 0;\n  }\n  /**\n   * Get Edge.\n   *\n   * @memberof EdgeRing\n   * @param {number} i - Index\n   * @returns {Edge} - Edge in the i position\n   */\n  get(i) {\n    return this.edges[i];\n  }\n  /**\n   * Getter of length property.\n   *\n   * @memberof EdgeRing\n   * @returns {number} - Length of the edge ring.\n   */\n  get length() {\n    return this.edges.length;\n  }\n  /**\n   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.forEach\n   */\n  forEach(f) {\n    this.edges.forEach(f);\n  }\n  /**\n   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.map\n   * @returns {Array} - The mapped values in the function\n   */\n  map(f) {\n    return this.edges.map(f);\n  }\n  /**\n   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.some\n   * @returns {boolean} - True if an Edge check the condition\n   */\n  some(f) {\n    return this.edges.some(f);\n  }\n  /**\n   * Check if the ring is valid in geomtry terms.\n   *\n   * A ring must have either 0 or 4 or more points. The first and the last must be\n   * equal (in 2D)\n   * geos::geom::LinearRing::validateConstruction\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - Validity of the EdgeRing\n   */\n  isValid() {\n    return true;\n  }\n  /**\n   * Tests whether this ring is a hole.\n   *\n   * A ring is a hole if it is oriented counter-clockwise.\n   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - true: if it is a hole\n   */\n  isHole() {\n    const hiIndex = this.edges.reduce((high, edge, i) => {\n        if (edge.from.coordinates[1] > this.edges[high].from.coordinates[1]) high = i;\n        return high;\n      }, 0),\n      iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1,\n      iNext = (hiIndex + 1) % this.length,\n      disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);\n    if (disc === 0) return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];\n    return disc > 0;\n  }\n  /**\n   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing\n   */\n  toMultiPoint() {\n    return multiPoint(this.edges.map(edge => edge.from.coordinates));\n  }\n  /**\n   * Creates a Polygon representing the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring\n   */\n  toPolygon() {\n    if (this.polygon) return this.polygon;\n    const coordinates = this.edges.map(edge => edge.from.coordinates);\n    coordinates.push(this.edges[0].from.coordinates);\n    return this.polygon = polygon([coordinates]);\n  }\n  /**\n   * Calculates the envelope of the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - envelope\n   */\n  getEnvelope() {\n    if (this.envelope) return this.envelope;\n    return this.envelope = envelope(this.toPolygon());\n  }\n  /**\n   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`\n   *\n   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list\n   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search\n   *\n   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing\n   */\n  static findEdgeRingContaining(testEdgeRing, shellList) {\n    const testEnvelope = testEdgeRing.getEnvelope();\n    let minEnvelope, minShell;\n    shellList.forEach(shell => {\n      const tryEnvelope = shell.getEnvelope();\n      if (minShell) minEnvelope = minShell.getEnvelope();\n      if (envelopeIsEqual(tryEnvelope, testEnvelope)) return;\n      if (envelopeContains(tryEnvelope, testEnvelope)) {\n        const testEdgeRingCoordinates = testEdgeRing.map(edge => edge.from.coordinates);\n        let testPoint;\n        for (const pt of testEdgeRingCoordinates) {\n          if (!shell.some(edge => coordinatesEqual(pt, edge.from.coordinates))) {\n            testPoint = pt;\n          }\n        }\n        if (testPoint && shell.inside(point2(testPoint))) {\n          if (!minShell || envelopeContains(minEnvelope, tryEnvelope)) minShell = shell;\n        }\n      }\n    });\n    return minShell;\n  }\n  /**\n   * Checks if the point is inside the edgeRing\n   *\n   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing\n   * @returns {boolean} - True if it is inside, False otherwise\n   */\n  inside(pt) {\n    return booleanPointInPolygon2(pt, this.toPolygon());\n  }\n};\n\n// lib/Graph.ts\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\nfunction validateGeoJson(geoJson) {\n  if (!geoJson) throw new Error(\"No geojson passed\");\n  if (geoJson.type !== \"FeatureCollection\" && geoJson.type !== \"GeometryCollection\" && geoJson.type !== \"MultiLineString\" && geoJson.type !== \"LineString\" && geoJson.type !== \"Feature\") throw new Error(`Invalid input type '${geoJson.type}'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature`);\n}\nvar Graph = class _Graph {\n  /**\n   * Creates a graph from a GeoJSON.\n   *\n   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n   * @returns {Graph} - The newly created graph\n   * @throws {Error} if geoJson is invalid.\n   */\n  static fromGeoJson(geoJson) {\n    validateGeoJson(geoJson);\n    const graph = new _Graph();\n    flattenEach(geoJson, feature => {\n      featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\n      coordReduce(feature, (prev, cur) => {\n        if (prev) {\n          const start = graph.getNode(prev),\n            end = graph.getNode(cur);\n          graph.addEdge(start, end);\n        }\n        return cur;\n      });\n    });\n    return graph;\n  }\n  /**\n   * Creates or get a Node.\n   *\n   * @param {number[]} coordinates - Coordinates of the node\n   * @returns {Node} - The created or stored node\n   */\n  getNode(coordinates) {\n    const id = Node.buildId(coordinates);\n    let node = this.nodes[id];\n    if (!node) node = this.nodes[id] = new Node(coordinates);\n    return node;\n  }\n  /**\n   * Adds an Edge and its symetricall.\n   *\n   * Edges are added symetrically, i.e.: we also add its symetric\n   *\n   * @param {Node} from - Node which starts the Edge\n   * @param {Node} to - Node which ends the Edge\n   */\n  addEdge(from, to) {\n    const edge = new Edge(from, to),\n      symetricEdge = edge.getSymetric();\n    this.edges.push(edge);\n    this.edges.push(symetricEdge);\n  }\n  constructor() {\n    this.edges = [];\n    this.nodes = {};\n  }\n  /**\n   * Removes Dangle Nodes (nodes with grade 1).\n   */\n  deleteDangles() {\n    Object.keys(this.nodes).map(id => this.nodes[id]).forEach(node => this._removeIfDangle(node));\n  }\n  /**\n   * Check if node is dangle, if so, remove it.\n   *\n   * It calls itself recursively, removing a dangling node might cause another dangling node\n   *\n   * @param {Node} node - Node to check if it's a dangle\n   */\n  _removeIfDangle(node) {\n    if (node.innerEdges.length <= 1) {\n      const outerNodes = node.getOuterEdges().map(e => e.to);\n      this.removeNode(node);\n      outerNodes.forEach(n => this._removeIfDangle(n));\n    }\n  }\n  /**\n   * Delete cut-edges (bridge edges).\n   *\n   * The graph will be traversed, all the edges will be labeled according the ring\n   * in which they are. (The label is a number incremented by 1). Edges with the same\n   * label are cut-edges.\n   */\n  deleteCutEdges() {\n    this._computeNextCWEdges();\n    this._findLabeledEdgeRings();\n    this.edges.forEach(edge => {\n      if (edge.label === edge.symetric.label) {\n        this.removeEdge(edge.symetric);\n        this.removeEdge(edge);\n      }\n    });\n  }\n  /**\n   * Set the `next` property of each Edge.\n   *\n   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n   * OuterEdges are sorted CCW.\n   *\n   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n   */\n  _computeNextCWEdges(node) {\n    if (typeof node === \"undefined\") {\n      Object.keys(this.nodes).forEach(id => this._computeNextCWEdges(this.nodes[id]));\n    } else {\n      node.getOuterEdges().forEach((edge, i) => {\n        node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n      });\n    }\n  }\n  /**\n   * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n   *\n   * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n   *\n   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n   * could be written in a more javascript way.\n   *\n   * @param {Node} node - Node\n   * @param {number} label - Ring's label\n   */\n  _computeNextCCWEdges(node, label) {\n    const edges = node.getOuterEdges();\n    let firstOutDE, prevInDE;\n    for (let i = edges.length - 1; i >= 0; --i) {\n      let de = edges[i],\n        sym = de.symetric,\n        outDE,\n        inDE;\n      if (de.label === label) outDE = de;\n      if (sym.label === label) inDE = sym;\n      if (!outDE || !inDE) continue;\n      if (inDE) prevInDE = inDE;\n      if (outDE) {\n        if (prevInDE) {\n          prevInDE.next = outDE;\n          prevInDE = void 0;\n        }\n        if (!firstOutDE) firstOutDE = outDE;\n      }\n    }\n    if (prevInDE) prevInDE.next = firstOutDE;\n  }\n  /**\n   * Finds rings and labels edges according to which rings are.\n   *\n   * The label is a number which is increased for each ring.\n   *\n   * @returns {Edge[]} edges that start rings\n   */\n  _findLabeledEdgeRings() {\n    const edgeRingStarts = [];\n    let label = 0;\n    this.edges.forEach(edge => {\n      if (edge.label >= 0) return;\n      edgeRingStarts.push(edge);\n      let e = edge;\n      do {\n        e.label = label;\n        e = e.next;\n      } while (!edge.isEqual(e));\n      label++;\n    });\n    return edgeRingStarts;\n  }\n  /**\n   * Computes the EdgeRings formed by the edges in this graph.\n   *\n   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n   */\n  getEdgeRings() {\n    this._computeNextCWEdges();\n    this.edges.forEach(edge => {\n      edge.label = void 0;\n    });\n    this._findLabeledEdgeRings().forEach(edge => {\n      this._findIntersectionNodes(edge).forEach(node => {\n        this._computeNextCCWEdges(node, edge.label);\n      });\n    });\n    const edgeRingList = [];\n    this.edges.forEach(edge => {\n      if (edge.ring) return;\n      edgeRingList.push(this._findEdgeRing(edge));\n    });\n    return edgeRingList;\n  }\n  /**\n   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n   *\n   * @param {Node} startEdge - Start Edge of the Ring\n   * @returns {Node[]} - intersection nodes\n   */\n  _findIntersectionNodes(startEdge) {\n    const intersectionNodes = [];\n    let edge = startEdge;\n    do {\n      let degree = 0;\n      edge.from.getOuterEdges().forEach(e => {\n        if (e.label === startEdge.label) ++degree;\n      });\n      if (degree > 1) intersectionNodes.push(edge.from);\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n    return intersectionNodes;\n  }\n  /**\n   * Get the edge-ring which starts from the provided Edge.\n   *\n   * @param {Edge} startEdge - starting edge of the edge ring\n   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n   */\n  _findEdgeRing(startEdge) {\n    let edge = startEdge;\n    const edgeRing = new EdgeRing();\n    do {\n      edgeRing.push(edge);\n      edge.ring = edgeRing;\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n    return edgeRing;\n  }\n  /**\n   * Removes a node from the Graph.\n   *\n   * It also removes edges asociated to that node\n   * @param {Node} node - Node to be removed\n   */\n  removeNode(node) {\n    node.getOuterEdges().forEach(edge => this.removeEdge(edge));\n    node.innerEdges.forEach(edge => this.removeEdge(edge));\n    delete this.nodes[node.id];\n  }\n  /**\n   * Remove edge from the graph and deletes the edge.\n   *\n   * @param {Edge} edge - Edge to be removed\n   */\n  removeEdge(edge) {\n    this.edges = this.edges.filter(e => !e.isEqual(edge));\n    edge.deleteEdge();\n  }\n};\n\n// index.ts\nfunction polygonize(geoJson) {\n  const graph = Graph.fromGeoJson(geoJson);\n  graph.deleteDangles();\n  graph.deleteCutEdges();\n  const holes = [],\n    shells = [];\n  graph.getEdgeRings().filter(edgeRing => edgeRing.isValid()).forEach(edgeRing => {\n    if (edgeRing.isHole()) holes.push(edgeRing);else shells.push(edgeRing);\n  });\n  holes.forEach(hole => {\n    if (EdgeRing.findEdgeRingContaining(hole, shells)) shells.push(hole);\n  });\n  return featureCollection(shells.map(shell => shell.toPolygon()));\n}\nvar turf_polygonize_default = polygonize;\nexport { turf_polygonize_default as default, polygonize };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}