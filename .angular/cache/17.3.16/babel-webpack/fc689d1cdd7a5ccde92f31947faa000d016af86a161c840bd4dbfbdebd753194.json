{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).jsts = e();\n}(this, function () {\n  \"use strict\";\n\n  function t(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, i = Array(e); n < e; n++) i[n] = t[n];\n    return i;\n  }\n  function e(t, e, n) {\n    return e = u(e), function (t, e) {\n      if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n      if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n      return function (t) {\n        if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return t;\n      }(t);\n    }(t, h() ? Reflect.construct(e, n || [], u(t).constructor) : e.apply(t, n));\n  }\n  function n(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function i(t, e, n) {\n    if (h()) return Reflect.construct.apply(null, arguments);\n    var i = [null];\n    i.push.apply(i, e);\n    var r = new (t.bind.apply(t, i))();\n    return n && c(r, n.prototype), r;\n  }\n  function r(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var i = e[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, v(i.key), i);\n    }\n  }\n  function s(t, e, n) {\n    return e && r(t.prototype, e), n && r(t, n), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), t;\n  }\n  function a(t, e) {\n    var n = \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n    if (!n) {\n      if (Array.isArray(t) || (n = y(t)) || e) {\n        n && (t = n);\n        var i = 0,\n          r = function () {};\n        return {\n          s: r,\n          n: function () {\n            return i >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[i++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: r\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var s,\n      a = !0,\n      o = !1;\n    return {\n      s: function () {\n        n = n.call(t);\n      },\n      n: function () {\n        var t = n.next();\n        return a = t.done, t;\n      },\n      e: function (t) {\n        o = !0, s = t;\n      },\n      f: function () {\n        try {\n          a || null == n.return || n.return();\n        } finally {\n          if (o) throw s;\n        }\n      }\n    };\n  }\n  function o() {\n    return o = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {\n      var i = function (t, e) {\n        for (; !{}.hasOwnProperty.call(t, e) && null !== (t = u(t)););\n        return t;\n      }(t, e);\n      if (i) {\n        var r = Object.getOwnPropertyDescriptor(i, e);\n        return r.get ? r.get.call(arguments.length < 3 ? t : n) : r.value;\n      }\n    }, o.apply(null, arguments);\n  }\n  function u(t) {\n    return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, u(t);\n  }\n  function l(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), e && c(t, e);\n  }\n  function h() {\n    try {\n      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (t) {}\n    return (h = function () {\n      return !!t;\n    })();\n  }\n  function c(t, e) {\n    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, c(t, e);\n  }\n  function f(t, e, n, i) {\n    var r = o(u(1 & i ? t.prototype : t), e, n);\n    return 2 & i && \"function\" == typeof r ? function (t) {\n      return r.apply(n, t);\n    } : r;\n  }\n  function g(e) {\n    return function (e) {\n      if (Array.isArray(e)) return t(e);\n    }(e) || function (t) {\n      if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n    }(e) || y(e) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n  function v(t) {\n    var e = function (t, e) {\n      if (\"object\" != typeof t || !t) return t;\n      var n = t[Symbol.toPrimitive];\n      if (void 0 !== n) {\n        var i = n.call(t, e);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return String(t);\n    }(t, \"string\");\n    return \"symbol\" == typeof e ? e : e + \"\";\n  }\n  function y(e, n) {\n    if (e) {\n      if (\"string\" == typeof e) return t(e, n);\n      var i = {}.toString.call(e).slice(8, -1);\n      return \"Object\" === i && e.constructor && (i = e.constructor.name), \"Map\" === i || \"Set\" === i ? Array.from(e) : \"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? t(e, n) : void 0;\n    }\n  }\n  function d(t) {\n    var e = \"function\" == typeof Map ? new Map() : void 0;\n    return d = function (t) {\n      if (null === t || !function (t) {\n        try {\n          return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n        } catch (e) {\n          return \"function\" == typeof t;\n        }\n      }(t)) return t;\n      if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n      if (void 0 !== e) {\n        if (e.has(t)) return e.get(t);\n        e.set(t, n);\n      }\n      function n() {\n        return i(t, arguments, u(this).constructor);\n      }\n      return n.prototype = Object.create(t.prototype, {\n        constructor: {\n          value: n,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), c(n, t);\n    }, d(t);\n  }\n  var _ = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"getEndCapStyle\",\n      value: function () {\n        return this._endCapStyle;\n      }\n    }, {\n      key: \"isSingleSided\",\n      value: function () {\n        return this._isSingleSided;\n      }\n    }, {\n      key: \"setQuadrantSegments\",\n      value: function (e) {\n        this._quadrantSegments = e, 0 === this._quadrantSegments && (this._joinStyle = t.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = t.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), e <= 0 && (this._quadrantSegments = 1), this._joinStyle !== t.JOIN_ROUND && (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS);\n      }\n    }, {\n      key: \"getJoinStyle\",\n      value: function () {\n        return this._joinStyle;\n      }\n    }, {\n      key: \"setJoinStyle\",\n      value: function (t) {\n        this._joinStyle = t;\n      }\n    }, {\n      key: \"setSimplifyFactor\",\n      value: function (t) {\n        this._simplifyFactor = t < 0 ? 0 : t;\n      }\n    }, {\n      key: \"getSimplifyFactor\",\n      value: function () {\n        return this._simplifyFactor;\n      }\n    }, {\n      key: \"getQuadrantSegments\",\n      value: function () {\n        return this._quadrantSegments;\n      }\n    }, {\n      key: \"setEndCapStyle\",\n      value: function (t) {\n        this._endCapStyle = t;\n      }\n    }, {\n      key: \"getMitreLimit\",\n      value: function () {\n        return this._mitreLimit;\n      }\n    }, {\n      key: \"setMitreLimit\",\n      value: function (t) {\n        this._mitreLimit = t;\n      }\n    }, {\n      key: \"setSingleSided\",\n      value: function (t) {\n        this._isSingleSided = t;\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length) ;else if (1 === arguments.length) {\n          var e = arguments[0];\n          this.setQuadrantSegments(e);\n        } else if (2 === arguments.length) {\n          var n = arguments[0],\n            i = arguments[1];\n          this.setQuadrantSegments(n), this.setEndCapStyle(i);\n        } else if (4 === arguments.length) {\n          var r = arguments[0],\n            s = arguments[1],\n            a = arguments[2],\n            o = arguments[3];\n          this.setQuadrantSegments(r), this.setEndCapStyle(s), this.setJoinStyle(a), this.setMitreLimit(o);\n        }\n      }\n    }, {\n      key: \"bufferDistanceError\",\n      value: function (t) {\n        var e = Math.PI / 2 / t;\n        return 1 - Math.cos(e / 2);\n      }\n    }]);\n  }();\n  _.CAP_ROUND = 1, _.CAP_FLAT = 2, _.CAP_SQUARE = 3, _.JOIN_ROUND = 1, _.JOIN_MITRE = 2, _.JOIN_BEVEL = 3, _.DEFAULT_QUADRANT_SEGMENTS = 8, _.DEFAULT_MITRE_LIMIT = 5, _.DEFAULT_SIMPLIFY_FACTOR = .01;\n  var p = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          Exception: i\n        })[0], r;\n      }\n      return l(i, t), s(i, [{\n        key: \"toString\",\n        value: function () {\n          return this.message;\n        }\n      }]);\n    }(d(Error)),\n    m = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          IllegalArgumentException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    k = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t) {}\n      }]);\n    }();\n  function x() {}\n  function I() {}\n  function E() {}\n  var N,\n    T,\n    S,\n    L,\n    C,\n    R,\n    w,\n    O,\n    b = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"equalsWithTolerance\",\n        value: function (t, e, n) {\n          return Math.abs(t - e) <= n;\n        }\n      }]);\n    }(),\n    M = function () {\n      return s(function t(e, i) {\n        n(this, t), this.low = i || 0, this.high = e || 0;\n      }, null, [{\n        key: \"toBinaryString\",\n        value: function (t) {\n          var e,\n            n = \"\";\n          for (e = 2147483648; e > 0; e >>>= 1) n += (t.high & e) === e ? \"1\" : \"0\";\n          for (e = 2147483648; e > 0; e >>>= 1) n += (t.low & e) === e ? \"1\" : \"0\";\n          return n;\n        }\n      }]);\n    }();\n  function A() {}\n  function P() {}\n  A.NaN = NaN, A.isNaN = function (t) {\n    return Number.isNaN(t);\n  }, A.isInfinite = function (t) {\n    return !Number.isFinite(t);\n  }, A.MAX_VALUE = Number.MAX_VALUE, A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, \"function\" == typeof Float64Array && \"function\" == typeof Int32Array ? (R = 2146435072, w = new Float64Array(1), O = new Int32Array(w.buffer), A.doubleToLongBits = function (t) {\n    w[0] = t;\n    var e = 0 | O[0],\n      n = 0 | O[1];\n    return (n & R) === R && 1048575 & n && 0 !== e && (e = 0, n = 2146959360), new M(n, e);\n  }, A.longBitsToDouble = function (t) {\n    return O[0] = t.low, O[1] = t.high, w[0];\n  }) : (N = 1023, T = Math.log2, S = Math.floor, L = Math.pow, C = function () {\n    for (var t = 53; t > 0; t--) {\n      var e = L(2, t) - 1;\n      if (S(T(e)) + 1 === t) return e;\n    }\n    return 0;\n  }(), A.doubleToLongBits = function (t) {\n    var e, n, i, r, s, a, o, u, l;\n    if (t < 0 || 1 / t === Number.NEGATIVE_INFINITY ? (a = 1 << 31, t = -t) : a = 0, 0 === t) return new M(u = a, l = 0);\n    if (t === 1 / 0) return new M(u = 2146435072 | a, l = 0);\n    if (t != t) return new M(u = 2146959360, l = 0);\n    if (r = 0, l = 0, (e = S(t)) > 1) if (e <= C) (r = S(T(e))) <= 20 ? (l = 0, u = e << 20 - r & 1048575) : (l = e % (n = L(2, i = r - 20)) << 32 - i, u = e / n & 1048575);else for (i = e, l = 0; 0 !== (i = S(n = i / 2));) r++, l >>>= 1, l |= (1 & u) << 31, u >>>= 1, n !== i && (u |= 524288);\n    if (o = r + N, s = 0 === e, e = t - e, r < 52 && 0 !== e) for (i = 0;;) {\n      if ((n = 2 * e) >= 1 ? (e = n - 1, s ? (o--, s = !1) : (i <<= 1, i |= 1, r++)) : (e = n, s ? 0 == --o && (r++, s = !1) : (i <<= 1, r++)), 20 === r) u |= i, i = 0;else if (52 === r) {\n        l |= i;\n        break;\n      }\n      if (1 === n) {\n        r < 20 ? u |= i << 20 - r : r < 52 && (l |= i << 52 - r);\n        break;\n      }\n    }\n    return u |= o << 20, new M(u |= a, l);\n  }, A.longBitsToDouble = function (t) {\n    var e,\n      n,\n      i,\n      r,\n      s = t.high,\n      a = t.low,\n      o = s & 1 << 31 ? -1 : 1;\n    for (i = ((2146435072 & s) >> 20) - N, r = 0, n = 1 << 19, e = 1; e <= 20; e++) s & n && (r += L(2, -e)), n >>>= 1;\n    for (n = 1 << 31, e = 21; e <= 52; e++) a & n && (r += L(2, -e)), n >>>= 1;\n    if (-1023 === i) {\n      if (0 === r) return 0 * o;\n      i = -1022;\n    } else {\n      if (1024 === i) return 0 === r ? o / 0 : NaN;\n      r += 1;\n    }\n    return o * r * L(2, i);\n  });\n  var D = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          RuntimeException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    F = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, null, [{\n        key: \"constructor_\",\n        value: function () {\n          if (0 === arguments.length) D.constructor_.call(this);else if (1 === arguments.length) {\n            var t = arguments[0];\n            D.constructor_.call(this, t);\n          }\n        }\n      }]);\n    }(D),\n    G = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"shouldNeverReachHere\",\n        value: function () {\n          if (0 === arguments.length) t.shouldNeverReachHere(null);else if (1 === arguments.length) {\n            var e = arguments[0];\n            throw new F(\"Should never reach here\" + (null !== e ? \": \" + e : \"\"));\n          }\n        }\n      }, {\n        key: \"isTrue\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            t.isTrue(e, null);\n          } else if (2 === arguments.length) {\n            var n = arguments[1];\n            if (!arguments[0]) throw null === n ? new F() : new F(n);\n          }\n        }\n      }, {\n        key: \"equals\",\n        value: function () {\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            t.equals(e, n, null);\n          } else if (3 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2];\n            if (!r.equals(i)) throw new F(\"Expected \" + i + \" but encountered \" + r + (null !== s ? \": \" + s : \"\"));\n          }\n        }\n      }]);\n    }(),\n    q = new ArrayBuffer(8),\n    Y = new Float64Array(q),\n    z = new Int32Array(q),\n    X = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getM\",\n        value: function () {\n          return A.NaN;\n        }\n      }, {\n        key: \"setOrdinate\",\n        value: function (e, n) {\n          switch (e) {\n            case t.X:\n              this.x = n;\n              break;\n            case t.Y:\n              this.y = n;\n              break;\n            case t.Z:\n              this.setZ(n);\n              break;\n            default:\n              throw new m(\"Invalid ordinate index: \" + e);\n          }\n        }\n      }, {\n        key: \"equals2D\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.x === t.x && this.y === t.y;\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            return !!b.equalsWithTolerance(this.x, e.x, n) && !!b.equalsWithTolerance(this.y, e.y, n);\n          }\n        }\n      }, {\n        key: \"setM\",\n        value: function (e) {\n          throw new m(\"Invalid ordinate index: \" + t.M);\n        }\n      }, {\n        key: \"getZ\",\n        value: function () {\n          return this.z;\n        }\n      }, {\n        key: \"getOrdinate\",\n        value: function (e) {\n          switch (e) {\n            case t.X:\n              return this.x;\n            case t.Y:\n              return this.y;\n            case t.Z:\n              return this.getZ();\n          }\n          throw new m(\"Invalid ordinate index: \" + e);\n        }\n      }, {\n        key: \"equals3D\",\n        value: function (t) {\n          return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || A.isNaN(this.getZ()) && A.isNaN(t.getZ()));\n        }\n      }, {\n        key: \"equals\",\n        value: function (e) {\n          return e instanceof t && this.equals2D(e);\n        }\n      }, {\n        key: \"equalInZ\",\n        value: function (t, e) {\n          return b.equalsWithTolerance(this.getZ(), t.getZ(), e);\n        }\n      }, {\n        key: \"setX\",\n        value: function (t) {\n          this.x = t;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;\n        }\n      }, {\n        key: \"getX\",\n        value: function () {\n          return this.x;\n        }\n      }, {\n        key: \"setZ\",\n        value: function (t) {\n          this.z = t;\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          try {\n            return null;\n          } catch (t) {\n            if (t instanceof CloneNotSupportedException) return G.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\"), null;\n            throw t;\n          }\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          return new t(this);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"(\" + this.x + \", \" + this.y + \", \" + this.getZ() + \")\";\n        }\n      }, {\n        key: \"distance3D\",\n        value: function (t) {\n          var e = this.x - t.x,\n            n = this.y - t.y,\n            i = this.getZ() - t.getZ();\n          return Math.sqrt(e * e + n * n + i * i);\n        }\n      }, {\n        key: \"getY\",\n        value: function () {\n          return this.y;\n        }\n      }, {\n        key: \"setY\",\n        value: function (t) {\n          this.y = t;\n        }\n      }, {\n        key: \"distance\",\n        value: function (t) {\n          var e = this.x - t.x,\n            n = this.y - t.y;\n          return Math.sqrt(e * e + n * n);\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          var e = 17;\n          return e = 37 * (e = 37 * e + t.hashCode(this.x)) + t.hashCode(this.y);\n        }\n      }, {\n        key: \"setCoordinate\",\n        value: function (t) {\n          this.x = t.x, this.y = t.y, this.z = t.getZ();\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x, I, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) t.constructor_.call(this, 0, 0);else if (1 === arguments.length) {\n            var e = arguments[0];\n            t.constructor_.call(this, e.x, e.y, e.getZ());\n          } else if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            t.constructor_.call(this, n, i, t.NULL_ORDINATE);\n          } else if (3 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2];\n            this.x = r, this.y = s, this.z = a;\n          }\n        }\n      }, {\n        key: \"hashCode\",\n        value: function (t) {\n          return Y[0] = t, z[0] ^ z[1];\n        }\n      }]);\n    }(),\n    B = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"compare\",\n        value: function (e, n) {\n          var i = t.compare(e.x, n.x);\n          if (0 !== i) return i;\n          var r = t.compare(e.y, n.y);\n          return 0 !== r ? r : this._dimensionsToTest <= 2 ? 0 : t.compare(e.getZ(), n.getZ());\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [P];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._dimensionsToTest = 2, 0 === arguments.length) t.constructor_.call(this, 2);else if (1 === arguments.length) {\n            var e = arguments[0];\n            if (2 !== e && 3 !== e) throw new m(\"only 2 or 3 dimensions may be specified\");\n            this._dimensionsToTest = e;\n          }\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          return t < e ? -1 : t > e ? 1 : A.isNaN(t) ? A.isNaN(e) ? 0 : -1 : A.isNaN(e) ? 1 : 0;\n        }\n      }]);\n    }();\n  X.DimensionalComparator = B, X.NULL_ORDINATE = A.NaN, X.X = 0, X.Y = 1, X.Z = 2, X.M = 3;\n  var U = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getArea\",\n        value: function () {\n          return this.getWidth() * this.getHeight();\n        }\n      }, {\n        key: \"equals\",\n        value: function (e) {\n          if (!(e instanceof t)) return !1;\n          var n = e;\n          return this.isNull() ? n.isNull() : this._maxx === n.getMaxX() && this._maxy === n.getMaxY() && this._minx === n.getMinX() && this._miny === n.getMinY();\n        }\n      }, {\n        key: \"intersection\",\n        value: function (e) {\n          if (this.isNull() || e.isNull() || !this.intersects(e)) return new t();\n          var n = this._minx > e._minx ? this._minx : e._minx,\n            i = this._miny > e._miny ? this._miny : e._miny;\n          return new t(n, this._maxx < e._maxx ? this._maxx : e._maxx, i, this._maxy < e._maxy ? this._maxy : e._maxy);\n        }\n      }, {\n        key: \"isNull\",\n        value: function () {\n          return this._maxx < this._minx;\n        }\n      }, {\n        key: \"getMaxX\",\n        value: function () {\n          return this._maxx;\n        }\n      }, {\n        key: \"covers\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              return this.covers(e.x, e.y);\n            }\n            if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              return !this.isNull() && !n.isNull() && n.getMinX() >= this._minx && n.getMaxX() <= this._maxx && n.getMinY() >= this._miny && n.getMaxY() <= this._maxy;\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            return !this.isNull() && i >= this._minx && i <= this._maxx && r >= this._miny && r <= this._maxy;\n          }\n        }\n      }, {\n        key: \"intersects\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return !this.isNull() && !e.isNull() && !(e._minx > this._maxx || e._maxx < this._minx || e._miny > this._maxy || e._maxy < this._miny);\n            }\n            if (arguments[0] instanceof X) {\n              var n = arguments[0];\n              return this.intersects(n.x, n.y);\n            }\n          } else if (2 === arguments.length) {\n            if (arguments[0] instanceof X && arguments[1] instanceof X) {\n              var i = arguments[0],\n                r = arguments[1];\n              return !this.isNull() && !((i.x < r.x ? i.x : r.x) > this._maxx) && !((i.x > r.x ? i.x : r.x) < this._minx) && !((i.y < r.y ? i.y : r.y) > this._maxy) && !((i.y > r.y ? i.y : r.y) < this._miny);\n            }\n            if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n              var s = arguments[0],\n                a = arguments[1];\n              return !this.isNull() && !(s > this._maxx || s < this._minx || a > this._maxy || a < this._miny);\n            }\n          }\n        }\n      }, {\n        key: \"getMinY\",\n        value: function () {\n          return this._miny;\n        }\n      }, {\n        key: \"getDiameter\",\n        value: function () {\n          if (this.isNull()) return 0;\n          var t = this.getWidth(),\n            e = this.getHeight();\n          return Math.sqrt(t * t + e * e);\n        }\n      }, {\n        key: \"getMinX\",\n        value: function () {\n          return this._minx;\n        }\n      }, {\n        key: \"expandToInclude\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              this.expandToInclude(e.x, e.y);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              if (n.isNull()) return null;\n              this.isNull() ? (this._minx = n.getMinX(), this._maxx = n.getMaxX(), this._miny = n.getMinY(), this._maxy = n.getMaxY()) : (n._minx < this._minx && (this._minx = n._minx), n._maxx > this._maxx && (this._maxx = n._maxx), n._miny < this._miny && (this._miny = n._miny), n._maxy > this._maxy && (this._maxy = n._maxy));\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.isNull() ? (this._minx = i, this._maxx = i, this._miny = r, this._maxy = r) : (i < this._minx && (this._minx = i), i > this._maxx && (this._maxx = i), r < this._miny && (this._miny = r), r > this._maxy && (this._maxy = r));\n          }\n        }\n      }, {\n        key: \"minExtent\",\n        value: function () {\n          if (this.isNull()) return 0;\n          var t = this.getWidth(),\n            e = this.getHeight();\n          return t < e ? t : e;\n        }\n      }, {\n        key: \"getWidth\",\n        value: function () {\n          return this.isNull() ? 0 : this._maxx - this._minx;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;\n        }\n      }, {\n        key: \"translate\",\n        value: function (t, e) {\n          if (this.isNull()) return null;\n          this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          return new t(this);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n        }\n      }, {\n        key: \"setToNull\",\n        value: function () {\n          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;\n        }\n      }, {\n        key: \"disjoint\",\n        value: function (t) {\n          return !(!this.isNull() && !t.isNull()) || t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny;\n        }\n      }, {\n        key: \"getHeight\",\n        value: function () {\n          return this.isNull() ? 0 : this._maxy - this._miny;\n        }\n      }, {\n        key: \"maxExtent\",\n        value: function () {\n          if (this.isNull()) return 0;\n          var t = this.getWidth(),\n            e = this.getHeight();\n          return t > e ? t : e;\n        }\n      }, {\n        key: \"expandBy\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.expandBy(t, t);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (this.isNull()) return null;\n            this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();\n          }\n        }\n      }, {\n        key: \"contains\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.covers(e);\n            }\n            if (arguments[0] instanceof X) {\n              var n = arguments[0];\n              return this.covers(n);\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            return this.covers(i, r);\n          }\n        }\n      }, {\n        key: \"centre\",\n        value: function () {\n          return this.isNull() ? null : new X((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);\n        }\n      }, {\n        key: \"init\",\n        value: function () {\n          if (0 === arguments.length) this.setToNull();else if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              this.init(e.x, e.x, e.y, e.y);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this._minx = n._minx, this._maxx = n._maxx, this._miny = n._miny, this._maxy = n._maxy;\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.init(i.x, r.x, i.y, r.y);\n          } else if (4 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2],\n              u = arguments[3];\n            s < a ? (this._minx = s, this._maxx = a) : (this._minx = a, this._maxx = s), o < u ? (this._miny = o, this._maxy = u) : (this._miny = u, this._maxy = o);\n          }\n        }\n      }, {\n        key: \"getMaxY\",\n        value: function () {\n          return this._maxy;\n        }\n      }, {\n        key: \"distance\",\n        value: function (t) {\n          if (this.intersects(t)) return 0;\n          var e = 0;\n          this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);\n          var n = 0;\n          return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n);\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          var t = 17;\n          return t = 37 * (t = 37 * (t = 37 * (t = 37 * t + X.hashCode(this._minx)) + X.hashCode(this._maxx)) + X.hashCode(this._miny)) + X.hashCode(this._maxy);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();else if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              this.init(e.x, e.x, e.y, e.y);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this.init(n);\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.init(i.x, r.x, i.y, r.y);\n          } else if (4 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2],\n              u = arguments[3];\n            this.init(s, a, o, u);\n          }\n        }\n      }, {\n        key: \"intersects\",\n        value: function () {\n          if (3 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = arguments[2];\n            return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);\n          }\n          if (4 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2],\n              a = arguments[3],\n              o = Math.min(s.x, a.x),\n              u = Math.max(s.x, a.x),\n              l = Math.min(i.x, r.x),\n              h = Math.max(i.x, r.x);\n            return !(l > u) && !(h < o) && (o = Math.min(s.y, a.y), u = Math.max(s.y, a.y), l = Math.min(i.y, r.y), h = Math.max(i.y, r.y), !(l > u) && !(h < o));\n          }\n        }\n      }]);\n    }(),\n    V = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"isGeometryCollection\",\n        value: function () {\n          return this.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION;\n        }\n      }, {\n        key: \"getFactory\",\n        value: function () {\n          return this._factory;\n        }\n      }, {\n        key: \"getGeometryN\",\n        value: function (t) {\n          return this;\n        }\n      }, {\n        key: \"getArea\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"isRectangle\",\n        value: function () {\n          return !1;\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function (t) {\n          return this === t || this.equalsExact(t, 0);\n        }\n      }, {\n        key: \"geometryChanged\",\n        value: function () {\n          this.apply(t.geometryChangedFilter);\n        }\n      }, {\n        key: \"geometryChangedAction\",\n        value: function () {\n          this._envelope = null;\n        }\n      }, {\n        key: \"equalsNorm\",\n        value: function (t) {\n          return null !== t && this.norm().equalsExact(t.norm());\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"getNumGeometries\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function () {\n          var t;\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e);\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            return t = n, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(n, i);\n          }\n        }\n      }, {\n        key: \"getUserData\",\n        value: function () {\n          return this._userData;\n        }\n      }, {\n        key: \"getSRID\",\n        value: function () {\n          return this._SRID;\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          return this.getFactory().toGeometry(this.getEnvelopeInternal());\n        }\n      }, {\n        key: \"checkNotGeometryCollection\",\n        value: function (e) {\n          if (e.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION) throw new m(\"This method does not support GeometryCollection arguments\");\n        }\n      }, {\n        key: \"equal\",\n        value: function (t, e, n) {\n          return 0 === n ? t.equals(e) : t.distance(e) <= n;\n        }\n      }, {\n        key: \"norm\",\n        value: function () {\n          var t = this.copy();\n          return t.normalize(), t;\n        }\n      }, {\n        key: \"reverse\",\n        value: function () {\n          var t = this.reverseInternal();\n          return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t;\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          var t = this.copyInternal();\n          return t.envelope = null == this._envelope ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t;\n        }\n      }, {\n        key: \"getPrecisionModel\",\n        value: function () {\n          return this._factory.getPrecisionModel();\n        }\n      }, {\n        key: \"getEnvelopeInternal\",\n        value: function () {\n          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new U(this._envelope);\n        }\n      }, {\n        key: \"setSRID\",\n        value: function (t) {\n          this._SRID = t;\n        }\n      }, {\n        key: \"setUserData\",\n        value: function (t) {\n          this._userData = t;\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {\n            var r = n.next(),\n              s = i.next(),\n              a = r.compareTo(s);\n            if (0 !== a) return a;\n          }\n          return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          return this.getEnvelopeInternal().hashCode();\n        }\n      }, {\n        key: \"isEquivalentClass\",\n        value: function (t) {\n          return this.getClass() === t.getClass();\n        }\n      }, {\n        key: \"isGeometryCollectionOrDerived\",\n        value: function () {\n          return this.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === t.TYPECODE_MULTIPOINT || this.getTypeCode() === t.TYPECODE_MULTILINESTRING || this.getTypeCode() === t.TYPECODE_MULTIPOLYGON;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [I, x, E];\n        }\n      }, {\n        key: \"getClass\",\n        value: function () {\n          return t;\n        }\n      }], [{\n        key: \"hasNonEmptyElements\",\n        value: function (t) {\n          for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;\n          return !1;\n        }\n      }, {\n        key: \"hasNullElements\",\n        value: function (t) {\n          for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;\n          return !1;\n        }\n      }]);\n    }();\n  V.constructor_ = function (t) {\n    t && (this._envelope = null, this._userData = null, this._factory = t, this._SRID = t.getSRID());\n  }, V.TYPECODE_POINT = 0, V.TYPECODE_MULTIPOINT = 1, V.TYPECODE_LINESTRING = 2, V.TYPECODE_LINEARRING = 3, V.TYPECODE_MULTILINESTRING = 4, V.TYPECODE_POLYGON = 5, V.TYPECODE_MULTIPOLYGON = 6, V.TYPECODE_GEOMETRYCOLLECTION = 7, V.TYPENAME_POINT = \"Point\", V.TYPENAME_MULTIPOINT = \"MultiPoint\", V.TYPENAME_LINESTRING = \"LineString\", V.TYPENAME_LINEARRING = \"LinearRing\", V.TYPENAME_MULTILINESTRING = \"MultiLineString\", V.TYPENAME_POLYGON = \"Polygon\", V.TYPENAME_MULTIPOLYGON = \"MultiPolygon\", V.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\", V.geometryChangedFilter = {\n    get interfaces_() {\n      return [k];\n    },\n    filter: function (t) {\n      t.geometryChangedAction();\n    }\n  };\n  var H = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"toLocationSymbol\",\n      value: function (e) {\n        switch (e) {\n          case t.EXTERIOR:\n            return \"e\";\n          case t.BOUNDARY:\n            return \"b\";\n          case t.INTERIOR:\n            return \"i\";\n          case t.NONE:\n            return \"-\";\n        }\n        throw new m(\"Unknown location value: \" + e);\n      }\n    }]);\n  }();\n  H.INTERIOR = 0, H.BOUNDARY = 1, H.EXTERIOR = 2, H.NONE = -1;\n  var Z = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"add\",\n        value: function () {}\n      }, {\n        key: \"addAll\",\n        value: function () {}\n      }, {\n        key: \"isEmpty\",\n        value: function () {}\n      }, {\n        key: \"iterator\",\n        value: function () {}\n      }, {\n        key: \"size\",\n        value: function () {}\n      }, {\n        key: \"toArray\",\n        value: function () {}\n      }, {\n        key: \"remove\",\n        value: function () {}\n      }]);\n    }(),\n    j = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          NoSuchElementException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    W = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          UnsupportedOperationException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    K = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i, [{\n        key: \"contains\",\n        value: function () {}\n      }]);\n    }(Z),\n    J = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i)).map = new Map(), t instanceof Z && r.addAll(t), r;\n      }\n      return l(i, t), s(i, [{\n        key: \"contains\",\n        value: function (t) {\n          var e = t.hashCode ? t.hashCode() : t;\n          return !!this.map.has(e);\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          var e = t.hashCode ? t.hashCode() : t;\n          return !this.map.has(e) && !!this.map.set(e, t);\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          var e,\n            n = a(t);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              var i = e.value;\n              this.add(i);\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n          return !0;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.map.size;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.map.size;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return Array.from(this.map.values());\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return new Q(this.map);\n        }\n      }, {\n        key: Symbol.iterator,\n        value: function () {\n          return this.map;\n        }\n      }]);\n    }(K),\n    Q = function () {\n      return s(function t(e) {\n        n(this, t), this.iterator = e.values();\n        var i = this.iterator.next(),\n          r = i.done,\n          s = i.value;\n        this.done = r, this.value = s;\n      }, [{\n        key: \"next\",\n        value: function () {\n          if (this.done) throw new j();\n          var t = this.value,\n            e = this.iterator.next(),\n            n = e.done,\n            i = e.value;\n          return this.done = n, this.value = i, t;\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          return !this.done;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }]);\n    }(),\n    $ = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"opposite\",\n        value: function (e) {\n          return e === t.LEFT ? t.RIGHT : e === t.RIGHT ? t.LEFT : e;\n        }\n      }]);\n    }();\n  $.ON = 0, $.LEFT = 1, $.RIGHT = 2;\n  var tt = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          EmptyStackException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    et = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i, [t])).name = Object.keys({\n          IndexOutOfBoundsException: i\n        })[0], r;\n      }\n      return l(i, t), s(i);\n    }(p),\n    nt = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i, [{\n        key: \"get\",\n        value: function () {}\n      }, {\n        key: \"set\",\n        value: function () {}\n      }, {\n        key: \"isEmpty\",\n        value: function () {}\n      }]);\n    }(Z),\n    it = function (t) {\n      function i() {\n        var t;\n        return n(this, i), (t = e(this, i)).array = [], t;\n      }\n      return l(i, t), s(i, [{\n        key: \"add\",\n        value: function (t) {\n          return this.array.push(t), !0;\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          if (t < 0 || t >= this.size()) throw new et();\n          return this.array[t];\n        }\n      }, {\n        key: \"push\",\n        value: function (t) {\n          return this.array.push(t), t;\n        }\n      }, {\n        key: \"pop\",\n        value: function () {\n          if (0 === this.array.length) throw new tt();\n          return this.array.pop();\n        }\n      }, {\n        key: \"peek\",\n        value: function () {\n          if (0 === this.array.length) throw new tt();\n          return this.array[this.array.length - 1];\n        }\n      }, {\n        key: \"empty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this.empty();\n        }\n      }, {\n        key: \"search\",\n        value: function (t) {\n          return this.array.indexOf(t);\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.array.length;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return this.array.slice();\n        }\n      }]);\n    }(nt);\n  function rt(t, e) {\n    return t.interfaces_ && t.interfaces_.indexOf(e) > -1;\n  }\n  var st = function () {\n      return s(function t(e) {\n        n(this, t), this.str = e;\n      }, [{\n        key: \"append\",\n        value: function (t) {\n          this.str += t;\n        }\n      }, {\n        key: \"setCharAt\",\n        value: function (t, e) {\n          this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.str;\n        }\n      }]);\n    }(),\n    at = function () {\n      function t(e) {\n        n(this, t), this.value = e;\n      }\n      return s(t, [{\n        key: \"intValue\",\n        value: function () {\n          return this.value;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          return this.value < t ? -1 : this.value > t ? 1 : 0;\n        }\n      }], [{\n        key: \"compare\",\n        value: function (t, e) {\n          return t < e ? -1 : t > e ? 1 : 0;\n        }\n      }, {\n        key: \"isNan\",\n        value: function (t) {\n          return Number.isNaN(t);\n        }\n      }, {\n        key: \"valueOf\",\n        value: function (e) {\n          return new t(e);\n        }\n      }]);\n    }(),\n    ot = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"isWhitespace\",\n        value: function (t) {\n          return t <= 32 && t >= 0 || 127 === t;\n        }\n      }, {\n        key: \"toUpperCase\",\n        value: function (t) {\n          return t.toUpperCase();\n        }\n      }]);\n    }(),\n    ut = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"le\",\n        value: function (t) {\n          return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo;\n        }\n      }, {\n        key: \"extractSignificantDigits\",\n        value: function (e, n) {\n          var i = this.abs(),\n            r = t.magnitude(i._hi),\n            s = t.TEN.pow(r);\n          (i = i.divide(s)).gt(t.TEN) ? (i = i.divide(t.TEN), r += 1) : i.lt(t.ONE) && (i = i.multiply(t.TEN), r -= 1);\n          for (var a = r + 1, o = new st(), u = t.MAX_PRINT_DIGITS - 1, l = 0; l <= u; l++) {\n            e && l === a && o.append(\".\");\n            var h = Math.trunc(i._hi);\n            if (h < 0) break;\n            var c = !1,\n              f = 0;\n            h > 9 ? (c = !0, f = \"9\") : f = \"0\" + h, o.append(f), i = i.subtract(t.valueOf(h)).multiply(t.TEN), c && i.selfAdd(t.TEN);\n            var g = !0,\n              v = t.magnitude(i._hi);\n            if (v < 0 && Math.abs(v) >= u - l && (g = !1), !g) break;\n          }\n          return n[0] = r, o.toString();\n        }\n      }, {\n        key: \"sqr\",\n        value: function () {\n          return this.multiply(this);\n        }\n      }, {\n        key: \"doubleValue\",\n        value: function () {\n          return this._hi + this._lo;\n        }\n      }, {\n        key: \"subtract\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this.add(e.negate());\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return this.add(-n);\n          }\n        }\n      }, {\n        key: \"equals\",\n        value: function () {\n          if (1 === arguments.length && arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this._hi === e._hi && this._lo === e._lo;\n          }\n        }\n      }, {\n        key: \"isZero\",\n        value: function () {\n          return 0 === this._hi && 0 === this._lo;\n        }\n      }, {\n        key: \"selfSubtract\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this.isNaN() ? this : this.selfAdd(-e._hi, -e._lo);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return this.isNaN() ? this : this.selfAdd(-n, 0);\n          }\n        }\n      }, {\n        key: \"getSpecialNumberString\",\n        value: function () {\n          return this.isZero() ? \"0.0\" : this.isNaN() ? \"NaN \" : null;\n        }\n      }, {\n        key: \"min\",\n        value: function (t) {\n          return this.le(t) ? this : t;\n        }\n      }, {\n        key: \"selfDivide\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.selfDivide(e._hi, e._lo);\n            }\n            if (\"number\" == typeof arguments[0]) {\n              var n = arguments[0];\n              return this.selfDivide(n, 0);\n            }\n          } else if (2 === arguments.length) {\n            var i,\n              r,\n              s,\n              a,\n              o = arguments[0],\n              u = arguments[1],\n              l = null,\n              h = null,\n              c = null,\n              f = null;\n            return s = this._hi / o, f = (l = (c = t.SPLIT * s) - (l = c - s)) * (h = (f = t.SPLIT * o) - (h = f - o)) - (a = s * o) + l * (r = o - h) + (i = s - l) * h + i * r, f = s + (c = (this._hi - a - f + this._lo - s * u) / o), this._hi = f, this._lo = s - f + c, this;\n          }\n        }\n      }, {\n        key: \"dump\",\n        value: function () {\n          return \"DD<\" + this._hi + \", \" + this._lo + \">\";\n        }\n      }, {\n        key: \"divide\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e,\n              n,\n              i,\n              r,\n              s = arguments[0],\n              a = null,\n              o = null,\n              u = null,\n              l = null;\n            return e = (i = this._hi / s._hi) - (a = (u = t.SPLIT * i) - (a = u - i)), l = a * (o = (l = t.SPLIT * s._hi) - (o = l - s._hi)) - (r = i * s._hi) + a * (n = s._hi - o) + e * o + e * n, new t(l = i + (u = (this._hi - r - l + this._lo - i * s._lo) / s._hi), i - l + u);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var h = arguments[0];\n            return A.isNaN(h) ? t.createNaN() : t.copy(this).selfDivide(h, 0);\n          }\n        }\n      }, {\n        key: \"ge\",\n        value: function (t) {\n          return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo;\n        }\n      }, {\n        key: \"pow\",\n        value: function (e) {\n          if (0 === e) return t.valueOf(1);\n          var n = new t(this),\n            i = t.valueOf(1),\n            r = Math.abs(e);\n          if (r > 1) for (; r > 0;) r % 2 == 1 && i.selfMultiply(n), (r /= 2) > 0 && (n = n.sqr());else i = n;\n          return e < 0 ? i.reciprocal() : i;\n        }\n      }, {\n        key: \"ceil\",\n        value: function () {\n          if (this.isNaN()) return t.NaN;\n          var e = Math.ceil(this._hi),\n            n = 0;\n          return e === this._hi && (n = Math.ceil(this._lo)), new t(e, n);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;\n        }\n      }, {\n        key: \"rint\",\n        value: function () {\n          return this.isNaN() ? this : this.add(.5).floor();\n        }\n      }, {\n        key: \"setValue\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return this.init(e), this;\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return this.init(n), this;\n          }\n        }\n      }, {\n        key: \"max\",\n        value: function (t) {\n          return this.ge(t) ? this : t;\n        }\n      }, {\n        key: \"sqrt\",\n        value: function () {\n          if (this.isZero()) return t.valueOf(0);\n          if (this.isNegative()) return t.NaN;\n          var e = 1 / Math.sqrt(this._hi),\n            n = this._hi * e,\n            i = t.valueOf(n),\n            r = this.subtract(i.sqr())._hi * (.5 * e);\n          return i.add(r);\n        }\n      }, {\n        key: \"selfAdd\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.selfAdd(e._hi, e._lo);\n            }\n            if (\"number\" == typeof arguments[0]) {\n              var n,\n                i,\n                r,\n                s,\n                a,\n                o = arguments[0],\n                u = null;\n              return u = (r = this._hi + o) - (s = r - this._hi), i = (a = (u = o - s + (this._hi - u)) + this._lo) + (r - (n = r + a)), this._hi = n + i, this._lo = i + (n - this._hi), this;\n            }\n          } else if (2 === arguments.length) {\n            var l,\n              h,\n              c,\n              f,\n              g = arguments[0],\n              v = arguments[1],\n              y = null,\n              d = null,\n              _ = null;\n            c = this._hi + g, h = this._lo + v, d = c - (_ = c - this._hi), y = h - (f = h - this._lo);\n            var p = (l = c + (_ = (d = g - _ + (this._hi - d)) + h)) + (_ = (y = v - f + (this._lo - y)) + (_ + (c - l))),\n              m = _ + (l - p);\n            return this._hi = p, this._lo = m, this;\n          }\n        }\n      }, {\n        key: \"selfMultiply\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof t) {\n              var e = arguments[0];\n              return this.selfMultiply(e._hi, e._lo);\n            }\n            if (\"number\" == typeof arguments[0]) {\n              var n = arguments[0];\n              return this.selfMultiply(n, 0);\n            }\n          } else if (2 === arguments.length) {\n            var i,\n              r,\n              s = arguments[0],\n              a = arguments[1],\n              o = null,\n              u = null,\n              l = null,\n              h = null;\n            o = (l = t.SPLIT * this._hi) - this._hi, h = t.SPLIT * s, o = l - o, i = this._hi - o, u = h - s;\n            var c = (l = this._hi * s) + (h = o * (u = h - u) - l + o * (r = s - u) + i * u + i * r + (this._hi * a + this._lo * s)),\n              f = h + (o = l - c);\n            return this._hi = c, this._lo = f, this;\n          }\n        }\n      }, {\n        key: \"selfSqr\",\n        value: function () {\n          return this.selfMultiply(this);\n        }\n      }, {\n        key: \"floor\",\n        value: function () {\n          if (this.isNaN()) return t.NaN;\n          var e = Math.floor(this._hi),\n            n = 0;\n          return e === this._hi && (n = Math.floor(this._lo)), new t(e, n);\n        }\n      }, {\n        key: \"negate\",\n        value: function () {\n          return this.isNaN() ? this : new t(-this._hi, -this._lo);\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          try {\n            return null;\n          } catch (t) {\n            if (t instanceof CloneNotSupportedException) return null;\n            throw t;\n          }\n        }\n      }, {\n        key: \"multiply\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return e.isNaN() ? t.createNaN() : t.copy(this).selfMultiply(e);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return A.isNaN(n) ? t.createNaN() : t.copy(this).selfMultiply(n, 0);\n          }\n        }\n      }, {\n        key: \"isNaN\",\n        value: function () {\n          return A.isNaN(this._hi);\n        }\n      }, {\n        key: \"intValue\",\n        value: function () {\n          return Math.trunc(this._hi);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var e = t.magnitude(this._hi);\n          return e >= -3 && e <= 20 ? this.toStandardNotation() : this.toSciNotation();\n        }\n      }, {\n        key: \"toStandardNotation\",\n        value: function () {\n          var e = this.getSpecialNumberString();\n          if (null !== e) return e;\n          var n = new Array(1).fill(null),\n            i = this.extractSignificantDigits(!0, n),\n            r = n[0] + 1,\n            s = i;\n          if (\".\" === i.charAt(0)) s = \"0\" + i;else if (r < 0) s = \"0.\" + t.stringOfChar(\"0\", -r) + i;else if (-1 === i.indexOf(\".\")) {\n            var a = r - i.length;\n            s = i + t.stringOfChar(\"0\", a) + \".0\";\n          }\n          return this.isNegative() ? \"-\" + s : s;\n        }\n      }, {\n        key: \"reciprocal\",\n        value: function () {\n          var e,\n            n,\n            i,\n            r,\n            s = null,\n            a = null,\n            o = null,\n            u = null;\n          e = (i = 1 / this._hi) - (s = (o = t.SPLIT * i) - (s = o - i)), a = (u = t.SPLIT * this._hi) - this._hi;\n          var l = i + (o = (1 - (r = i * this._hi) - (u = s * (a = u - a) - r + s * (n = this._hi - a) + e * a + e * n) - i * this._lo) / this._hi);\n          return new t(l, i - l + o);\n        }\n      }, {\n        key: \"toSciNotation\",\n        value: function () {\n          if (this.isZero()) return t.SCI_NOT_ZERO;\n          var e = this.getSpecialNumberString();\n          if (null !== e) return e;\n          var n = new Array(1).fill(null),\n            i = this.extractSignificantDigits(!1, n),\n            r = t.SCI_NOT_EXPONENT_CHAR + n[0];\n          if (\"0\" === i.charAt(0)) throw new IllegalStateException(\"Found leading zero: \" + i);\n          var s = \"\";\n          i.length > 1 && (s = i.substring(1));\n          var a = i.charAt(0) + \".\" + s;\n          return this.isNegative() ? \"-\" + a + r : a + r;\n        }\n      }, {\n        key: \"abs\",\n        value: function () {\n          return this.isNaN() ? t.NaN : this.isNegative() ? this.negate() : new t(this);\n        }\n      }, {\n        key: \"isPositive\",\n        value: function () {\n          return this._hi > 0 || 0 === this._hi && this._lo > 0;\n        }\n      }, {\n        key: \"lt\",\n        value: function (t) {\n          return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo;\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return t.copy(this).selfAdd(e);\n          }\n          if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            return t.copy(this).selfAdd(n);\n          }\n        }\n      }, {\n        key: \"init\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (\"number\" == typeof arguments[0]) {\n              var e = arguments[0];\n              this._hi = e, this._lo = 0;\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this._hi = n._hi, this._lo = n._lo;\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this._hi = i, this._lo = r;\n          }\n        }\n      }, {\n        key: \"gt\",\n        value: function (t) {\n          return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo;\n        }\n      }, {\n        key: \"isNegative\",\n        value: function () {\n          return this._hi < 0 || 0 === this._hi && this._lo < 0;\n        }\n      }, {\n        key: \"trunc\",\n        value: function () {\n          return this.isNaN() ? t.NaN : this.isPositive() ? this.floor() : this.ceil();\n        }\n      }, {\n        key: \"signum\",\n        value: function () {\n          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E, x, I];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);else if (1 === arguments.length) {\n            if (\"number\" == typeof arguments[0]) {\n              var e = arguments[0];\n              this.init(e);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this.init(n);\n            } else if (\"string\" == typeof arguments[0]) {\n              var i = arguments[0];\n              t.constructor_.call(this, t.parse(i));\n            }\n          } else if (2 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1];\n            this.init(r, s);\n          }\n        }\n      }, {\n        key: \"determinant\",\n        value: function () {\n          if (\"number\" == typeof arguments[3] && \"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1],\n              i = arguments[2],\n              r = arguments[3];\n            return t.determinant(t.valueOf(e), t.valueOf(n), t.valueOf(i), t.valueOf(r));\n          }\n          if (arguments[3] instanceof t && arguments[2] instanceof t && arguments[0] instanceof t && arguments[1] instanceof t) {\n            var s = arguments[1],\n              a = arguments[2],\n              o = arguments[3];\n            return arguments[0].multiply(o).selfSubtract(s.multiply(a));\n          }\n        }\n      }, {\n        key: \"sqr\",\n        value: function (e) {\n          return t.valueOf(e).selfMultiply(e);\n        }\n      }, {\n        key: \"valueOf\",\n        value: function () {\n          if (\"string\" == typeof arguments[0]) {\n            var e = arguments[0];\n            return t.parse(e);\n          }\n          if (\"number\" == typeof arguments[0]) return new t(arguments[0]);\n        }\n      }, {\n        key: \"sqrt\",\n        value: function (e) {\n          return t.valueOf(e).sqrt();\n        }\n      }, {\n        key: \"parse\",\n        value: function (e) {\n          for (var n = 0, i = e.length; ot.isWhitespace(e.charAt(n));) n++;\n          var r = !1;\n          if (n < i) {\n            var s = e.charAt(n);\n            \"-\" !== s && \"+\" !== s || (n++, \"-\" === s && (r = !0));\n          }\n          for (var a = new t(), o = 0, u = 0, l = 0, h = !1; !(n >= i);) {\n            var c = e.charAt(n);\n            if (n++, ot.isDigit(c)) {\n              var f = c - \"0\";\n              a.selfMultiply(t.TEN), a.selfAdd(f), o++;\n            } else {\n              if (\".\" !== c) {\n                if (\"e\" === c || \"E\" === c) {\n                  var g = e.substring(n);\n                  try {\n                    l = at.parseInt(g);\n                  } catch (t) {\n                    throw t instanceof NumberFormatException ? new NumberFormatException(\"Invalid exponent \" + g + \" in string \" + e) : t;\n                  }\n                  break;\n                }\n                throw new NumberFormatException(\"Unexpected character '\" + c + \"' at position \" + n + \" in string \" + e);\n              }\n              u = o, h = !0;\n            }\n          }\n          var v = a;\n          h || (u = o);\n          var y = o - u - l;\n          if (0 === y) v = a;else if (y > 0) {\n            var d = t.TEN.pow(y);\n            v = a.divide(d);\n          } else if (y < 0) {\n            var _ = t.TEN.pow(-y);\n            v = a.multiply(_);\n          }\n          return r ? v.negate() : v;\n        }\n      }, {\n        key: \"createNaN\",\n        value: function () {\n          return new t(A.NaN, A.NaN);\n        }\n      }, {\n        key: \"copy\",\n        value: function (e) {\n          return new t(e);\n        }\n      }, {\n        key: \"magnitude\",\n        value: function (t) {\n          var e = Math.abs(t),\n            n = Math.log(e) / Math.log(10),\n            i = Math.trunc(Math.floor(n));\n          return 10 * Math.pow(10, i) <= e && (i += 1), i;\n        }\n      }, {\n        key: \"stringOfChar\",\n        value: function (t, e) {\n          for (var n = new st(), i = 0; i < e; i++) n.append(t);\n          return n.toString();\n        }\n      }]);\n    }();\n  ut.PI = new ut(3.141592653589793, 12246467991473532e-32), ut.TWO_PI = new ut(6.283185307179586, 24492935982947064e-32), ut.PI_2 = new ut(1.5707963267948966, 6123233995736766e-32), ut.E = new ut(2.718281828459045, 14456468917292502e-32), ut.NaN = new ut(A.NaN, A.NaN), ut.EPS = 123259516440783e-46, ut.SPLIT = 134217729, ut.MAX_PRINT_DIGITS = 32, ut.TEN = ut.valueOf(10), ut.ONE = ut.valueOf(1), ut.SCI_NOT_EXPONENT_CHAR = \"E\", ut.SCI_NOT_ZERO = \"0.0E0\";\n  var lt = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"orientationIndex\",\n      value: function (e, n, i) {\n        var r = t.orientationIndexFilter(e, n, i);\n        if (r <= 1) return r;\n        var s = ut.valueOf(n.x).selfAdd(-e.x),\n          a = ut.valueOf(n.y).selfAdd(-e.y),\n          o = ut.valueOf(i.x).selfAdd(-n.x),\n          u = ut.valueOf(i.y).selfAdd(-n.y);\n        return s.selfMultiply(u).selfSubtract(a.selfMultiply(o)).signum();\n      }\n    }, {\n      key: \"signOfDet2x2\",\n      value: function () {\n        if (arguments[3] instanceof ut && arguments[2] instanceof ut && arguments[0] instanceof ut && arguments[1] instanceof ut) {\n          var t = arguments[1],\n            e = arguments[2],\n            n = arguments[3];\n          return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum();\n        }\n        if (\"number\" == typeof arguments[3] && \"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n          var i = arguments[0],\n            r = arguments[1],\n            s = arguments[2],\n            a = arguments[3],\n            o = ut.valueOf(i),\n            u = ut.valueOf(r),\n            l = ut.valueOf(s),\n            h = ut.valueOf(a);\n          return o.multiply(h).selfSubtract(u.multiply(l)).signum();\n        }\n      }\n    }, {\n      key: \"intersection\",\n      value: function (t, e, n, i) {\n        var r = new ut(t.y).selfSubtract(e.y),\n          s = new ut(e.x).selfSubtract(t.x),\n          a = new ut(t.x).selfMultiply(e.y).selfSubtract(new ut(e.x).selfMultiply(t.y)),\n          o = new ut(n.y).selfSubtract(i.y),\n          u = new ut(i.x).selfSubtract(n.x),\n          l = new ut(n.x).selfMultiply(i.y).selfSubtract(new ut(i.x).selfMultiply(n.y)),\n          h = s.multiply(l).selfSubtract(u.multiply(a)),\n          c = o.multiply(a).selfSubtract(r.multiply(l)),\n          f = r.multiply(u).selfSubtract(o.multiply(s)),\n          g = h.selfDivide(f).doubleValue(),\n          v = c.selfDivide(f).doubleValue();\n        return A.isNaN(g) || A.isInfinite(g) || A.isNaN(v) || A.isInfinite(v) ? null : new X(g, v);\n      }\n    }, {\n      key: \"orientationIndexFilter\",\n      value: function (e, n, i) {\n        var r = null,\n          s = (e.x - i.x) * (n.y - i.y),\n          a = (e.y - i.y) * (n.x - i.x),\n          o = s - a;\n        if (s > 0) {\n          if (a <= 0) return t.signum(o);\n          r = s + a;\n        } else {\n          if (!(s < 0)) return t.signum(o);\n          if (a >= 0) return t.signum(o);\n          r = -s - a;\n        }\n        var u = t.DP_SAFE_EPSILON * r;\n        return o >= u || -o >= u ? t.signum(o) : 2;\n      }\n    }, {\n      key: \"signum\",\n      value: function (t) {\n        return t > 0 ? 1 : t < 0 ? -1 : 0;\n      }\n    }]);\n  }();\n  lt.DP_SAFE_EPSILON = 1e-15;\n  var ht = function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"getM\",\n      value: function (t) {\n        if (this.hasM()) {\n          var e = this.getDimension() - this.getMeasures();\n          return this.getOrdinate(t, e);\n        }\n        return A.NaN;\n      }\n    }, {\n      key: \"setOrdinate\",\n      value: function (t, e, n) {}\n    }, {\n      key: \"getZ\",\n      value: function (t) {\n        return this.hasZ() ? this.getOrdinate(t, 2) : A.NaN;\n      }\n    }, {\n      key: \"size\",\n      value: function () {}\n    }, {\n      key: \"getOrdinate\",\n      value: function (t, e) {}\n    }, {\n      key: \"getCoordinate\",\n      value: function () {}\n    }, {\n      key: \"getCoordinateCopy\",\n      value: function (t) {}\n    }, {\n      key: \"createCoordinate\",\n      value: function () {}\n    }, {\n      key: \"getDimension\",\n      value: function () {}\n    }, {\n      key: \"hasM\",\n      value: function () {\n        return this.getMeasures() > 0;\n      }\n    }, {\n      key: \"getX\",\n      value: function (t) {}\n    }, {\n      key: \"hasZ\",\n      value: function () {\n        return this.getDimension() - this.getMeasures() > 2;\n      }\n    }, {\n      key: \"getMeasures\",\n      value: function () {\n        return 0;\n      }\n    }, {\n      key: \"expandEnvelope\",\n      value: function (t) {}\n    }, {\n      key: \"copy\",\n      value: function () {}\n    }, {\n      key: \"getY\",\n      value: function (t) {}\n    }, {\n      key: \"toCoordinateArray\",\n      value: function () {}\n    }, {\n      key: \"interfaces_\",\n      get: function () {\n        return [I];\n      }\n    }]);\n  }();\n  ht.X = 0, ht.Y = 1, ht.Z = 2, ht.M = 3;\n  var ct = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"index\",\n      value: function (t, e, n) {\n        return lt.orientationIndex(t, e, n);\n      }\n    }, {\n      key: \"isCCW\",\n      value: function () {\n        if (arguments[0] instanceof Array) {\n          var e = arguments[0],\n            n = e.length - 1;\n          if (n < 3) throw new m(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n          for (var i = e[0], r = 0, s = 1; s <= n; s++) {\n            var a = e[s];\n            a.y > i.y && (i = a, r = s);\n          }\n          var o = r;\n          do {\n            (o -= 1) < 0 && (o = n);\n          } while (e[o].equals2D(i) && o !== r);\n          var u = r;\n          do {\n            u = (u + 1) % n;\n          } while (e[u].equals2D(i) && u !== r);\n          var l = e[o],\n            h = e[u];\n          if (l.equals2D(i) || h.equals2D(i) || l.equals2D(h)) return !1;\n          var c = t.index(l, i, h);\n          return 0 === c ? l.x > h.x : c > 0;\n        }\n        if (rt(arguments[0], ht)) {\n          var f = arguments[0],\n            g = f.size() - 1;\n          if (g < 3) throw new m(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n          for (var v = f.getCoordinate(0), y = 0, d = 1; d <= g; d++) {\n            var _ = f.getCoordinate(d);\n            _.y > v.y && (v = _, y = d);\n          }\n          var p = null,\n            k = y;\n          do {\n            (k -= 1) < 0 && (k = g), p = f.getCoordinate(k);\n          } while (p.equals2D(v) && k !== y);\n          var x = null,\n            I = y;\n          do {\n            I = (I + 1) % g, x = f.getCoordinate(I);\n          } while (x.equals2D(v) && I !== y);\n          if (p.equals2D(v) || x.equals2D(v) || p.equals2D(x)) return !1;\n          var E = t.index(p, v, x);\n          return 0 === E ? p.x > x.x : E > 0;\n        }\n      }\n    }]);\n  }();\n  ct.CLOCKWISE = -1, ct.RIGHT = ct.CLOCKWISE, ct.COUNTERCLOCKWISE = 1, ct.LEFT = ct.COUNTERCLOCKWISE, ct.COLLINEAR = 0, ct.STRAIGHT = ct.COLLINEAR;\n  var ft = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getCoordinate\",\n        value: function () {\n          return this._minCoord;\n        }\n      }, {\n        key: \"getRightmostSide\",\n        value: function (t, e) {\n          var n = this.getRightmostSideOfSegment(t, e);\n          return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;\n        }\n      }, {\n        key: \"findRightmostEdgeAtVertex\",\n        value: function () {\n          var t = this._minDe.getEdge().getCoordinates();\n          G.isTrue(this._minIndex > 0 && this._minIndex < t.length, \"rightmost point expected to be interior vertex of edge\");\n          var e = t[this._minIndex - 1],\n            n = t[this._minIndex + 1],\n            i = ct.index(this._minCoord, n, e),\n            r = !1;\n          (e.y < this._minCoord.y && n.y < this._minCoord.y && i === ct.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && i === ct.CLOCKWISE) && (r = !0), r && (this._minIndex = this._minIndex - 1);\n        }\n      }, {\n        key: \"getRightmostSideOfSegment\",\n        value: function (t, e) {\n          var n = t.getEdge().getCoordinates();\n          if (e < 0 || e + 1 >= n.length) return -1;\n          if (n[e].y === n[e + 1].y) return -1;\n          var i = $.LEFT;\n          return n[e].y < n[e + 1].y && (i = $.RIGHT), i;\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._orientedDe;\n        }\n      }, {\n        key: \"checkForRightmostCoordinate\",\n        value: function (t) {\n          for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++) (null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]);\n        }\n      }, {\n        key: \"findRightmostEdgeAtNode\",\n        value: function () {\n          var t = this._minDe.getNode().getEdges();\n          this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);\n        }\n      }, {\n        key: \"findEdge\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next();\n            n.isForward() && this.checkForRightmostCoordinate(n);\n          }\n          G.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === $.LEFT && (this._orientedDe = this._minDe.getSym());\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;\n        }\n      }]);\n    }(),\n    gt = function (t) {\n      function i(t, r) {\n        var s;\n        return n(this, i), (s = e(this, i, [r ? t + \" [ \" + r + \" ]\" : t])).pt = r ? new X(r) : void 0, s.name = Object.keys({\n          TopologyException: i\n        })[0], s;\n      }\n      return l(i, t), s(i, [{\n        key: \"getCoordinate\",\n        value: function () {\n          return this.pt;\n        }\n      }]);\n    }(D),\n    vt = function () {\n      return s(function t() {\n        n(this, t), this.array = [];\n      }, [{\n        key: \"addLast\",\n        value: function (t) {\n          this.array.push(t);\n        }\n      }, {\n        key: \"removeFirst\",\n        value: function () {\n          return this.array.shift();\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }]);\n    }(),\n    yt = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i)).array = [], t instanceof Z && r.addAll(t), r;\n      }\n      return l(i, t), s(i, [{\n        key: \"interfaces_\",\n        get: function () {\n          return [nt, Z];\n        }\n      }, {\n        key: \"ensureCapacity\",\n        value: function () {}\n      }, {\n        key: \"add\",\n        value: function (t) {\n          return 1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0;\n        }\n      }, {\n        key: \"clear\",\n        value: function () {\n          this.array = [];\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          var e,\n            n = a(t);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              var i = e.value;\n              this.array.push(i);\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n        }\n      }, {\n        key: \"set\",\n        value: function (t, e) {\n          var n = this.array[t];\n          return this.array[t] = e, n;\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return new dt(this);\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          if (t < 0 || t >= this.size()) throw new et();\n          return this.array[t];\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }, {\n        key: \"sort\",\n        value: function (t) {\n          t ? this.array.sort(function (e, n) {\n            return t.compare(e, n);\n          }) : this.array.sort();\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.array.length;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return this.array.slice();\n        }\n      }, {\n        key: \"remove\",\n        value: function (t) {\n          for (var e = 0, n = this.array.length; e < n; e++) if (this.array[e] === t) return !!this.array.splice(e, 1);\n          return !1;\n        }\n      }, {\n        key: Symbol.iterator,\n        value: function () {\n          return this.array.values();\n        }\n      }]);\n    }(nt),\n    dt = function () {\n      return s(function t(e) {\n        n(this, t), this.arrayList = e, this.position = 0;\n      }, [{\n        key: \"next\",\n        value: function () {\n          if (this.position === this.arrayList.size()) throw new j();\n          return this.arrayList.get(this.position++);\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          return this.position < this.arrayList.size();\n        }\n      }, {\n        key: \"set\",\n        value: function (t) {\n          return this.arrayList.set(this.position - 1, t);\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          this.arrayList.remove(this.arrayList.get(this.position));\n        }\n      }]);\n    }(),\n    _t = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"clearVisitedEdges\",\n        value: function () {\n          for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n            t.next().setVisited(!1);\n          }\n        }\n      }, {\n        key: \"getRightmostCoordinate\",\n        value: function () {\n          return this._rightMostCoord;\n        }\n      }, {\n        key: \"computeNodeDepth\",\n        value: function (t) {\n          for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {\n            var i = n.next();\n            if (i.isVisited() || i.getSym().isVisited()) {\n              e = i;\n              break;\n            }\n          }\n          if (null === e) throw new gt(\"unable to find edge to compute depths at \" + t.getCoordinate());\n          t.getEdges().computeDepths(e);\n          for (var r = t.getEdges().iterator(); r.hasNext();) {\n            var s = r.next();\n            s.setVisited(!0), this.copySymDepths(s);\n          }\n        }\n      }, {\n        key: \"computeDepth\",\n        value: function (t) {\n          this.clearVisitedEdges();\n          var e = this._finder.getEdge();\n          e.getNode(), e.getLabel(), e.setEdgeDepths($.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);\n        }\n      }, {\n        key: \"create\",\n        value: function (t) {\n          this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();\n        }\n      }, {\n        key: \"findResultEdges\",\n        value: function () {\n          for (var t = this._dirEdgeList.iterator(); t.hasNext();) {\n            var e = t.next();\n            e.getDepth($.RIGHT) >= 1 && e.getDepth($.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);\n          }\n        }\n      }, {\n        key: \"computeDepths\",\n        value: function (t) {\n          var e = new J(),\n            n = new vt(),\n            i = t.getNode();\n          for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {\n            var r = n.removeFirst();\n            e.add(r), this.computeNodeDepth(r);\n            for (var s = r.getEdges().iterator(); s.hasNext();) {\n              var a = s.next().getSym();\n              if (!a.isVisited()) {\n                var o = a.getNode();\n                e.contains(o) || (n.addLast(o), e.add(o));\n              }\n            }\n          }\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          if (null === this._env) {\n            for (var t = new U(), e = this._dirEdgeList.iterator(); e.hasNext();) for (var n = e.next().getEdge().getCoordinates(), i = 0; i < n.length - 1; i++) t.expandToInclude(n[i]);\n            this._env = t;\n          }\n          return this._env;\n        }\n      }, {\n        key: \"addReachable\",\n        value: function (t) {\n          var e = new it();\n          for (e.add(t); !e.empty();) {\n            var n = e.pop();\n            this.add(n, e);\n          }\n        }\n      }, {\n        key: \"copySymDepths\",\n        value: function (t) {\n          var e = t.getSym();\n          e.setDepth($.LEFT, t.getDepth($.RIGHT)), e.setDepth($.RIGHT, t.getDepth($.LEFT));\n        }\n      }, {\n        key: \"add\",\n        value: function (t, e) {\n          t.setVisited(!0), this._nodes.add(t);\n          for (var n = t.getEdges().iterator(); n.hasNext();) {\n            var i = n.next();\n            this._dirEdgeList.add(i);\n            var r = i.getSym().getNode();\n            r.isVisited() || e.push(r);\n          }\n        }\n      }, {\n        key: \"getNodes\",\n        value: function () {\n          return this._nodes;\n        }\n      }, {\n        key: \"getDirectedEdges\",\n        value: function () {\n          return this._dirEdgeList;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._finder = null, this._dirEdgeList = new yt(), this._nodes = new yt(), this._rightMostCoord = null, this._env = null, this._finder = new ft();\n        }\n      }]);\n    }(),\n    pt = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"intersection\",\n        value: function (t, e, n, i) {\n          var r = t.x < e.x ? t.x : e.x,\n            s = t.y < e.y ? t.y : e.y,\n            a = t.x > e.x ? t.x : e.x,\n            o = t.y > e.y ? t.y : e.y,\n            u = n.x < i.x ? n.x : i.x,\n            l = n.y < i.y ? n.y : i.y,\n            h = n.x > i.x ? n.x : i.x,\n            c = n.y > i.y ? n.y : i.y,\n            f = ((r > u ? r : u) + (a < h ? a : h)) / 2,\n            g = ((s > l ? s : l) + (o < c ? o : c)) / 2,\n            v = t.x - f,\n            y = t.y - g,\n            d = e.x - f,\n            _ = e.y - g,\n            p = n.x - f,\n            m = n.y - g,\n            k = i.x - f,\n            x = i.y - g,\n            I = y - _,\n            E = d - v,\n            N = v * _ - d * y,\n            T = m - x,\n            S = k - p,\n            L = p * x - k * m,\n            C = I * S - T * E,\n            R = (E * L - S * N) / C,\n            w = (T * N - I * L) / C;\n          return A.isNaN(R) || A.isInfinite(R) || A.isNaN(w) || A.isInfinite(w) ? null : new X(R + f, w + g);\n        }\n      }]);\n    }(),\n    mt = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"arraycopy\",\n        value: function (t, e, n, i, r) {\n          for (var s = 0, a = e; a < e + r; a++) n[i + s] = t[a], s++;\n        }\n      }, {\n        key: \"getProperty\",\n        value: function (t) {\n          return {\n            \"line.separator\": \"\\n\"\n          }[t];\n        }\n      }]);\n    }(),\n    kt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"log10\",\n        value: function (e) {\n          var n = Math.log(e);\n          return A.isInfinite(n) || A.isNaN(n) ? n : n / t.LOG_10;\n        }\n      }, {\n        key: \"min\",\n        value: function (t, e, n, i) {\n          var r = t;\n          return e < r && (r = e), n < r && (r = n), i < r && (r = i), r;\n        }\n      }, {\n        key: \"clamp\",\n        value: function () {\n          if (\"number\" == typeof arguments[2] && \"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = arguments[2];\n            return t < e ? e : t > n ? n : t;\n          }\n          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2];\n            return i < r ? r : i > s ? s : i;\n          }\n        }\n      }, {\n        key: \"wrap\",\n        value: function (t, e) {\n          return t < 0 ? e - -t % e : t % e;\n        }\n      }, {\n        key: \"max\",\n        value: function () {\n          if (3 === arguments.length) {\n            var t = arguments[1],\n              e = arguments[2],\n              n = arguments[0];\n            return t > n && (n = t), e > n && (n = e), n;\n          }\n          if (4 === arguments.length) {\n            var i = arguments[1],\n              r = arguments[2],\n              s = arguments[3],\n              a = arguments[0];\n            return i > a && (a = i), r > a && (a = r), s > a && (a = s), a;\n          }\n        }\n      }, {\n        key: \"average\",\n        value: function (t, e) {\n          return (t + e) / 2;\n        }\n      }]);\n    }();\n  kt.LOG_10 = Math.log(10);\n  var xt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"segmentToSegment\",\n        value: function (e, n, i, r) {\n          if (e.equals(n)) return t.pointToSegment(e, i, r);\n          if (i.equals(r)) return t.pointToSegment(r, e, n);\n          var s = !1;\n          if (U.intersects(e, n, i, r)) {\n            var a = (n.x - e.x) * (r.y - i.y) - (n.y - e.y) * (r.x - i.x);\n            if (0 === a) s = !0;else {\n              var o = (e.y - i.y) * (r.x - i.x) - (e.x - i.x) * (r.y - i.y),\n                u = ((e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y)) / a,\n                l = o / a;\n              (l < 0 || l > 1 || u < 0 || u > 1) && (s = !0);\n            }\n          } else s = !0;\n          return s ? kt.min(t.pointToSegment(e, i, r), t.pointToSegment(n, i, r), t.pointToSegment(i, e, n), t.pointToSegment(r, e, n)) : 0;\n        }\n      }, {\n        key: \"pointToSegment\",\n        value: function (t, e, n) {\n          if (e.x === n.x && e.y === n.y) return t.distance(e);\n          var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n            r = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / i;\n          if (r <= 0) return t.distance(e);\n          if (r >= 1) return t.distance(n);\n          var s = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;\n          return Math.abs(s) * Math.sqrt(i);\n        }\n      }, {\n        key: \"pointToLinePerpendicular\",\n        value: function (t, e, n) {\n          var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),\n            r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;\n          return Math.abs(r) * Math.sqrt(i);\n        }\n      }, {\n        key: \"pointToSegmentString\",\n        value: function (e, n) {\n          if (0 === n.length) throw new m(\"Line array must contain at least one vertex\");\n          for (var i = e.distance(n[0]), r = 0; r < n.length - 1; r++) {\n            var s = t.pointToSegment(e, n[r], n[r + 1]);\n            s < i && (i = s);\n          }\n          return i;\n        }\n      }]);\n    }(),\n    It = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"create\",\n        value: function () {\n          if (1 === arguments.length) arguments[0] instanceof Array || rt(arguments[0], ht);else if (2 === arguments.length) ;else if (3 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            return this.create(t, e);\n          }\n        }\n      }]);\n    }(),\n    Et = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t) {}\n      }]);\n    }(),\n    Nt = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"ofLine\",\n        value: function (t) {\n          var e = t.size();\n          if (e <= 1) return 0;\n          var n = 0,\n            i = new X();\n          t.getCoordinate(0, i);\n          for (var r = i.x, s = i.y, a = 1; a < e; a++) {\n            t.getCoordinate(a, i);\n            var o = i.x,\n              u = i.y,\n              l = o - r,\n              h = u - s;\n            n += Math.sqrt(l * l + h * h), r = o, s = u;\n          }\n          return n;\n        }\n      }]);\n    }(),\n    Tt = s(function t() {\n      n(this, t);\n    }),\n    St = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"copyCoord\",\n        value: function (t, e, n, i) {\n          for (var r = Math.min(t.getDimension(), n.getDimension()), s = 0; s < r; s++) n.setOrdinate(i, s, t.getOrdinate(e, s));\n        }\n      }, {\n        key: \"isRing\",\n        value: function (t) {\n          var e = t.size();\n          return 0 === e || !(e <= 3) && t.getOrdinate(0, ht.X) === t.getOrdinate(e - 1, ht.X) && t.getOrdinate(0, ht.Y) === t.getOrdinate(e - 1, ht.Y);\n        }\n      }, {\n        key: \"scroll\",\n        value: function () {\n          if (2 === arguments.length) {\n            if (rt(arguments[0], ht) && Number.isInteger(arguments[1])) {\n              var e = arguments[0],\n                n = arguments[1];\n              t.scroll(e, n, t.isRing(e));\n            } else if (rt(arguments[0], ht) && arguments[1] instanceof X) {\n              var i = arguments[0],\n                r = arguments[1],\n                s = t.indexOf(r, i);\n              if (s <= 0) return null;\n              t.scroll(i, s);\n            }\n          } else if (3 === arguments.length) {\n            var a = arguments[0],\n              o = arguments[1],\n              u = arguments[2];\n            if (o <= 0) return null;\n            for (var l = a.copy(), h = u ? a.size() - 1 : a.size(), c = 0; c < h; c++) for (var f = 0; f < a.getDimension(); f++) a.setOrdinate(c, f, l.getOrdinate((o + c) % h, f));\n            if (u) for (var g = 0; g < a.getDimension(); g++) a.setOrdinate(h, g, a.getOrdinate(0, g));\n          }\n        }\n      }, {\n        key: \"isEqual\",\n        value: function (t, e) {\n          var n = t.size();\n          if (n !== e.size()) return !1;\n          for (var i = Math.min(t.getDimension(), e.getDimension()), r = 0; r < n; r++) for (var s = 0; s < i; s++) {\n            var a = t.getOrdinate(r, s),\n              o = e.getOrdinate(r, s);\n            if (t.getOrdinate(r, s) !== e.getOrdinate(r, s) && (!A.isNaN(a) || !A.isNaN(o))) return !1;\n          }\n          return !0;\n        }\n      }, {\n        key: \"minCoordinateIndex\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t.minCoordinateIndex(e, 0, e.size() - 1);\n          }\n          if (3 === arguments.length) {\n            for (var n = arguments[0], i = arguments[2], r = -1, s = null, a = arguments[1]; a <= i; a++) {\n              var o = n.getCoordinate(a);\n              (null === s || s.compareTo(o) > 0) && (s = o, r = a);\n            }\n            return r;\n          }\n        }\n      }, {\n        key: \"extend\",\n        value: function (e, n, i) {\n          var r = e.create(i, n.getDimension()),\n            s = n.size();\n          if (t.copy(n, 0, r, 0, s), s > 0) for (var a = s; a < i; a++) t.copy(n, s - 1, r, a, 1);\n          return r;\n        }\n      }, {\n        key: \"reverse\",\n        value: function (e) {\n          for (var n = e.size() - 1, i = Math.trunc(n / 2), r = 0; r <= i; r++) t.swap(e, r, n - r);\n        }\n      }, {\n        key: \"swap\",\n        value: function (t, e, n) {\n          if (e === n) return null;\n          for (var i = 0; i < t.getDimension(); i++) {\n            var r = t.getOrdinate(e, i);\n            t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, r);\n          }\n        }\n      }, {\n        key: \"copy\",\n        value: function (e, n, i, r, s) {\n          for (var a = 0; a < s; a++) t.copyCoord(e, n + a, i, r + a);\n        }\n      }, {\n        key: \"ensureValidRing\",\n        value: function (e, n) {\n          var i = n.size();\n          return 0 === i ? n : i <= 3 ? t.createClosedRing(e, n, 4) : n.getOrdinate(0, ht.X) === n.getOrdinate(i - 1, ht.X) && n.getOrdinate(0, ht.Y) === n.getOrdinate(i - 1, ht.Y) ? n : t.createClosedRing(e, n, i + 1);\n        }\n      }, {\n        key: \"indexOf\",\n        value: function (t, e) {\n          for (var n = 0; n < e.size(); n++) if (t.x === e.getOrdinate(n, ht.X) && t.y === e.getOrdinate(n, ht.Y)) return n;\n          return -1;\n        }\n      }, {\n        key: \"createClosedRing\",\n        value: function (e, n, i) {\n          var r = e.create(i, n.getDimension()),\n            s = n.size();\n          t.copy(n, 0, r, 0, s);\n          for (var a = s; a < i; a++) t.copy(n, 0, r, a, 1);\n          return r;\n        }\n      }, {\n        key: \"minCoordinate\",\n        value: function (t) {\n          for (var e = null, n = 0; n < t.size(); n++) {\n            var i = t.getCoordinate(n);\n            (null === e || e.compareTo(i) > 0) && (e = i);\n          }\n          return e;\n        }\n      }]);\n    }(),\n    Lt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"toDimensionSymbol\",\n        value: function (e) {\n          switch (e) {\n            case t.FALSE:\n              return t.SYM_FALSE;\n            case t.TRUE:\n              return t.SYM_TRUE;\n            case t.DONTCARE:\n              return t.SYM_DONTCARE;\n            case t.P:\n              return t.SYM_P;\n            case t.L:\n              return t.SYM_L;\n            case t.A:\n              return t.SYM_A;\n          }\n          throw new m(\"Unknown dimension value: \" + e);\n        }\n      }, {\n        key: \"toDimensionValue\",\n        value: function (e) {\n          switch (ot.toUpperCase(e)) {\n            case t.SYM_FALSE:\n              return t.FALSE;\n            case t.SYM_TRUE:\n              return t.TRUE;\n            case t.SYM_DONTCARE:\n              return t.DONTCARE;\n            case t.SYM_P:\n              return t.P;\n            case t.SYM_L:\n              return t.L;\n            case t.SYM_A:\n              return t.A;\n          }\n          throw new m(\"Unknown dimension symbol: \" + e);\n        }\n      }]);\n    }();\n  Lt.P = 0, Lt.L = 1, Lt.A = 2, Lt.FALSE = -1, Lt.TRUE = -2, Lt.DONTCARE = -3, Lt.SYM_FALSE = \"F\", Lt.SYM_TRUE = \"T\", Lt.SYM_DONTCARE = \"*\", Lt.SYM_P = \"0\", Lt.SYM_L = \"1\", Lt.SYM_A = \"2\";\n  var Ct = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t) {}\n      }]);\n    }(),\n    Rt = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"filter\",\n        value: function (t, e) {}\n      }, {\n        key: \"isDone\",\n        value: function () {}\n      }, {\n        key: \"isGeometryChanged\",\n        value: function () {}\n      }]);\n    }(),\n    wt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          return this.isEmpty() ? new U() : this._points.expandEnvelope(new U());\n        }\n      }, {\n        key: \"isRing\",\n        value: function () {\n          return this.isClosed() && this.isSimple();\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          return this._points.toCoordinateArray();\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          return new i(this._points.copy(), this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (!this.isEquivalentClass(t)) return !1;\n            var n = t;\n            if (this._points.size() !== n._points.size()) return !1;\n            for (var r = 0; r < this._points.size(); r++) if (!this.equal(this._points.getCoordinate(r), n._points.getCoordinate(r), e)) return !1;\n            return !0;\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {\n            var e = this._points.size() - 1 - t;\n            if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) {\n              if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) {\n                var n = this._points.copy();\n                St.reverse(n), this._points = n;\n              }\n              return null;\n            }\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this.isEmpty() ? null : this._points.getCoordinate(0);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return this.isClosed() ? Lt.FALSE : 0;\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          var t = this._points.copy();\n          return St.reverse(t), this.getFactory().createLineString(t);\n        }\n      }, {\n        key: \"getEndPoint\",\n        value: function () {\n          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_LINESTRING;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return Nt.ofLine(this._points);\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          return this._points.size();\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {\n              var i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));\n              if (0 !== i) return i;\n              e++, n++;\n            }\n            return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0;\n          }\n          if (2 === arguments.length) {\n            var r = arguments[0];\n            return arguments[1].compare(this._points, r._points);\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e));else if (rt(arguments[0], Rt)) {\n            var n = arguments[0];\n            if (0 === this._points.size()) return null;\n            for (var i = 0; i < this._points.size() && (n.filter(this._points, i), !n.isDone()); i++);\n            n.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            arguments[0].filter(this);\n          } else if (rt(arguments[0], k)) {\n            arguments[0].filter(this);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"isEquivalentClass\",\n        value: function (t) {\n          return t instanceof i;\n        }\n      }, {\n        key: \"getCoordinateN\",\n        value: function (t) {\n          return this._points.getCoordinate(t);\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_LINESTRING;\n        }\n      }, {\n        key: \"getCoordinateSequence\",\n        value: function () {\n          return this._points;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this._points.size();\n        }\n      }, {\n        key: \"init\",\n        value: function (t) {\n          if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new m(\"Invalid number of points in LineString (found \" + t.size() + \" - must be 0 or >= 2)\");\n          this._points = t;\n        }\n      }, {\n        key: \"isCoordinate\",\n        value: function (t) {\n          for (var e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0;\n          return !1;\n        }\n      }, {\n        key: \"getStartPoint\",\n        value: function () {\n          return this.isEmpty() ? null : this.getPointN(0);\n        }\n      }, {\n        key: \"getPointN\",\n        value: function (t) {\n          return this.getFactory().createPoint(this._points.getCoordinate(t));\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Tt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._points = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            V.constructor_.call(this, e), this.init(t);\n          }\n        }\n      }]);\n    }(V),\n    Ot = s(function t() {\n      n(this, t);\n    }),\n    bt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          if (this.isEmpty()) return new U();\n          var t = new U();\n          return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          return this.isEmpty() ? [] : [this.getCoordinate()];\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          return new i(this._coordinates.copy(), this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e));\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {}\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return Lt.FALSE;\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          return this.getFactory().createPoint(this._coordinates.copy());\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_POINT;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          return this.isEmpty() ? 0 : 1;\n        }\n      }, {\n        key: \"getX\",\n        value: function () {\n          if (null === this.getCoordinate()) throw new IllegalStateException(\"getX called on empty Point\");\n          return this.getCoordinate().x;\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.getCoordinate().compareTo(t.getCoordinate());\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0];\n            return arguments[1].compare(this._coordinates, e._coordinates);\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) {\n            var t = arguments[0];\n            if (this.isEmpty()) return null;\n            t.filter(this.getCoordinate());\n          } else if (rt(arguments[0], Rt)) {\n            var e = arguments[0];\n            if (this.isEmpty()) return null;\n            e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            arguments[0].filter(this);\n          } else if (rt(arguments[0], k)) {\n            arguments[0].filter(this);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          return this.getFactory().createGeometryCollection();\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_POINT;\n        }\n      }, {\n        key: \"getCoordinateSequence\",\n        value: function () {\n          return this._coordinates;\n        }\n      }, {\n        key: \"getY\",\n        value: function () {\n          if (null === this.getCoordinate()) throw new IllegalStateException(\"getY called on empty Point\");\n          return this.getCoordinate().y;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this._coordinates.size();\n        }\n      }, {\n        key: \"init\",\n        value: function (t) {\n          null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), G.isTrue(t.size() <= 1), this._coordinates = t;\n        }\n      }, {\n        key: \"isSimple\",\n        value: function () {\n          return !0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Ot];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._coordinates = null;\n          var t = arguments[0],\n            e = arguments[1];\n          V.constructor_.call(this, e), this.init(t);\n        }\n      }]);\n    }(V),\n    Mt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"ofRing\",\n        value: function () {\n          if (arguments[0] instanceof Array) {\n            var e = arguments[0];\n            return Math.abs(t.ofRingSigned(e));\n          }\n          if (rt(arguments[0], ht)) {\n            var n = arguments[0];\n            return Math.abs(t.ofRingSigned(n));\n          }\n        }\n      }, {\n        key: \"ofRingSigned\",\n        value: function () {\n          if (arguments[0] instanceof Array) {\n            var t = arguments[0];\n            if (t.length < 3) return 0;\n            for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {\n              var r = t[i].x - n,\n                s = t[i + 1].y;\n              e += r * (t[i - 1].y - s);\n            }\n            return e / 2;\n          }\n          if (rt(arguments[0], ht)) {\n            var a = arguments[0],\n              o = a.size();\n            if (o < 3) return 0;\n            var u = new X(),\n              l = new X(),\n              h = new X();\n            a.getCoordinate(0, l), a.getCoordinate(1, h);\n            var c = l.x;\n            h.x -= c;\n            for (var f = 0, g = 1; g < o - 1; g++) u.y = l.y, l.x = h.x, l.y = h.y, a.getCoordinate(g + 1, h), h.x -= c, f += l.x * (u.y - h.y);\n            return f / 2;\n          }\n        }\n      }]);\n    }(),\n    At = function () {\n      return s(function t() {\n        n(this, t);\n      }, null, [{\n        key: \"sort\",\n        value: function () {\n          var t = arguments,\n            e = arguments[0];\n          if (1 === arguments.length) e.sort(function (t, e) {\n            return t.compareTo(e);\n          });else if (2 === arguments.length) e.sort(function (e, n) {\n            return t[1].compare(e, n);\n          });else if (3 === arguments.length) {\n            var n = e.slice(arguments[1], arguments[2]);\n            n.sort();\n            var i = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length));\n            e.splice(0, e.length);\n            var r,\n              s = a(i);\n            try {\n              for (s.s(); !(r = s.n()).done;) {\n                var o = r.value;\n                e.push(o);\n              }\n            } catch (t) {\n              s.e(t);\n            } finally {\n              s.f();\n            }\n          } else if (4 === arguments.length) {\n            var u = e.slice(arguments[1], arguments[2]);\n            u.sort(function (e, n) {\n              return t[3].compare(e, n);\n            });\n            var l = e.slice(0, arguments[1]).concat(u, e.slice(arguments[2], e.length));\n            e.splice(0, e.length);\n            var h,\n              c = a(l);\n            try {\n              for (c.s(); !(h = c.n()).done;) {\n                var f = h.value;\n                e.push(f);\n              }\n            } catch (t) {\n              c.e(t);\n            } finally {\n              c.f();\n            }\n          }\n        }\n      }, {\n        key: \"asList\",\n        value: function (t) {\n          var e,\n            n = new yt(),\n            i = a(t);\n          try {\n            for (i.s(); !(e = i.n()).done;) {\n              var r = e.value;\n              n.add(r);\n            }\n          } catch (t) {\n            i.e(t);\n          } finally {\n            i.f();\n          }\n          return n;\n        }\n      }, {\n        key: \"copyOf\",\n        value: function (t, e) {\n          return t.slice(0, e);\n        }\n      }]);\n    }(),\n    Pt = s(function t() {\n      n(this, t);\n    }),\n    Dt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          return this._shell.getEnvelopeInternal();\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          if (this.isEmpty()) return [];\n          for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), i = 0; i < n.length; i++) t[++e] = n[i];\n          for (var r = 0; r < this._holes.length; r++) for (var s = this._holes[r].getCoordinates(), a = 0; a < s.length; a++) t[++e] = s[a];\n          return t;\n        }\n      }, {\n        key: \"getArea\",\n        value: function () {\n          var t = 0;\n          t += Mt.ofRing(this._shell.getCoordinateSequence());\n          for (var e = 0; e < this._holes.length; e++) t -= Mt.ofRing(this._holes[e].getCoordinateSequence());\n          return t;\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = this._shell.copy(), e = new Array(this._holes.length).fill(null), n = 0; n < this._holes.length; n++) e[n] = this._holes[n].copy();\n          return new i(t, e, this._factory);\n        }\n      }, {\n        key: \"isRectangle\",\n        value: function () {\n          if (0 !== this.getNumInteriorRing()) return !1;\n          if (null === this._shell) return !1;\n          if (5 !== this._shell.getNumPoints()) return !1;\n          for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {\n            var i = t.getX(n);\n            if (i !== e.getMinX() && i !== e.getMaxX()) return !1;\n            var r = t.getY(n);\n            if (r !== e.getMinY() && r !== e.getMaxY()) return !1;\n          }\n          for (var s = t.getX(0), a = t.getY(0), o = 1; o <= 4; o++) {\n            var u = t.getX(o),\n              l = t.getY(o);\n            if (u !== s === (l !== a)) return !1;\n            s = u, a = l;\n          }\n          return !0;\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (!this.isEquivalentClass(t)) return !1;\n            var n = t,\n              r = this._shell,\n              s = n._shell;\n            if (!r.equalsExact(s, e)) return !1;\n            if (this._holes.length !== n._holes.length) return !1;\n            for (var a = 0; a < this._holes.length; a++) if (!this._holes[a].equalsExact(n._holes[a], e)) return !1;\n            return !0;\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          if (0 === arguments.length) {\n            this._shell = this.normalized(this._shell, !0);\n            for (var t = 0; t < this._holes.length; t++) this._holes[t] = this.normalized(this._holes[t], !1);\n            At.sort(this._holes);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (e.isEmpty()) return null;\n            var i = e.getCoordinateSequence(),\n              r = St.minCoordinateIndex(i, 0, i.size() - 2);\n            St.scroll(i, r, !0), ct.isCCW(i) === n && St.reverse(i);\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this._shell.getCoordinate();\n        }\n      }, {\n        key: \"getNumInteriorRing\",\n        value: function () {\n          return this._holes.length;\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          for (var t = this.getExteriorRing().reverse(), e = new Array(this.getNumInteriorRing()).fill(null), n = 0; n < e.length; n++) e[n] = this.getInteriorRingN(n).reverse();\n          return this.getFactory().createPolygon(t, e);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_POLYGON;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 2;\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          var t = 0;\n          t += this._shell.getLength();\n          for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();\n          return t;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();\n          return t;\n        }\n      }, {\n        key: \"convexHull\",\n        value: function () {\n          return this.getExteriorRing().convexHull();\n        }\n      }, {\n        key: \"normalized\",\n        value: function (t, e) {\n          var n = t.copy();\n          return this.normalize(n, e), n;\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = this._shell,\n              n = t._shell;\n            return e.compareToSameClass(n);\n          }\n          if (2 === arguments.length) {\n            var i = arguments[1],\n              r = arguments[0],\n              s = this._shell,\n              a = r._shell,\n              o = s.compareToSameClass(a, i);\n            if (0 !== o) return o;\n            for (var u = this.getNumInteriorRing(), l = r.getNumInteriorRing(), h = 0; h < u && h < l;) {\n              var c = this.getInteriorRingN(h),\n                f = r.getInteriorRingN(h),\n                g = c.compareToSameClass(f, i);\n              if (0 !== g) return g;\n              h++;\n            }\n            return h < u ? 1 : h < l ? -1 : 0;\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) {\n            var t = arguments[0];\n            this._shell.apply(t);\n            for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t);\n          } else if (rt(arguments[0], Rt)) {\n            var n = arguments[0];\n            if (this._shell.apply(n), !n.isDone()) for (var i = 0; i < this._holes.length && (this._holes[i].apply(n), !n.isDone()); i++);\n            n.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            arguments[0].filter(this);\n          } else if (rt(arguments[0], k)) {\n            var r = arguments[0];\n            r.filter(this), this._shell.apply(r);\n            for (var s = 0; s < this._holes.length; s++) this._holes[s].apply(r);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          if (this.isEmpty()) return this.getFactory().createMultiLineString();\n          var t = new Array(this._holes.length + 1).fill(null);\n          t[0] = this._shell;\n          for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];\n          return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t);\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_POLYGON;\n        }\n      }, {\n        key: \"getExteriorRing\",\n        value: function () {\n          return this._shell;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this._shell.isEmpty();\n        }\n      }, {\n        key: \"getInteriorRingN\",\n        value: function (t) {\n          return this._holes[t];\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Pt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._shell = null, this._holes = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          if (V.constructor_.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), V.hasNullElements(e)) throw new m(\"holes must not contain null elements\");\n          if (t.isEmpty() && V.hasNonEmptyElements(e)) throw new m(\"shell is empty but holes are not\");\n          this._shell = t, this._holes = e;\n        }\n      }]);\n    }(V),\n    Ft = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i);\n    }(K),\n    Gt = function (t) {\n      function i(t) {\n        var r;\n        return n(this, i), (r = e(this, i)).array = [], t instanceof Z && r.addAll(t), r;\n      }\n      return l(i, t), s(i, [{\n        key: \"contains\",\n        value: function (t) {\n          var e,\n            n = a(this.array);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              if (0 === e.value.compareTo(t)) return !0;\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n          return !1;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          if (this.contains(t)) return !1;\n          for (var e = 0, n = this.array.length; e < n; e++) {\n            if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t);\n          }\n          return this.array.push(t), !0;\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          var e,\n            n = a(t);\n          try {\n            for (n.s(); !(e = n.n()).done;) {\n              var i = e.value;\n              this.add(i);\n            }\n          } catch (t) {\n            n.e(t);\n          } finally {\n            n.f();\n          }\n          return !0;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.array.length;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this.array.length;\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          return this.array.slice();\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return new qt(this.array);\n        }\n      }]);\n    }(Ft),\n    qt = function () {\n      return s(function t(e) {\n        n(this, t), this.array = e, this.position = 0;\n      }, [{\n        key: \"next\",\n        value: function () {\n          if (this.position === this.array.length) throw new j();\n          return this.array[this.position++];\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          return this.position < this.array.length;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W();\n        }\n      }]);\n    }(),\n    Yt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeEnvelopeInternal\",\n        value: function () {\n          for (var t = new U(), e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());\n          return t;\n        }\n      }, {\n        key: \"getGeometryN\",\n        value: function (t) {\n          return this._geometries[t];\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (var i = this._geometries[n].getCoordinates(), r = 0; r < i.length; r++) t[++e] = i[r];\n          return t;\n        }\n      }, {\n        key: \"getArea\",\n        value: function () {\n          for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();\n          return t;\n        }\n      }, {\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (!this.isEquivalentClass(t)) return !1;\n            var n = t;\n            if (this._geometries.length !== n._geometries.length) return !1;\n            for (var r = 0; r < this._geometries.length; r++) if (!this._geometries[r].equalsExact(n._geometries[r], e)) return !1;\n            return !0;\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();\n          At.sort(this._geometries);\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this.isEmpty() ? null : this._geometries[0].getCoordinate();\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          for (var t = Lt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());\n          return t;\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          for (var t = this._geometries.length, e = new yt(t), n = 0; n < t; n++) e.add(this._geometries[n].reverse());\n          return this.getFactory().buildGeometry(e);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_GEOMETRYCOLLECTION;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          for (var t = Lt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());\n          return t;\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();\n          return t;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();\n          return t;\n        }\n      }, {\n        key: \"getNumGeometries\",\n        value: function () {\n          return this._geometries.length;\n        }\n      }, {\n        key: \"compareToSameClass\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = new Gt(At.asList(this._geometries)),\n              n = new Gt(At.asList(t._geometries));\n            return this.compare(e, n);\n          }\n          if (2 === arguments.length) {\n            for (var i = arguments[1], r = arguments[0], s = this.getNumGeometries(), a = r.getNumGeometries(), o = 0; o < s && o < a;) {\n              var u = this.getGeometryN(o),\n                l = r.getGeometryN(o),\n                h = u.compareToSameClass(l, i);\n              if (0 !== h) return h;\n              o++;\n            }\n            return o < s ? 1 : o < a ? -1 : 0;\n          }\n        }\n      }, {\n        key: \"apply\",\n        value: function () {\n          if (rt(arguments[0], Et)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t);else if (rt(arguments[0], Rt)) {\n            var n = arguments[0];\n            if (0 === this._geometries.length) return null;\n            for (var i = 0; i < this._geometries.length && (this._geometries[i].apply(n), !n.isDone()); i++);\n            n.isGeometryChanged() && this.geometryChanged();\n          } else if (rt(arguments[0], Ct)) {\n            var r = arguments[0];\n            r.filter(this);\n            for (var s = 0; s < this._geometries.length; s++) this._geometries[s].apply(r);\n          } else if (rt(arguments[0], k)) {\n            var a = arguments[0];\n            a.filter(this);\n            for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(a);\n          }\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          return V.checkNotGeometryCollection(this), G.shouldNeverReachHere(), null;\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_GEOMETRYCOLLECTION;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;\n          return !0;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._geometries = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (V.constructor_.call(this, e), null === t && (t = []), V.hasNullElements(t)) throw new m(\"geometries must not contain null elements\");\n            this._geometries = t;\n          }\n        }\n      }]);\n    }(V),\n    zt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"isValid\",\n        value: function () {\n          return !0;\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && f(i, \"equalsExact\", this, 1).call(this, t, e);\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          if (1 === arguments.length && Number.isInteger(arguments[0])) {\n            var t = arguments[0];\n            return this._geometries[t].getCoordinate();\n          }\n          return f(i, \"getCoordinate\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return Lt.FALSE;\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_MULTIPOINT;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 0;\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          return this.getFactory().createGeometryCollection();\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_MULTIPOINT;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Ot];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Yt.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Yt),\n    Xt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          return new i(this._points.copy(), this._factory);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return Lt.FALSE;\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return !!this.isEmpty() || f(i, \"isClosed\", this, 1).call(this);\n        }\n      }, {\n        key: \"reverseInternal\",\n        value: function () {\n          var t = this._points.copy();\n          return St.reverse(t), this.getFactory().createLinearRing(t);\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_LINEARRING;\n        }\n      }, {\n        key: \"validateConstruction\",\n        value: function () {\n          if (!this.isEmpty() && !f(i, \"isClosed\", this, 1).call(this)) throw new m(\"Points of LinearRing do not form a closed linestring\");\n          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < i.MINIMUM_VALID_SIZE) throw new m(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_LINEARRING;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          wt.constructor_.call(this, t, e), this.validateConstruction();\n        }\n      }]);\n    }(wt);\n  Xt.MINIMUM_VALID_SIZE = 4;\n  var Bt = function (t) {\n    function i() {\n      var t;\n      return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n    }\n    return l(i, t), s(i, [{\n      key: \"setOrdinate\",\n      value: function (t, e) {\n        switch (t) {\n          case i.X:\n            this.x = e;\n            break;\n          case i.Y:\n            this.y = e;\n            break;\n          default:\n            throw new m(\"Invalid ordinate index: \" + t);\n        }\n      }\n    }, {\n      key: \"getZ\",\n      value: function () {\n        return X.NULL_ORDINATE;\n      }\n    }, {\n      key: \"getOrdinate\",\n      value: function (t) {\n        switch (t) {\n          case i.X:\n            return this.x;\n          case i.Y:\n            return this.y;\n        }\n        throw new m(\"Invalid ordinate index: \" + t);\n      }\n    }, {\n      key: \"setZ\",\n      value: function (t) {\n        throw new m(\"CoordinateXY dimension 2 does not support z-ordinate\");\n      }\n    }, {\n      key: \"copy\",\n      value: function () {\n        return new i(this);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"(\" + this.x + \", \" + this.y + \")\";\n      }\n    }, {\n      key: \"setCoordinate\",\n      value: function (t) {\n        this.x = t.x, this.y = t.y, this.z = t.getZ();\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        if (0 === arguments.length) X.constructor_.call(this);else if (1 === arguments.length) {\n          if (arguments[0] instanceof i) {\n            var t = arguments[0];\n            X.constructor_.call(this, t.x, t.y);\n          } else if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            X.constructor_.call(this, e.x, e.y);\n          }\n        } else if (2 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1];\n          X.constructor_.call(this, n, r, X.NULL_ORDINATE);\n        }\n      }\n    }]);\n  }(X);\n  Bt.X = 0, Bt.Y = 1, Bt.Z = -1, Bt.M = -1;\n  var Ut = function (t) {\n    function i() {\n      var t;\n      return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n    }\n    return l(i, t), s(i, [{\n      key: \"getM\",\n      value: function () {\n        return this._m;\n      }\n    }, {\n      key: \"setOrdinate\",\n      value: function (t, e) {\n        switch (t) {\n          case i.X:\n            this.x = e;\n            break;\n          case i.Y:\n            this.y = e;\n            break;\n          case i.M:\n            this._m = e;\n            break;\n          default:\n            throw new m(\"Invalid ordinate index: \" + t);\n        }\n      }\n    }, {\n      key: \"setM\",\n      value: function (t) {\n        this._m = t;\n      }\n    }, {\n      key: \"getZ\",\n      value: function () {\n        return X.NULL_ORDINATE;\n      }\n    }, {\n      key: \"getOrdinate\",\n      value: function (t) {\n        switch (t) {\n          case i.X:\n            return this.x;\n          case i.Y:\n            return this.y;\n          case i.M:\n            return this._m;\n        }\n        throw new m(\"Invalid ordinate index: \" + t);\n      }\n    }, {\n      key: \"setZ\",\n      value: function (t) {\n        throw new m(\"CoordinateXY dimension 2 does not support z-ordinate\");\n      }\n    }, {\n      key: \"copy\",\n      value: function () {\n        return new i(this);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"(\" + this.x + \", \" + this.y + \" m=\" + this.getM() + \")\";\n      }\n    }, {\n      key: \"setCoordinate\",\n      value: function (t) {\n        this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM();\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;else if (1 === arguments.length) {\n          if (arguments[0] instanceof i) {\n            var t = arguments[0];\n            X.constructor_.call(this, t.x, t.y), this._m = t._m;\n          } else if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            X.constructor_.call(this, e.x, e.y), this._m = this.getM();\n          }\n        } else if (3 === arguments.length) {\n          var n = arguments[0],\n            r = arguments[1],\n            s = arguments[2];\n          X.constructor_.call(this, n, r, X.NULL_ORDINATE), this._m = s;\n        }\n      }\n    }]);\n  }(X);\n  Ut.X = 0, Ut.Y = 1, Ut.Z = -1, Ut.M = 2;\n  var Vt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getM\",\n        value: function () {\n          return this._m;\n        }\n      }, {\n        key: \"setOrdinate\",\n        value: function (t, e) {\n          switch (t) {\n            case X.X:\n              this.x = e;\n              break;\n            case X.Y:\n              this.y = e;\n              break;\n            case X.Z:\n              this.z = e;\n              break;\n            case X.M:\n              this._m = e;\n              break;\n            default:\n              throw new m(\"Invalid ordinate index: \" + t);\n          }\n        }\n      }, {\n        key: \"setM\",\n        value: function (t) {\n          this._m = t;\n        }\n      }, {\n        key: \"getOrdinate\",\n        value: function (t) {\n          switch (t) {\n            case X.X:\n              return this.x;\n            case X.Y:\n              return this.y;\n            case X.Z:\n              return this.getZ();\n            case X.M:\n              return this.getM();\n          }\n          throw new m(\"Invalid ordinate index: \" + t);\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          return new i(this);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"(\" + this.x + \", \" + this.y + \", \" + this.getZ() + \" m=\" + this.getM() + \")\";\n        }\n      }, {\n        key: \"setCoordinate\",\n        value: function (t) {\n          this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM();\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._m = null, 0 === arguments.length) X.constructor_.call(this), this._m = 0;else if (1 === arguments.length) {\n            if (arguments[0] instanceof i) {\n              var t = arguments[0];\n              X.constructor_.call(this, t), this._m = t._m;\n            } else if (arguments[0] instanceof X) {\n              var e = arguments[0];\n              X.constructor_.call(this, e), this._m = this.getM();\n            }\n          } else if (4 === arguments.length) {\n            var n = arguments[0],\n              r = arguments[1],\n              s = arguments[2],\n              a = arguments[3];\n            X.constructor_.call(this, n, r, s), this._m = a;\n          }\n        }\n      }]);\n    }(X),\n    Ht = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"measures\",\n        value: function (t) {\n          return t instanceof Bt ? 0 : t instanceof Ut || t instanceof Vt ? 1 : 0;\n        }\n      }, {\n        key: \"dimension\",\n        value: function (t) {\n          return t instanceof Bt ? 2 : t instanceof Ut ? 3 : t instanceof Vt ? 4 : 3;\n        }\n      }, {\n        key: \"create\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t.create(e, 0);\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            return 2 === n ? new Bt() : 3 === n && 0 === i ? new X() : 3 === n && 1 === i ? new Ut() : 4 === n && 1 === i ? new Vt() : new X();\n          }\n        }\n      }]);\n    }(),\n    Zt = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getCoordinate\",\n        value: function (t) {\n          return this.get(t);\n        }\n      }, {\n        key: \"addAll\",\n        value: function () {\n          if (2 === arguments.length && \"boolean\" == typeof arguments[1] && rt(arguments[0], Z)) {\n            for (var t = arguments[1], e = !1, n = arguments[0].iterator(); n.hasNext();) this.add(n.next(), t), e = !0;\n            return e;\n          }\n          return f(i, \"addAll\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"clone\",\n        value: function () {\n          for (var t = f(i, \"clone\", this, 1).call(this), e = 0; e < this.size(); e++) t.add(e, this.get(e).clone());\n          return t;\n        }\n      }, {\n        key: \"toCoordinateArray\",\n        value: function () {\n          if (0 === arguments.length) return this.toArray(i.coordArrayType);\n          if (1 === arguments.length) {\n            if (arguments[0]) return this.toArray(i.coordArrayType);\n            for (var t = this.size(), e = new Array(t).fill(null), n = 0; n < t; n++) e[n] = this.get(t - n - 1);\n            return e;\n          }\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return f(i, \"add\", this, 1).call(this, t);\n          }\n          if (2 === arguments.length) {\n            if (arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n              var e = arguments[0],\n                n = arguments[1];\n              return this.add(e, n, !0), !0;\n            }\n            if (arguments[0] instanceof X && \"boolean\" == typeof arguments[1]) {\n              var r = arguments[0];\n              if (!arguments[1] && this.size() >= 1) if (this.get(this.size() - 1).equals2D(r)) return null;\n              f(i, \"add\", this, 1).call(this, r);\n            } else if (arguments[0] instanceof Object && \"boolean\" == typeof arguments[1]) {\n              var s = arguments[0],\n                a = arguments[1];\n              return this.add(s, a), !0;\n            }\n          } else if (3 === arguments.length) {\n            if (\"boolean\" == typeof arguments[2] && arguments[0] instanceof Array && \"boolean\" == typeof arguments[1]) {\n              var o = arguments[0],\n                u = arguments[1];\n              if (arguments[2]) for (var l = 0; l < o.length; l++) this.add(o[l], u);else for (var h = o.length - 1; h >= 0; h--) this.add(o[h], u);\n              return !0;\n            }\n            if (\"boolean\" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof X) {\n              var c = arguments[0],\n                g = arguments[1];\n              if (!arguments[2]) {\n                var v = this.size();\n                if (v > 0) {\n                  if (c > 0) if (this.get(c - 1).equals2D(g)) return null;\n                  if (c < v) if (this.get(c).equals2D(g)) return null;\n                }\n              }\n              f(i, \"add\", this, 1).call(this, c, g);\n            }\n          } else if (4 === arguments.length) {\n            var y = arguments[0],\n              d = arguments[1],\n              _ = arguments[2],\n              p = arguments[3],\n              m = 1;\n            _ > p && (m = -1);\n            for (var k = _; k !== p; k += m) this.add(y[k], d);\n            return !0;\n          }\n        }\n      }, {\n        key: \"closeRing\",\n        value: function () {\n          if (this.size() > 0) {\n            var t = this.get(0).copy();\n            this.add(t, !1);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this.ensureCapacity(t.length), this.add(t, !0);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.ensureCapacity(e.length), this.add(e, n);\n          }\n        }\n      }]);\n    }(yt);\n  Zt.coordArrayType = new Array(0).fill(null);\n  var jt = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"isRing\",\n        value: function (t) {\n          return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1]);\n        }\n      }, {\n        key: \"ptNotInList\",\n        value: function (e, n) {\n          for (var i = 0; i < e.length; i++) {\n            var r = e[i];\n            if (t.indexOf(r, n) < 0) return r;\n          }\n          return null;\n        }\n      }, {\n        key: \"scroll\",\n        value: function (e, n) {\n          var i = t.indexOf(n, e);\n          if (i < 0) return null;\n          var r = new Array(e.length).fill(null);\n          mt.arraycopy(e, i, r, 0, e.length - i), mt.arraycopy(e, 0, r, e.length - i, i), mt.arraycopy(r, 0, e, 0, e.length);\n        }\n      }, {\n        key: \"equals\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            if (t === e) return !0;\n            if (null === t || null === e) return !1;\n            if (t.length !== e.length) return !1;\n            for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;\n            return !0;\n          }\n          if (3 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1],\n              s = arguments[2];\n            if (i === r) return !0;\n            if (null === i || null === r) return !1;\n            if (i.length !== r.length) return !1;\n            for (var a = 0; a < i.length; a++) if (0 !== s.compare(i[a], r[a])) return !1;\n            return !0;\n          }\n        }\n      }, {\n        key: \"intersection\",\n        value: function (t, e) {\n          for (var n = new Zt(), i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0);\n          return n.toCoordinateArray();\n        }\n      }, {\n        key: \"measures\",\n        value: function (t) {\n          if (null === t || 0 === t.length) return 0;\n          var e,\n            n = 0,\n            i = a(t);\n          try {\n            for (i.s(); !(e = i.n()).done;) {\n              var r = e.value;\n              n = Math.max(n, Ht.measures(r));\n            }\n          } catch (t) {\n            i.e(t);\n          } finally {\n            i.f();\n          }\n          return n;\n        }\n      }, {\n        key: \"hasRepeatedPoints\",\n        value: function (t) {\n          for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;\n          return !1;\n        }\n      }, {\n        key: \"removeRepeatedPoints\",\n        value: function (e) {\n          return t.hasRepeatedPoints(e) ? new Zt(e, !1).toCoordinateArray() : e;\n        }\n      }, {\n        key: \"reverse\",\n        value: function (t) {\n          for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {\n            var r = t[i];\n            t[i] = t[e - i], t[e - i] = r;\n          }\n        }\n      }, {\n        key: \"removeNull\",\n        value: function (t) {\n          for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;\n          var i = new Array(e).fill(null);\n          if (0 === e) return i;\n          for (var r = 0, s = 0; s < t.length; s++) null !== t[s] && (i[r++] = t[s]);\n          return i;\n        }\n      }, {\n        key: \"copyDeep\",\n        value: function () {\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = t[n].copy();\n            return e;\n          }\n          if (5 === arguments.length) for (var i = arguments[0], r = arguments[1], s = arguments[2], a = arguments[3], o = arguments[4], u = 0; u < o; u++) s[a + u] = i[r + u].copy();\n        }\n      }, {\n        key: \"isEqualReversed\",\n        value: function (t, e) {\n          for (var n = 0; n < t.length; n++) {\n            var i = t[n],\n              r = e[t.length - n - 1];\n            if (0 !== i.compareTo(r)) return !1;\n          }\n          return !0;\n        }\n      }, {\n        key: \"envelope\",\n        value: function (t) {\n          for (var e = new U(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);\n          return e;\n        }\n      }, {\n        key: \"toCoordinateArray\",\n        value: function (e) {\n          return e.toArray(t.coordArrayType);\n        }\n      }, {\n        key: \"dimension\",\n        value: function (t) {\n          if (null === t || 0 === t.length) return 3;\n          var e,\n            n = 0,\n            i = a(t);\n          try {\n            for (i.s(); !(e = i.n()).done;) {\n              var r = e.value;\n              n = Math.max(n, Ht.dimension(r));\n            }\n          } catch (t) {\n            i.e(t);\n          } finally {\n            i.f();\n          }\n          return n;\n        }\n      }, {\n        key: \"atLeastNCoordinatesOrNothing\",\n        value: function (t, e) {\n          return e.length >= t ? e : [];\n        }\n      }, {\n        key: \"indexOf\",\n        value: function (t, e) {\n          for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;\n          return -1;\n        }\n      }, {\n        key: \"increasingDirection\",\n        value: function (t) {\n          for (var e = 0; e < Math.trunc(t.length / 2); e++) {\n            var n = t.length - 1 - e,\n              i = t[e].compareTo(t[n]);\n            if (0 !== i) return i;\n          }\n          return 1;\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          for (var n = 0; n < t.length && n < e.length;) {\n            var i = t[n].compareTo(e[n]);\n            if (0 !== i) return i;\n            n++;\n          }\n          return n < e.length ? -1 : n < t.length ? 1 : 0;\n        }\n      }, {\n        key: \"minCoordinate\",\n        value: function (t) {\n          for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);\n          return e;\n        }\n      }, {\n        key: \"extract\",\n        value: function (t, e, n) {\n          e = kt.clamp(e, 0, t.length);\n          var i = (n = kt.clamp(n, -1, t.length)) - e + 1;\n          n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);\n          var r = new Array(i).fill(null);\n          if (0 === i) return r;\n          for (var s = 0, a = e; a <= n; a++) r[s++] = t[a];\n          return r;\n        }\n      }]);\n    }(),\n    Wt = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"compare\",\n        value: function (t, e) {\n          var n = t,\n            i = e;\n          return jt.compare(n, i);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [P];\n        }\n      }]);\n    }(),\n    Kt = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"compare\",\n        value: function (t, e) {\n          var n = t,\n            i = e;\n          if (n.length < i.length) return -1;\n          if (n.length > i.length) return 1;\n          if (0 === n.length) return 0;\n          var r = jt.compare(n, i);\n          return jt.isEqualReversed(n, i) ? 0 : r;\n        }\n      }, {\n        key: \"OLDcompare\",\n        value: function (t, e) {\n          var n = t,\n            i = e;\n          if (n.length < i.length) return -1;\n          if (n.length > i.length) return 1;\n          if (0 === n.length) return 0;\n          for (var r = jt.increasingDirection(n), s = jt.increasingDirection(i), a = r > 0 ? 0 : n.length - 1, o = s > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {\n            var l = n[a].compareTo(i[o]);\n            if (0 !== l) return l;\n            a += r, o += s;\n          }\n          return 0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [P];\n        }\n      }]);\n    }();\n  jt.ForwardComparator = Wt, jt.BidirectionalComparator = Kt, jt.coordArrayType = new Array(0).fill(null);\n  var Jt = function () {\n      return s(function t(e) {\n        n(this, t), this.str = e;\n      }, [{\n        key: \"append\",\n        value: function (t) {\n          this.str += t;\n        }\n      }, {\n        key: \"setCharAt\",\n        value: function (t, e) {\n          this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.str;\n        }\n      }]);\n    }(),\n    Qt = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getM\",\n        value: function (t) {\n          return this.hasM() ? this._coordinates[t].getM() : A.NaN;\n        }\n      }, {\n        key: \"setOrdinate\",\n        value: function (t, e, n) {\n          switch (e) {\n            case ht.X:\n              this._coordinates[t].x = n;\n              break;\n            case ht.Y:\n              this._coordinates[t].y = n;\n              break;\n            default:\n              this._coordinates[t].setOrdinate(e, n);\n          }\n        }\n      }, {\n        key: \"getZ\",\n        value: function (t) {\n          return this.hasZ() ? this._coordinates[t].getZ() : A.NaN;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._coordinates.length;\n        }\n      }, {\n        key: \"getOrdinate\",\n        value: function (t, e) {\n          switch (e) {\n            case ht.X:\n              return this._coordinates[t].x;\n            case ht.Y:\n              return this._coordinates[t].y;\n            default:\n              return this._coordinates[t].getOrdinate(e);\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this._coordinates[t];\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0];\n            arguments[1].setCoordinate(this._coordinates[e]);\n          }\n        }\n      }, {\n        key: \"getCoordinateCopy\",\n        value: function (t) {\n          var e = this.createCoordinate();\n          return e.setCoordinate(this._coordinates[t]), e;\n        }\n      }, {\n        key: \"createCoordinate\",\n        value: function () {\n          return Ht.create(this.getDimension(), this.getMeasures());\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return this._dimension;\n        }\n      }, {\n        key: \"getX\",\n        value: function (t) {\n          return this._coordinates[t].x;\n        }\n      }, {\n        key: \"getMeasures\",\n        value: function () {\n          return this._measures;\n        }\n      }, {\n        key: \"expandEnvelope\",\n        value: function (t) {\n          for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);\n          return t;\n        }\n      }, {\n        key: \"copy\",\n        value: function () {\n          for (var e = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++) {\n            var i = this.createCoordinate();\n            i.setCoordinate(this._coordinates[n]), e[n] = i;\n          }\n          return new t(e, this._dimension, this._measures);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          if (this._coordinates.length > 0) {\n            var t = new Jt(17 * this._coordinates.length);\n            t.append(\"(\"), t.append(this._coordinates[0]);\n            for (var e = 1; e < this._coordinates.length; e++) t.append(\", \"), t.append(this._coordinates[e]);\n            return t.append(\")\"), t.toString();\n          }\n          return \"()\";\n        }\n      }, {\n        key: \"getY\",\n        value: function (t) {\n          return this._coordinates[t].y;\n        }\n      }, {\n        key: \"toCoordinateArray\",\n        value: function () {\n          return this._coordinates;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [ht, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var e = arguments[0];\n              t.constructor_.call(this, e, jt.dimension(e), jt.measures(e));\n            } else if (Number.isInteger(arguments[0])) {\n              var n = arguments[0];\n              this._coordinates = new Array(n).fill(null);\n              for (var i = 0; i < n; i++) this._coordinates[i] = new X();\n            } else if (rt(arguments[0], ht)) {\n              var r = arguments[0];\n              if (null === r) return this._coordinates = new Array(0).fill(null), null;\n              this._dimension = r.getDimension(), this._measures = r.getMeasures(), this._coordinates = new Array(r.size()).fill(null);\n              for (var s = 0; s < this._coordinates.length; s++) this._coordinates[s] = r.getCoordinateCopy(s);\n            }\n          } else if (2 === arguments.length) {\n            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n              var a = arguments[0],\n                o = arguments[1];\n              t.constructor_.call(this, a, o, jt.measures(a));\n            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n              var u = arguments[0],\n                l = arguments[1];\n              this._coordinates = new Array(u).fill(null), this._dimension = l;\n              for (var h = 0; h < u; h++) this._coordinates[h] = Ht.create(l);\n            }\n          } else if (3 === arguments.length) if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n            var c = arguments[0],\n              f = arguments[1],\n              g = arguments[2];\n            this._dimension = f, this._measures = g, this._coordinates = null === c ? new Array(0).fill(null) : c;\n          } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n            var v = arguments[0],\n              y = arguments[1],\n              d = arguments[2];\n            this._coordinates = new Array(v).fill(null), this._dimension = y, this._measures = d;\n            for (var _ = 0; _ < v; _++) this._coordinates[_] = this.createCoordinate();\n          }\n        }\n      }]);\n    }(),\n    $t = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, [{\n        key: \"readResolve\",\n        value: function () {\n          return t.instance();\n        }\n      }, {\n        key: \"create\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) return new Qt(arguments[0]);\n            if (rt(arguments[0], ht)) return new Qt(arguments[0]);\n          } else {\n            if (2 === arguments.length) {\n              var t = arguments[1];\n              return t > 3 && (t = 3), t < 2 && (t = 2), new Qt(arguments[0], t);\n            }\n            if (3 === arguments.length) {\n              var e = arguments[2],\n                n = arguments[1] - e;\n              return e > 1 && (e = 1), n > 3 && (n = 3), n < 2 && (n = 2), new Qt(arguments[0], n + e, e);\n            }\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [It, E];\n        }\n      }], [{\n        key: \"instance\",\n        value: function () {\n          return t.instanceObject;\n        }\n      }]);\n    }();\n  $t.instanceObject = new $t();\n  var te = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && f(i, \"equalsExact\", this, 1).call(this, t, e);\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_MULTIPOLYGON;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 2;\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          if (this.isEmpty()) return this.getFactory().createMultiLineString();\n          for (var t = new yt(), e = 0; e < this._geometries.length; e++) for (var n = this._geometries[e].getBoundary(), i = 0; i < n.getNumGeometries(); i++) t.add(n.getGeometryN(i));\n          var r = new Array(t.size()).fill(null);\n          return this.getFactory().createMultiLineString(t.toArray(r));\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_MULTIPOLYGON;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Pt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Yt.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Yt),\n    ee = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"get\",\n        value: function () {}\n      }, {\n        key: \"put\",\n        value: function () {}\n      }, {\n        key: \"size\",\n        value: function () {}\n      }, {\n        key: \"values\",\n        value: function () {}\n      }, {\n        key: \"entrySet\",\n        value: function () {}\n      }]);\n    }(),\n    ne = function (t) {\n      function i() {\n        var t;\n        return n(this, i), (t = e(this, i)).map = new Map(), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"get\",\n        value: function (t) {\n          return this.map.get(t) || null;\n        }\n      }, {\n        key: \"put\",\n        value: function (t, e) {\n          return this.map.set(t, e), e;\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          for (var t = new yt(), e = this.map.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();\n          return t;\n        }\n      }, {\n        key: \"entrySet\",\n        value: function () {\n          var t = new J();\n          return this.map.entries().forEach(function (e) {\n            return t.add(e);\n          }), t;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.map.size();\n        }\n      }]);\n    }(ee),\n    ie = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"equals\",\n        value: function (e) {\n          if (!(e instanceof t)) return !1;\n          var n = e;\n          return this._modelType === n._modelType && this._scale === n._scale;\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t,\n            n = this.getMaximumSignificantDigits(),\n            i = e.getMaximumSignificantDigits();\n          return at.compare(n, i);\n        }\n      }, {\n        key: \"getScale\",\n        value: function () {\n          return this._scale;\n        }\n      }, {\n        key: \"isFloating\",\n        value: function () {\n          return this._modelType === t.FLOATING || this._modelType === t.FLOATING_SINGLE;\n        }\n      }, {\n        key: \"getType\",\n        value: function () {\n          return this._modelType;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var e = \"UNKNOWN\";\n          return this._modelType === t.FLOATING ? e = \"Floating\" : this._modelType === t.FLOATING_SINGLE ? e = \"Floating-Single\" : this._modelType === t.FIXED && (e = \"Fixed (Scale=\" + this.getScale() + \")\"), e;\n        }\n      }, {\n        key: \"makePrecise\",\n        value: function () {\n          if (\"number\" == typeof arguments[0]) {\n            var e = arguments[0];\n            return A.isNaN(e) || this._modelType === t.FLOATING_SINGLE ? e : this._modelType === t.FIXED ? Math.round(e * this._scale) / this._scale : e;\n          }\n          if (arguments[0] instanceof X) {\n            var n = arguments[0];\n            if (this._modelType === t.FLOATING) return null;\n            n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y);\n          }\n        }\n      }, {\n        key: \"getMaximumSignificantDigits\",\n        value: function () {\n          var e = 16;\n          return this._modelType === t.FLOATING ? e = 16 : this._modelType === t.FLOATING_SINGLE ? e = 6 : this._modelType === t.FIXED && (e = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), e;\n        }\n      }, {\n        key: \"setScale\",\n        value: function (t) {\n          this._scale = Math.abs(t);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E, x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING;else if (1 === arguments.length) if (arguments[0] instanceof re) {\n            var e = arguments[0];\n            this._modelType = e, e === t.FIXED && this.setScale(1);\n          } else if (\"number\" == typeof arguments[0]) {\n            var n = arguments[0];\n            this._modelType = t.FIXED, this.setScale(n);\n          } else if (arguments[0] instanceof t) {\n            var i = arguments[0];\n            this._modelType = i._modelType, this._scale = i._scale;\n          }\n        }\n      }, {\n        key: \"mostPrecise\",\n        value: function (t, e) {\n          return t.compareTo(e) >= 0 ? t : e;\n        }\n      }]);\n    }(),\n    re = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"readResolve\",\n        value: function () {\n          return t.nameToTypeMap.get(this._name);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this._name;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._name = null;\n          var e = arguments[0];\n          this._name = e, t.nameToTypeMap.put(e, this);\n        }\n      }]);\n    }();\n  re.nameToTypeMap = new ne(), ie.Type = re, ie.FIXED = new re(\"FIXED\"), ie.FLOATING = new re(\"FLOATING\"), ie.FLOATING_SINGLE = new re(\"FLOATING SINGLE\"), ie.maximumPreciseValue = 9007199254740992;\n  var se = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"copyInternal\",\n        value: function () {\n          for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++) t[e] = this._geometries[e].copy();\n          return new i(t, this._factory);\n        }\n      }, {\n        key: \"equalsExact\",\n        value: function () {\n          if (2 === arguments.length && \"number\" == typeof arguments[1] && arguments[0] instanceof V) {\n            var t = arguments[0],\n              e = arguments[1];\n            return !!this.isEquivalentClass(t) && f(i, \"equalsExact\", this, 1).call(this, t, e);\n          }\n          return f(i, \"equalsExact\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"getBoundaryDimension\",\n        value: function () {\n          return this.isClosed() ? Lt.FALSE : 0;\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          if (this.isEmpty()) return !1;\n          for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;\n          return !0;\n        }\n      }, {\n        key: \"getTypeCode\",\n        value: function () {\n          return V.TYPECODE_MULTILINESTRING;\n        }\n      }, {\n        key: \"getDimension\",\n        value: function () {\n          return 1;\n        }\n      }, {\n        key: \"getBoundary\",\n        value: function () {\n          throw new W();\n        }\n      }, {\n        key: \"getGeometryType\",\n        value: function () {\n          return V.TYPENAME_MULTILINESTRING;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Tt];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Yt.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Yt),\n    ae = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"createEmpty\",\n        value: function (t) {\n          switch (t) {\n            case -1:\n              return this.createGeometryCollection();\n            case 0:\n              return this.createPoint();\n            case 1:\n              return this.createLineString();\n            case 2:\n              return this.createPolygon();\n            default:\n              throw new m(\"Invalid dimension: \" + t);\n          }\n        }\n      }, {\n        key: \"toGeometry\",\n        value: function (t) {\n          return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new X(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new X(t.getMinX(), t.getMinY()), new X(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new X(t.getMinX(), t.getMinY()), new X(t.getMinX(), t.getMaxY()), new X(t.getMaxX(), t.getMaxY()), new X(t.getMaxX(), t.getMinY()), new X(t.getMinX(), t.getMinY())]), null);\n        }\n      }, {\n        key: \"createLineString\",\n        value: function () {\n          if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var t = arguments[0];\n              return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n            }\n            if (rt(arguments[0], ht)) return new wt(arguments[0], this);\n          }\n        }\n      }, {\n        key: \"createMultiLineString\",\n        value: function () {\n          return 0 === arguments.length ? new se(null, this) : 1 === arguments.length ? new se(arguments[0], this) : void 0;\n        }\n      }, {\n        key: \"buildGeometry\",\n        value: function (e) {\n          for (var n = null, i = !1, r = !1, s = e.iterator(); s.hasNext();) {\n            var a = s.next(),\n              o = a.getTypeCode();\n            null === n && (n = o), o !== n && (i = !0), a instanceof Yt && (r = !0);\n          }\n          if (null === n) return this.createGeometryCollection();\n          if (i || r) return this.createGeometryCollection(t.toGeometryArray(e));\n          var u = e.iterator().next();\n          if (e.size() > 1) {\n            if (u instanceof Dt) return this.createMultiPolygon(t.toPolygonArray(e));\n            if (u instanceof wt) return this.createMultiLineString(t.toLineStringArray(e));\n            if (u instanceof bt) return this.createMultiPoint(t.toPointArray(e));\n            G.shouldNeverReachHere(\"Unhandled geometry type: \" + u.getGeometryType());\n          }\n          return u;\n        }\n      }, {\n        key: \"createMultiPointFromCoords\",\n        value: function (t) {\n          return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n        }\n      }, {\n        key: \"createPoint\",\n        value: function () {\n          if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof X) {\n              var t = arguments[0];\n              return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);\n            }\n            if (rt(arguments[0], ht)) return new bt(arguments[0], this);\n          }\n        }\n      }, {\n        key: \"getCoordinateSequenceFactory\",\n        value: function () {\n          return this._coordinateSequenceFactory;\n        }\n      }, {\n        key: \"createPolygon\",\n        value: function () {\n          if (0 === arguments.length) return this.createPolygon(null, null);\n          if (1 === arguments.length) {\n            if (rt(arguments[0], ht)) {\n              var t = arguments[0];\n              return this.createPolygon(this.createLinearRing(t));\n            }\n            if (arguments[0] instanceof Array) {\n              var e = arguments[0];\n              return this.createPolygon(this.createLinearRing(e));\n            }\n            if (arguments[0] instanceof Xt) {\n              var n = arguments[0];\n              return this.createPolygon(n, null);\n            }\n          } else if (2 === arguments.length) {\n            return new Dt(arguments[0], arguments[1], this);\n          }\n        }\n      }, {\n        key: \"getSRID\",\n        value: function () {\n          return this._SRID;\n        }\n      }, {\n        key: \"createGeometryCollection\",\n        value: function () {\n          return 0 === arguments.length ? new Yt(null, this) : 1 === arguments.length ? new Yt(arguments[0], this) : void 0;\n        }\n      }, {\n        key: \"getPrecisionModel\",\n        value: function () {\n          return this._precisionModel;\n        }\n      }, {\n        key: \"createLinearRing\",\n        value: function () {\n          if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var t = arguments[0];\n              return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);\n            }\n            if (rt(arguments[0], ht)) return new Xt(arguments[0], this);\n          }\n        }\n      }, {\n        key: \"createMultiPolygon\",\n        value: function () {\n          return 0 === arguments.length ? new te(null, this) : 1 === arguments.length ? new te(arguments[0], this) : void 0;\n        }\n      }, {\n        key: \"createMultiPoint\",\n        value: function () {\n          if (0 === arguments.length) return new zt(null, this);\n          if (1 === arguments.length) {\n            if (arguments[0] instanceof Array) return new zt(arguments[0], this);\n            if (rt(arguments[0], ht)) {\n              var t = arguments[0];\n              if (null === t) return this.createMultiPoint(new Array(0).fill(null));\n              for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {\n                var i = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures());\n                St.copy(t, n, i, 0, 1), e[n] = this.createPoint(i);\n              }\n              return this.createMultiPoint(e);\n            }\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) t.constructor_.call(this, new ie(), 0);else if (1 === arguments.length) {\n            if (rt(arguments[0], It)) {\n              var e = arguments[0];\n              t.constructor_.call(this, new ie(), 0, e);\n            } else if (arguments[0] instanceof ie) {\n              var n = arguments[0];\n              t.constructor_.call(this, n, 0, t.getDefaultCoordinateSequenceFactory());\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            t.constructor_.call(this, i, r, t.getDefaultCoordinateSequenceFactory());\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2];\n            this._precisionModel = s, this._coordinateSequenceFactory = o, this._SRID = a;\n          }\n        }\n      }, {\n        key: \"toMultiPolygonArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toGeometryArray\",\n        value: function (t) {\n          if (null === t) return null;\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"getDefaultCoordinateSequenceFactory\",\n        value: function () {\n          return $t.instance();\n        }\n      }, {\n        key: \"toMultiLineStringArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toLineStringArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toMultiPointArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toLinearRingArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toPointArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"toPolygonArray\",\n        value: function (t) {\n          var e = new Array(t.size()).fill(null);\n          return t.toArray(e);\n        }\n      }, {\n        key: \"createPointFromInternalCoord\",\n        value: function (t, e) {\n          return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);\n        }\n      }]);\n    }(),\n    oe = \"XY\",\n    ue = \"XYZ\",\n    le = \"XYM\",\n    he = \"XYZM\",\n    ce = {\n      POINT: \"Point\",\n      LINE_STRING: \"LineString\",\n      LINEAR_RING: \"LinearRing\",\n      POLYGON: \"Polygon\",\n      MULTI_POINT: \"MultiPoint\",\n      MULTI_LINE_STRING: \"MultiLineString\",\n      MULTI_POLYGON: \"MultiPolygon\",\n      GEOMETRY_COLLECTION: \"GeometryCollection\",\n      CIRCLE: \"Circle\"\n    },\n    fe = \"EMPTY\",\n    ge = 1,\n    ve = 2,\n    ye = 3,\n    de = 4,\n    _e = 5,\n    pe = 6;\n  for (var me in ce) ce[me].toUpperCase();\n  var ke = function () {\n      return s(function t(e) {\n        n(this, t), this.wkt = e, this.index_ = -1;\n      }, [{\n        key: \"isAlpha_\",\n        value: function (t) {\n          return t >= \"a\" && t <= \"z\" || t >= \"A\" && t <= \"Z\";\n        }\n      }, {\n        key: \"isNumeric_\",\n        value: function (t, e) {\n          return t >= \"0\" && t <= \"9\" || \".\" == t && !(void 0 !== e && e);\n        }\n      }, {\n        key: \"isWhiteSpace_\",\n        value: function (t) {\n          return \" \" == t || \"\\t\" == t || \"\\r\" == t || \"\\n\" == t;\n        }\n      }, {\n        key: \"nextChar_\",\n        value: function () {\n          return this.wkt.charAt(++this.index_);\n        }\n      }, {\n        key: \"nextToken\",\n        value: function () {\n          var t,\n            e = this.nextChar_(),\n            n = this.index_,\n            i = e;\n          if (\"(\" == e) t = ve;else if (\",\" == e) t = _e;else if (\")\" == e) t = ye;else if (this.isNumeric_(e) || \"-\" == e) t = de, i = this.readNumber_();else if (this.isAlpha_(e)) t = ge, i = this.readText_();else {\n            if (this.isWhiteSpace_(e)) return this.nextToken();\n            if (\"\" !== e) throw new Error(\"Unexpected character: \" + e);\n            t = pe;\n          }\n          return {\n            position: n,\n            value: i,\n            type: t\n          };\n        }\n      }, {\n        key: \"readNumber_\",\n        value: function () {\n          var t,\n            e = this.index_,\n            n = !1,\n            i = !1;\n          do {\n            \".\" == t ? n = !0 : \"e\" != t && \"E\" != t || (i = !0), t = this.nextChar_();\n          } while (this.isNumeric_(t, n) || !i && (\"e\" == t || \"E\" == t) || i && (\"-\" == t || \"+\" == t));\n          return parseFloat(this.wkt.substring(e, this.index_--));\n        }\n      }, {\n        key: \"readText_\",\n        value: function () {\n          var t,\n            e = this.index_;\n          do {\n            t = this.nextChar_();\n          } while (this.isAlpha_(t));\n          return this.wkt.substring(e, this.index_--).toUpperCase();\n        }\n      }]);\n    }(),\n    xe = function () {\n      return s(function t(e, i) {\n        n(this, t), this.lexer_ = e, this.token_, this.layout_ = oe, this.factory = i;\n      }, [{\n        key: \"consume_\",\n        value: function () {\n          this.token_ = this.lexer_.nextToken();\n        }\n      }, {\n        key: \"isTokenType\",\n        value: function (t) {\n          return this.token_.type == t;\n        }\n      }, {\n        key: \"match\",\n        value: function (t) {\n          var e = this.isTokenType(t);\n          return e && this.consume_(), e;\n        }\n      }, {\n        key: \"parse\",\n        value: function () {\n          return this.consume_(), this.parseGeometry_();\n        }\n      }, {\n        key: \"parseGeometryLayout_\",\n        value: function () {\n          var t = oe,\n            e = this.token_;\n          if (this.isTokenType(ge)) {\n            var n = e.value;\n            \"Z\" === n ? t = ue : \"M\" === n ? t = le : \"ZM\" === n && (t = he), t !== oe && this.consume_();\n          }\n          return t;\n        }\n      }, {\n        key: \"parseGeometryCollectionText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = [];\n            do {\n              t.push(this.parseGeometry_());\n            } while (this.match(_e));\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePointText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parsePoint_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return null;\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseLineStringText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parsePointList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePolygonText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parseLineStringTextList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseMultiPointText_\",\n        value: function () {\n          var t;\n          if (this.match(ve)) {\n            if (t = this.token_.type == ve ? this.parsePointTextList_() : this.parsePointList_(), this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseMultiLineStringText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parseLineStringTextList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parseMultiPolygonText_\",\n        value: function () {\n          if (this.match(ve)) {\n            var t = this.parsePolygonTextList_();\n            if (this.match(ye)) return t;\n          } else if (this.isEmptyGeometry_()) return [];\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePoint_\",\n        value: function () {\n          for (var t = [], e = this.layout_.length, n = 0; n < e; ++n) {\n            var i = this.token_;\n            if (!this.match(de)) break;\n            t.push(i.value);\n          }\n          if (t.length == e) return t;\n          throw new Error(this.formatErrorMessage_());\n        }\n      }, {\n        key: \"parsePointList_\",\n        value: function () {\n          for (var t = [this.parsePoint_()]; this.match(_e);) t.push(this.parsePoint_());\n          return t;\n        }\n      }, {\n        key: \"parsePointTextList_\",\n        value: function () {\n          for (var t = [this.parsePointText_()]; this.match(_e);) t.push(this.parsePointText_());\n          return t;\n        }\n      }, {\n        key: \"parseLineStringTextList_\",\n        value: function () {\n          for (var t = [this.parseLineStringText_()]; this.match(_e);) t.push(this.parseLineStringText_());\n          return t;\n        }\n      }, {\n        key: \"parsePolygonTextList_\",\n        value: function () {\n          for (var t = [this.parsePolygonText_()]; this.match(_e);) t.push(this.parsePolygonText_());\n          return t;\n        }\n      }, {\n        key: \"isEmptyGeometry_\",\n        value: function () {\n          var t = this.isTokenType(ge) && this.token_.value == fe;\n          return t && this.consume_(), t;\n        }\n      }, {\n        key: \"formatErrorMessage_\",\n        value: function () {\n          return \"Unexpected `\" + this.token_.value + \"` at position \" + this.token_.position + \" in `\" + this.lexer_.wkt + \"`\";\n        }\n      }, {\n        key: \"parseGeometry_\",\n        value: function () {\n          var t = this.factory,\n            e = function (t) {\n              return i(X, g(t));\n            },\n            n = function (n) {\n              var i = n.map(function (n) {\n                return t.createLinearRing(n.map(e));\n              });\n              return i.length > 1 ? t.createPolygon(i[0], i.slice(1)) : t.createPolygon(i[0]);\n            },\n            r = this.token_;\n          if (this.match(ge)) {\n            var s = r.value;\n            if (this.layout_ = this.parseGeometryLayout_(), \"GEOMETRYCOLLECTION\" == s) {\n              var a = this.parseGeometryCollectionText_();\n              return t.createGeometryCollection(a);\n            }\n            switch (s) {\n              case \"POINT\":\n                var o = this.parsePointText_();\n                return o ? t.createPoint(i(X, g(o))) : t.createPoint();\n              case \"LINESTRING\":\n                var u = this.parseLineStringText_().map(e);\n                return t.createLineString(u);\n              case \"LINEARRING\":\n                var l = this.parseLineStringText_().map(e);\n                return t.createLinearRing(l);\n              case \"POLYGON\":\n                var h = this.parsePolygonText_();\n                return h && 0 !== h.length ? n(h) : t.createPolygon();\n              case \"MULTIPOINT\":\n                var c = this.parseMultiPointText_();\n                if (!c || 0 === c.length) return t.createMultiPoint();\n                var f = c.map(e).map(function (e) {\n                  return t.createPoint(e);\n                });\n                return t.createMultiPoint(f);\n              case \"MULTILINESTRING\":\n                var v = this.parseMultiLineStringText_().map(function (n) {\n                  return t.createLineString(n.map(e));\n                });\n                return t.createMultiLineString(v);\n              case \"MULTIPOLYGON\":\n                var y = this.parseMultiPolygonText_();\n                if (!y || 0 === y.length) return t.createMultiPolygon();\n                var d = y.map(n);\n                return t.createMultiPolygon(d);\n              default:\n                throw new Error(\"Invalid geometry type: \" + s);\n            }\n          }\n          throw new Error(this.formatErrorMessage_());\n        }\n      }]);\n    }();\n  function Ie(t) {\n    if (t.isEmpty()) return \"\";\n    var e = t.getCoordinate(),\n      n = [e.x, e.y];\n    return void 0 === e.z || Number.isNaN(e.z) || n.push(e.z), void 0 === e.m || Number.isNaN(e.m) || n.push(e.m), n.join(\" \");\n  }\n  function Ee(t) {\n    for (var e = t.getCoordinates().map(function (t) {\n        var e = [t.x, t.y];\n        return void 0 === t.z || Number.isNaN(t.z) || e.push(t.z), void 0 === t.m || Number.isNaN(t.m) || e.push(t.m), e;\n      }), n = [], i = 0, r = e.length; i < r; ++i) n.push(e[i].join(\" \"));\n    return n.join(\", \");\n  }\n  function Ne(t) {\n    var e = [];\n    e.push(\"(\" + Ee(t.getExteriorRing()) + \")\");\n    for (var n = 0, i = t.getNumInteriorRing(); n < i; ++n) e.push(\"(\" + Ee(t.getInteriorRingN(n)) + \")\");\n    return e.join(\", \");\n  }\n  var Te = {\n    Point: Ie,\n    LineString: Ee,\n    LinearRing: Ee,\n    Polygon: Ne,\n    MultiPoint: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(\"(\" + Ie(t.getGeometryN(n)) + \")\");\n      return e.join(\", \");\n    },\n    MultiLineString: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(\"(\" + Ee(t.getGeometryN(n)) + \")\");\n      return e.join(\", \");\n    },\n    MultiPolygon: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(\"(\" + Ne(t.getGeometryN(n)) + \")\");\n      return e.join(\", \");\n    },\n    GeometryCollection: function (t) {\n      for (var e = [], n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(Se(t.getGeometryN(n)));\n      return e.join(\", \");\n    }\n  };\n  function Se(t) {\n    var e = t.getGeometryType(),\n      n = Te[e];\n    e = e.toUpperCase();\n    var i = function (t) {\n      var e = \"\";\n      if (t.isEmpty()) return e;\n      var n = t.getCoordinate();\n      return void 0 === n.z || Number.isNaN(n.z) || (e += \"Z\"), void 0 === n.m || Number.isNaN(n.m) || (e += \"M\"), e;\n    }(t);\n    return i.length > 0 && (e += \" \" + i), t.isEmpty() ? e + \" \" + fe : e + \" (\" + n(t) + \")\";\n  }\n  var Le = function () {\n      return s(function t(e) {\n        n(this, t), this.geometryFactory = e || new ae(), this.precisionModel = this.geometryFactory.getPrecisionModel();\n      }, [{\n        key: \"read\",\n        value: function (t) {\n          var e = new ke(t);\n          return new xe(e, this.geometryFactory).parse();\n        }\n      }, {\n        key: \"write\",\n        value: function (t) {\n          return Se(t);\n        }\n      }]);\n    }(),\n    Ce = function () {\n      return s(function t(e) {\n        n(this, t), this.parser = new Le(e);\n      }, [{\n        key: \"write\",\n        value: function (t) {\n          return this.parser.write(t);\n        }\n      }], [{\n        key: \"toLineString\",\n        value: function (t, e) {\n          if (2 !== arguments.length) throw new Error(\"Not implemented\");\n          return \"LINESTRING ( \" + t.x + \" \" + t.y + \", \" + e.x + \" \" + e.y + \" )\";\n        }\n      }]);\n    }(),\n    Re = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getIndexAlongSegment\",\n        value: function (t, e) {\n          return this.computeIntLineIndex(), this._intLineIndex[t][e];\n        }\n      }, {\n        key: \"getTopologySummary\",\n        value: function () {\n          var t = new Jt();\n          return this.isEndPoint() && t.append(\" endpoint\"), this._isProper && t.append(\" proper\"), this.isCollinear() && t.append(\" collinear\"), t.toString();\n        }\n      }, {\n        key: \"computeIntersection\",\n        value: function (t, e, n, i) {\n          this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i);\n        }\n      }, {\n        key: \"getIntersectionNum\",\n        value: function () {\n          return this._result;\n        }\n      }, {\n        key: \"computeIntLineIndex\",\n        value: function () {\n          if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function () {\n            return Array(2);\n          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));else if (1 === arguments.length) {\n            var t = arguments[0];\n            this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0);\n          }\n        }\n      }, {\n        key: \"isProper\",\n        value: function () {\n          return this.hasIntersection() && this._isProper;\n        }\n      }, {\n        key: \"setPrecisionModel\",\n        value: function (t) {\n          this._precisionModel = t;\n        }\n      }, {\n        key: \"isInteriorIntersection\",\n        value: function () {\n          if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;\n            return !1;\n          }\n        }\n      }, {\n        key: \"getIntersection\",\n        value: function (t) {\n          return this._intPt[t];\n        }\n      }, {\n        key: \"isEndPoint\",\n        value: function () {\n          return this.hasIntersection() && !this._isProper;\n        }\n      }, {\n        key: \"hasIntersection\",\n        value: function () {\n          return this._result !== t.NO_INTERSECTION;\n        }\n      }, {\n        key: \"getEdgeDistance\",\n        value: function (e, n) {\n          return t.computeEdgeDistance(this._intPt[n], this._inputLines[e][0], this._inputLines[e][1]);\n        }\n      }, {\n        key: \"isCollinear\",\n        value: function () {\n          return this._result === t.COLLINEAR_INTERSECTION;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return Ce.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + Ce.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n        }\n      }, {\n        key: \"getEndpoint\",\n        value: function (t, e) {\n          return this._inputLines[t][e];\n        }\n      }, {\n        key: \"isIntersection\",\n        value: function (t) {\n          for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;\n          return !1;\n        }\n      }, {\n        key: \"getIntersectionAlongSegment\",\n        value: function (t, e) {\n          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._result = null, this._inputLines = Array(2).fill().map(function () {\n            return Array(2);\n          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new X(), this._intPt[1] = new X(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;\n        }\n      }, {\n        key: \"computeEdgeDistance\",\n        value: function (t, e, n) {\n          var i = Math.abs(n.x - e.x),\n            r = Math.abs(n.y - e.y),\n            s = -1;\n          if (t.equals(e)) s = 0;else if (t.equals(n)) s = i > r ? i : r;else {\n            var a = Math.abs(t.x - e.x),\n              o = Math.abs(t.y - e.y);\n            0 !== (s = i > r ? a : o) || t.equals(e) || (s = Math.max(a, o));\n          }\n          return G.isTrue(!(0 === s && !t.equals(e)), \"Bad distance calculation\"), s;\n        }\n      }, {\n        key: \"nonRobustComputeEdgeDistance\",\n        value: function (t, e, n) {\n          var i = t.x - e.x,\n            r = t.y - e.y,\n            s = Math.sqrt(i * i + r * r);\n          return G.isTrue(!(0 === s && !t.equals(e)), \"Invalid distance calculation\"), s;\n        }\n      }]);\n    }();\n  Re.DONT_INTERSECT = 0, Re.DO_INTERSECT = 1, Re.COLLINEAR = 2, Re.NO_INTERSECTION = 0, Re.POINT_INTERSECTION = 1, Re.COLLINEAR_INTERSECTION = 2;\n  var we = function (t) {\n      function i() {\n        return n(this, i), e(this, i);\n      }\n      return l(i, t), s(i, [{\n        key: \"isInSegmentEnvelopes\",\n        value: function (t) {\n          var e = new U(this._inputLines[0][0], this._inputLines[0][1]),\n            n = new U(this._inputLines[1][0], this._inputLines[1][1]);\n          return e.contains(t) && n.contains(t);\n        }\n      }, {\n        key: \"computeIntersection\",\n        value: function () {\n          if (3 !== arguments.length) return f(i, \"computeIntersection\", this, 1).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          if (this._isProper = !1, U.intersects(e, n, t) && 0 === ct.index(e, n, t) && 0 === ct.index(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = Re.POINT_INTERSECTION, null;\n          this._result = Re.NO_INTERSECTION;\n        }\n      }, {\n        key: \"intersection\",\n        value: function (t, e, n, r) {\n          var s = this.intersectionSafe(t, e, n, r);\n          return this.isInSegmentEnvelopes(s) || (s = new X(i.nearestEndpoint(t, e, n, r))), null !== this._precisionModel && this._precisionModel.makePrecise(s), s;\n        }\n      }, {\n        key: \"checkDD\",\n        value: function (t, e, n, i, r) {\n          var s = lt.intersection(t, e, n, i),\n            a = this.isInSegmentEnvelopes(s);\n          mt.out.println(\"DD in env = \" + a + \"  --------------------- \" + s), r.distance(s) > 1e-4 && mt.out.println(\"Distance = \" + r.distance(s));\n        }\n      }, {\n        key: \"intersectionSafe\",\n        value: function (t, e, n, r) {\n          var s = pt.intersection(t, e, n, r);\n          return null === s && (s = i.nearestEndpoint(t, e, n, r)), s;\n        }\n      }, {\n        key: \"computeCollinearIntersection\",\n        value: function (t, e, n, i) {\n          var r = U.intersects(t, e, n),\n            s = U.intersects(t, e, i),\n            a = U.intersects(n, i, t),\n            o = U.intersects(n, i, e);\n          return r && s ? (this._intPt[0] = n, this._intPt[1] = i, Re.COLLINEAR_INTERSECTION) : a && o ? (this._intPt[0] = t, this._intPt[1] = e, Re.COLLINEAR_INTERSECTION) : r && a ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || s || o ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : r && o ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || s || a ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : s && a ? (this._intPt[0] = i, this._intPt[1] = t, !i.equals(t) || r || o ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : s && o ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || r || a ? Re.COLLINEAR_INTERSECTION : Re.POINT_INTERSECTION) : Re.NO_INTERSECTION;\n        }\n      }, {\n        key: \"computeIntersect\",\n        value: function (t, e, n, i) {\n          if (this._isProper = !1, !U.intersects(t, e, n, i)) return Re.NO_INTERSECTION;\n          var r = ct.index(t, e, n),\n            s = ct.index(t, e, i);\n          if (r > 0 && s > 0 || r < 0 && s < 0) return Re.NO_INTERSECTION;\n          var a = ct.index(n, i, t),\n            o = ct.index(n, i, e);\n          return a > 0 && o > 0 || a < 0 && o < 0 ? Re.NO_INTERSECTION : 0 === r && 0 === s && 0 === a && 0 === o ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === s || 0 === a || 0 === o ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this._intPt[0] = e : 0 === r ? this._intPt[0] = new X(n) : 0 === s ? this._intPt[0] = new X(i) : 0 === a ? this._intPt[0] = new X(t) : 0 === o && (this._intPt[0] = new X(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, i)), Re.POINT_INTERSECTION);\n        }\n      }], [{\n        key: \"nearestEndpoint\",\n        value: function (t, e, n, i) {\n          var r = t,\n            s = xt.pointToSegment(t, n, i),\n            a = xt.pointToSegment(e, n, i);\n          return a < s && (s = a, r = e), (a = xt.pointToSegment(n, t, e)) < s && (s = a, r = n), (a = xt.pointToSegment(i, t, e)) < s && (s = a, r = i), r;\n        }\n      }]);\n    }(Re),\n    Oe = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"countSegment\",\n        value: function (t, e) {\n          if (t.x < this._p.x && e.x < this._p.x) return null;\n          if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;\n          if (t.y === this._p.y && e.y === this._p.y) {\n            var n = t.x,\n              i = e.x;\n            return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null;\n          }\n          if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {\n            var r = ct.index(t, e, this._p);\n            if (r === ct.COLLINEAR) return this._isPointOnSegment = !0, null;\n            e.y < t.y && (r = -r), r === ct.LEFT && this._crossingCount++;\n          }\n        }\n      }, {\n        key: \"isPointInPolygon\",\n        value: function () {\n          return this.getLocation() !== H.EXTERIOR;\n        }\n      }, {\n        key: \"getLocation\",\n        value: function () {\n          return this._isPointOnSegment ? H.BOUNDARY : this._crossingCount % 2 == 1 ? H.INTERIOR : H.EXTERIOR;\n        }\n      }, {\n        key: \"isOnSegment\",\n        value: function () {\n          return this._isPointOnSegment;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;\n          var t = arguments[0];\n          this._p = t;\n        }\n      }, {\n        key: \"locatePointInRing\",\n        value: function () {\n          if (arguments[0] instanceof X && rt(arguments[1], ht)) {\n            for (var e = arguments[1], n = new t(arguments[0]), i = new X(), r = new X(), s = 1; s < e.size(); s++) if (e.getCoordinate(s, i), e.getCoordinate(s - 1, r), n.countSegment(i, r), n.isOnSegment()) return n.getLocation();\n            return n.getLocation();\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof Array) {\n            for (var a = arguments[1], o = new t(arguments[0]), u = 1; u < a.length; u++) {\n              var l = a[u],\n                h = a[u - 1];\n              if (o.countSegment(l, h), o.isOnSegment()) return o.getLocation();\n            }\n            return o.getLocation();\n          }\n        }\n      }]);\n    }(),\n    be = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"isOnLine\",\n        value: function () {\n          if (arguments[0] instanceof X && rt(arguments[1], ht)) {\n            for (var t = arguments[0], e = arguments[1], n = new we(), i = new X(), r = new X(), s = e.size(), a = 1; a < s; a++) if (e.getCoordinate(a - 1, i), e.getCoordinate(a, r), n.computeIntersection(t, i, r), n.hasIntersection()) return !0;\n            return !1;\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof Array) {\n            for (var o = arguments[0], u = arguments[1], l = new we(), h = 1; h < u.length; h++) {\n              var c = u[h - 1],\n                f = u[h];\n              if (l.computeIntersection(o, c, f), l.hasIntersection()) return !0;\n            }\n            return !1;\n          }\n        }\n      }, {\n        key: \"locateInRing\",\n        value: function (t, e) {\n          return Oe.locatePointInRing(t, e);\n        }\n      }, {\n        key: \"isInRing\",\n        value: function (e, n) {\n          return t.locateInRing(e, n) !== H.EXTERIOR;\n        }\n      }]);\n    }(),\n    Me = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"setAllLocations\",\n        value: function (t) {\n          for (var e = 0; e < this.location.length; e++) this.location[e] = t;\n        }\n      }, {\n        key: \"isNull\",\n        value: function () {\n          for (var t = 0; t < this.location.length; t++) if (this.location[t] !== H.NONE) return !1;\n          return !0;\n        }\n      }, {\n        key: \"setAllLocationsIfNull\",\n        value: function (t) {\n          for (var e = 0; e < this.location.length; e++) this.location[e] === H.NONE && (this.location[e] = t);\n        }\n      }, {\n        key: \"isLine\",\n        value: function () {\n          return 1 === this.location.length;\n        }\n      }, {\n        key: \"merge\",\n        value: function (t) {\n          if (t.location.length > this.location.length) {\n            var e = new Array(3).fill(null);\n            e[$.ON] = this.location[$.ON], e[$.LEFT] = H.NONE, e[$.RIGHT] = H.NONE, this.location = e;\n          }\n          for (var n = 0; n < this.location.length; n++) this.location[n] === H.NONE && n < t.location.length && (this.location[n] = t.location[n]);\n        }\n      }, {\n        key: \"getLocations\",\n        value: function () {\n          return this.location;\n        }\n      }, {\n        key: \"flip\",\n        value: function () {\n          if (this.location.length <= 1) return null;\n          var t = this.location[$.LEFT];\n          this.location[$.LEFT] = this.location[$.RIGHT], this.location[$.RIGHT] = t;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new st();\n          return this.location.length > 1 && t.append(H.toLocationSymbol(this.location[$.LEFT])), t.append(H.toLocationSymbol(this.location[$.ON])), this.location.length > 1 && t.append(H.toLocationSymbol(this.location[$.RIGHT])), t.toString();\n        }\n      }, {\n        key: \"setLocations\",\n        value: function (t, e, n) {\n          this.location[$.ON] = t, this.location[$.LEFT] = e, this.location[$.RIGHT] = n;\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          return t < this.location.length ? this.location[t] : H.NONE;\n        }\n      }, {\n        key: \"isArea\",\n        value: function () {\n          return this.location.length > 1;\n        }\n      }, {\n        key: \"isAnyNull\",\n        value: function () {\n          for (var t = 0; t < this.location.length; t++) if (this.location[t] === H.NONE) return !0;\n          return !1;\n        }\n      }, {\n        key: \"setLocation\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setLocation($.ON, t);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.location[e] = n;\n          }\n        }\n      }, {\n        key: \"init\",\n        value: function (t) {\n          this.location = new Array(t).fill(null), this.setAllLocations(H.NONE);\n        }\n      }, {\n        key: \"isEqualOnSide\",\n        value: function (t, e) {\n          return this.location[e] === t.location[e];\n        }\n      }, {\n        key: \"allPositionsEqual\",\n        value: function (t) {\n          for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;\n          return !0;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.location = null, 1 === arguments.length) {\n            if (arguments[0] instanceof Array) {\n              var e = arguments[0];\n              this.init(e.length);\n            } else if (Number.isInteger(arguments[0])) {\n              var n = arguments[0];\n              this.init(1), this.location[$.ON] = n;\n            } else if (arguments[0] instanceof t) {\n              var i = arguments[0];\n              if (this.init(i.location.length), null !== i) for (var r = 0; r < this.location.length; r++) this.location[r] = i.location[r];\n            }\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2];\n            this.init(3), this.location[$.ON] = s, this.location[$.LEFT] = a, this.location[$.RIGHT] = o;\n          }\n        }\n      }]);\n    }(),\n    Ae = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getGeometryCount\",\n        value: function () {\n          var t = 0;\n          return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;\n        }\n      }, {\n        key: \"setAllLocations\",\n        value: function (t, e) {\n          this.elt[t].setAllLocations(e);\n        }\n      }, {\n        key: \"isNull\",\n        value: function (t) {\n          return this.elt[t].isNull();\n        }\n      }, {\n        key: \"setAllLocationsIfNull\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.elt[e].setAllLocationsIfNull(n);\n          }\n        }\n      }, {\n        key: \"isLine\",\n        value: function (t) {\n          return this.elt[t].isLine();\n        }\n      }, {\n        key: \"merge\",\n        value: function (t) {\n          for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Me(t.elt[e]) : this.elt[e].merge(t.elt[e]);\n        }\n      }, {\n        key: \"flip\",\n        value: function () {\n          this.elt[0].flip(), this.elt[1].flip();\n        }\n      }, {\n        key: \"getLocation\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.elt[t].get($.ON);\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            return this.elt[e].get(n);\n          }\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new st();\n          return null !== this.elt[0] && (t.append(\"A:\"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(\" B:\"), t.append(this.elt[1].toString())), t.toString();\n        }\n      }, {\n        key: \"isArea\",\n        value: function () {\n          if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.elt[t].isArea();\n          }\n        }\n      }, {\n        key: \"isAnyNull\",\n        value: function (t) {\n          return this.elt[t].isAnyNull();\n        }\n      }, {\n        key: \"setLocation\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this.elt[t].setLocation($.ON, e);\n          } else if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2];\n            this.elt[n].setLocation(i, r);\n          }\n        }\n      }, {\n        key: \"isEqualOnSide\",\n        value: function (t, e) {\n          return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);\n        }\n      }, {\n        key: \"allPositionsEqual\",\n        value: function (t, e) {\n          return this.elt[t].allPositionsEqual(e);\n        }\n      }, {\n        key: \"toLine\",\n        value: function (t) {\n          this.elt[t].isArea() && (this.elt[t] = new Me(this.elt[t].location[0]));\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {\n            if (Number.isInteger(arguments[0])) {\n              var e = arguments[0];\n              this.elt[0] = new Me(e), this.elt[1] = new Me(e);\n            } else if (arguments[0] instanceof t) {\n              var n = arguments[0];\n              this.elt[0] = new Me(n.elt[0]), this.elt[1] = new Me(n.elt[1]);\n            }\n          } else if (2 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this.elt[0] = new Me(H.NONE), this.elt[1] = new Me(H.NONE), this.elt[i].setLocation(r);\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2];\n            this.elt[0] = new Me(s, a, o), this.elt[1] = new Me(s, a, o);\n          } else if (4 === arguments.length) {\n            var u = arguments[0],\n              l = arguments[1],\n              h = arguments[2],\n              c = arguments[3];\n            this.elt[0] = new Me(H.NONE, H.NONE, H.NONE), this.elt[1] = new Me(H.NONE, H.NONE, H.NONE), this.elt[u].setLocations(l, h, c);\n          }\n        }\n      }, {\n        key: \"toLineLabel\",\n        value: function (e) {\n          for (var n = new t(H.NONE), i = 0; i < 2; i++) n.setLocation(i, e.getLocation(i));\n          return n;\n        }\n      }]);\n    }(),\n    Pe = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"computeRing\",\n        value: function () {\n          if (null !== this._ring) return null;\n          for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);\n          this._ring = this._geometryFactory.createLinearRing(t), this._isHole = ct.isCCW(this._ring.getCoordinates());\n        }\n      }, {\n        key: \"isIsolated\",\n        value: function () {\n          return 1 === this._label.getGeometryCount();\n        }\n      }, {\n        key: \"computePoints\",\n        value: function (t) {\n          this._startDe = t;\n          var e = t,\n            n = !0;\n          do {\n            if (null === e) throw new gt(\"Found null DirectedEdge\");\n            if (e.getEdgeRing() === this) throw new gt(\"Directed Edge visited twice during ring-building at \" + e.getCoordinate());\n            this._edges.add(e);\n            var i = e.getLabel();\n            G.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e);\n          } while (e !== this._startDe);\n        }\n      }, {\n        key: \"getLinearRing\",\n        value: function () {\n          return this._ring;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {\n          return this._pts.get(t);\n        }\n      }, {\n        key: \"computeMaxNodeDegree\",\n        value: function () {\n          this._maxNodeDegree = 0;\n          var t = this._startDe;\n          do {\n            var e = t.getNode().getEdges().getOutgoingDegree(this);\n            e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t);\n          } while (t !== this._startDe);\n          this._maxNodeDegree *= 2;\n        }\n      }, {\n        key: \"addPoints\",\n        value: function (t, e, n) {\n          var i = t.getCoordinates();\n          if (e) {\n            var r = 1;\n            n && (r = 0);\n            for (var s = r; s < i.length; s++) this._pts.add(i[s]);\n          } else {\n            var a = i.length - 2;\n            n && (a = i.length - 1);\n            for (var o = a; o >= 0; o--) this._pts.add(i[o]);\n          }\n        }\n      }, {\n        key: \"isHole\",\n        value: function () {\n          return this._isHole;\n        }\n      }, {\n        key: \"setInResult\",\n        value: function () {\n          var t = this._startDe;\n          do {\n            t.getEdge().setInResult(!0), t = t.getNext();\n          } while (t !== this._startDe);\n        }\n      }, {\n        key: \"containsPoint\",\n        value: function (t) {\n          var e = this.getLinearRing();\n          if (!e.getEnvelopeInternal().contains(t)) return !1;\n          if (!be.isInRing(t, e.getCoordinates())) return !1;\n          for (var n = this._holes.iterator(); n.hasNext();) {\n            if (n.next().containsPoint(t)) return !1;\n          }\n          return !0;\n        }\n      }, {\n        key: \"addHole\",\n        value: function (t) {\n          this._holes.add(t);\n        }\n      }, {\n        key: \"isShell\",\n        value: function () {\n          return null === this._shell;\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return this._edges;\n        }\n      }, {\n        key: \"getMaxNodeDegree\",\n        value: function () {\n          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;\n        }\n      }, {\n        key: \"getShell\",\n        value: function () {\n          return this._shell;\n        }\n      }, {\n        key: \"mergeLabel\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.mergeLabel(t, 0), this.mergeLabel(t, 1);\n          } else if (2 === arguments.length) {\n            var e = arguments[1],\n              n = arguments[0].getLocation(e, $.RIGHT);\n            if (n === H.NONE) return null;\n            if (this._label.getLocation(e) === H.NONE) return this._label.setLocation(e, n), null;\n          }\n        }\n      }, {\n        key: \"setShell\",\n        value: function (t) {\n          this._shell = t, null !== t && t.addHole(this);\n        }\n      }, {\n        key: \"toPolygon\",\n        value: function (t) {\n          for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();\n          return t.createPolygon(this.getLinearRing(), e);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new yt(), this._pts = new yt(), this._label = new Ae(H.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new yt(), this._geometryFactory = null, 0 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this._geometryFactory = e, this.computePoints(t), this.computeRing();\n          }\n        }\n      }]);\n    }(),\n    De = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"setEdgeRing\",\n        value: function (t, e) {\n          t.setMinEdgeRing(e);\n        }\n      }, {\n        key: \"getNext\",\n        value: function (t) {\n          return t.getNextMin();\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Pe.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Pe),\n    Fe = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"buildMinimalRings\",\n        value: function () {\n          var t = new yt(),\n            e = this._startDe;\n          do {\n            if (null === e.getMinEdgeRing()) {\n              var n = new De(e, this._geometryFactory);\n              t.add(n);\n            }\n            e = e.getNext();\n          } while (e !== this._startDe);\n          return t;\n        }\n      }, {\n        key: \"setEdgeRing\",\n        value: function (t, e) {\n          t.setEdgeRing(e);\n        }\n      }, {\n        key: \"linkDirectedEdgesForMinimalEdgeRings\",\n        value: function () {\n          var t = this._startDe;\n          do {\n            t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext();\n          } while (t !== this._startDe);\n        }\n      }, {\n        key: \"getNext\",\n        value: function (t) {\n          return t.getNext();\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0],\n            e = arguments[1];\n          Pe.constructor_.call(this, t, e);\n        }\n      }]);\n    }(Pe),\n    Ge = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"setVisited\",\n        value: function (t) {\n          this._isVisited = t;\n        }\n      }, {\n        key: \"setInResult\",\n        value: function (t) {\n          this._isInResult = t;\n        }\n      }, {\n        key: \"isCovered\",\n        value: function () {\n          return this._isCovered;\n        }\n      }, {\n        key: \"isCoveredSet\",\n        value: function () {\n          return this._isCoveredSet;\n        }\n      }, {\n        key: \"setLabel\",\n        value: function (t) {\n          this._label = t;\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"setCovered\",\n        value: function (t) {\n          this._isCovered = t, this._isCoveredSet = !0;\n        }\n      }, {\n        key: \"updateIM\",\n        value: function (t) {\n          G.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\"), this.computeIM(t);\n        }\n      }, {\n        key: \"isInResult\",\n        value: function () {\n          return this._isInResult;\n        }\n      }, {\n        key: \"isVisited\",\n        value: function () {\n          return this._isVisited;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this._label = t;\n          }\n        }\n      }]);\n    }(),\n    qe = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"isIncidentEdgeInResult\",\n        value: function () {\n          for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {\n            if (t.next().getEdge().isInResult()) return !0;\n          }\n          return !1;\n        }\n      }, {\n        key: \"isIsolated\",\n        value: function () {\n          return 1 === this._label.getGeometryCount();\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this._coord;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.println(\"node \" + this._coord + \" lbl: \" + this._label);\n        }\n      }, {\n        key: \"computeIM\",\n        value: function (t) {}\n      }, {\n        key: \"computeMergedLocation\",\n        value: function (t, e) {\n          var n = H.NONE;\n          if (n = this._label.getLocation(e), !t.isNull(e)) {\n            var i = t.getLocation(e);\n            n !== H.BOUNDARY && (n = i);\n          }\n          return n;\n        }\n      }, {\n        key: \"setLabel\",\n        value: function () {\n          if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return f(i, \"setLabel\", this, 1).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1];\n          null === this._label ? this._label = new Ae(t, e) : this._label.setLocation(t, e);\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return this._edges;\n        }\n      }, {\n        key: \"mergeLabel\",\n        value: function () {\n          if (arguments[0] instanceof i) {\n            var t = arguments[0];\n            this.mergeLabel(t._label);\n          } else if (arguments[0] instanceof Ae) for (var e = arguments[0], n = 0; n < 2; n++) {\n            var r = this.computeMergedLocation(e, n);\n            this._label.getLocation(n) === H.NONE && this._label.setLocation(n, r);\n          }\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._edges.insert(t), t.setNode(this);\n        }\n      }, {\n        key: \"setLabelBoundary\",\n        value: function (t) {\n          if (null === this._label) return null;\n          var e = H.NONE;\n          null !== this._label && (e = this._label.getLocation(t));\n          var n = null;\n          switch (e) {\n            case H.BOUNDARY:\n              n = H.INTERIOR;\n              break;\n            case H.INTERIOR:\n            default:\n              n = H.BOUNDARY;\n          }\n          this._label.setLocation(t, n);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._coord = null, this._edges = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._coord = t, this._edges = e, this._label = new Ae(0, H.NONE);\n        }\n      }]);\n    }(Ge),\n    Ye = function (t) {\n      function i() {\n        return n(this, i), e(this, i, arguments);\n      }\n      return l(i, t), s(i);\n    }(ee);\n  function ze(t) {\n    return null == t ? 0 : t.color;\n  }\n  function Xe(t) {\n    return null == t ? null : t.parent;\n  }\n  function Be(t, e) {\n    null !== t && (t.color = e);\n  }\n  function Ue(t) {\n    return null == t ? null : t.left;\n  }\n  function Ve(t) {\n    return null == t ? null : t.right;\n  }\n  var He = function (t) {\n      function i() {\n        var t;\n        return n(this, i), (t = e(this, i)).root_ = null, t.size_ = 0, t;\n      }\n      return l(i, t), s(i, [{\n        key: \"get\",\n        value: function (t) {\n          for (var e = this.root_; null !== e;) {\n            var n = t.compareTo(e.key);\n            if (n < 0) e = e.left;else {\n              if (!(n > 0)) return e.value;\n              e = e.right;\n            }\n          }\n          return null;\n        }\n      }, {\n        key: \"put\",\n        value: function (t, e) {\n          if (null === this.root_) return this.root_ = {\n            key: t,\n            value: e,\n            left: null,\n            right: null,\n            parent: null,\n            color: 0,\n            getValue: function () {\n              return this.value;\n            },\n            getKey: function () {\n              return this.key;\n            }\n          }, this.size_ = 1, null;\n          var n,\n            i,\n            r = this.root_;\n          do {\n            if (n = r, (i = t.compareTo(r.key)) < 0) r = r.left;else {\n              if (!(i > 0)) {\n                var s = r.value;\n                return r.value = e, s;\n              }\n              r = r.right;\n            }\n          } while (null !== r);\n          var a = {\n            key: t,\n            left: null,\n            right: null,\n            value: e,\n            parent: n,\n            color: 0,\n            getValue: function () {\n              return this.value;\n            },\n            getKey: function () {\n              return this.key;\n            }\n          };\n          return i < 0 ? n.left = a : n.right = a, this.fixAfterInsertion(a), this.size_++, null;\n        }\n      }, {\n        key: \"fixAfterInsertion\",\n        value: function (t) {\n          var e;\n          for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;) Xe(t) === Ue(Xe(Xe(t))) ? 1 === ze(e = Ve(Xe(Xe(t)))) ? (Be(Xe(t), 0), Be(e, 0), Be(Xe(Xe(t)), 1), t = Xe(Xe(t))) : (t === Ve(Xe(t)) && (t = Xe(t), this.rotateLeft(t)), Be(Xe(t), 0), Be(Xe(Xe(t)), 1), this.rotateRight(Xe(Xe(t)))) : 1 === ze(e = Ue(Xe(Xe(t)))) ? (Be(Xe(t), 0), Be(e, 0), Be(Xe(Xe(t)), 1), t = Xe(Xe(t))) : (t === Ue(Xe(t)) && (t = Xe(t), this.rotateRight(t)), Be(Xe(t), 0), Be(Xe(Xe(t)), 1), this.rotateLeft(Xe(Xe(t))));\n          this.root_.color = 0;\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          var t = new yt(),\n            e = this.getFirstEntry();\n          if (null !== e) for (t.add(e.value); null !== (e = i.successor(e));) t.add(e.value);\n          return t;\n        }\n      }, {\n        key: \"entrySet\",\n        value: function () {\n          var t = new J(),\n            e = this.getFirstEntry();\n          if (null !== e) for (t.add(e); null !== (e = i.successor(e));) t.add(e);\n          return t;\n        }\n      }, {\n        key: \"rotateLeft\",\n        value: function (t) {\n          if (null != t) {\n            var e = t.right;\n            t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;\n          }\n        }\n      }, {\n        key: \"rotateRight\",\n        value: function (t) {\n          if (null != t) {\n            var e = t.left;\n            t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;\n          }\n        }\n      }, {\n        key: \"getFirstEntry\",\n        value: function () {\n          var t = this.root_;\n          if (null != t) for (; null != t.left;) t = t.left;\n          return t;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this.size_;\n        }\n      }, {\n        key: \"containsKey\",\n        value: function (t) {\n          for (var e = this.root_; null !== e;) {\n            var n = t.compareTo(e.key);\n            if (n < 0) e = e.left;else {\n              if (!(n > 0)) return !0;\n              e = e.right;\n            }\n          }\n          return !1;\n        }\n      }], [{\n        key: \"successor\",\n        value: function (t) {\n          var e;\n          if (null === t) return null;\n          if (null !== t.right) {\n            for (e = t.right; null !== e.left;) e = e.left;\n            return e;\n          }\n          e = t.parent;\n          for (var n = t; null !== e && n === e.right;) n = e, e = e.parent;\n          return e;\n        }\n      }]);\n    }(Ye),\n    Ze = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"find\",\n        value: function (t) {\n          return this.nodeMap.get(t);\n        }\n      }, {\n        key: \"addNode\",\n        value: function () {\n          if (arguments[0] instanceof X) {\n            var t = arguments[0],\n              e = this.nodeMap.get(t);\n            return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;\n          }\n          if (arguments[0] instanceof qe) {\n            var n = arguments[0],\n              i = this.nodeMap.get(n.getCoordinate());\n            return null === i ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i);\n          }\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this.nodeMap.values().iterator();\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          return this.nodeMap.values();\n        }\n      }, {\n        key: \"getBoundaryNodes\",\n        value: function (t) {\n          for (var e = new yt(), n = this.iterator(); n.hasNext();) {\n            var i = n.next();\n            i.getLabel().getLocation(t) === H.BOUNDARY && e.add(i);\n          }\n          return e;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          var e = t.getCoordinate();\n          this.addNode(e).add(t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.nodeMap = new He(), this.nodeFact = null;\n          var t = arguments[0];\n          this.nodeFact = t;\n        }\n      }]);\n    }(),\n    je = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"isNorthern\",\n        value: function (e) {\n          return e === t.NE || e === t.NW;\n        }\n      }, {\n        key: \"isOpposite\",\n        value: function (t, e) {\n          return t !== e && 2 === (t - e + 4) % 4;\n        }\n      }, {\n        key: \"commonHalfPlane\",\n        value: function (t, e) {\n          if (t === e) return t;\n          if (2 === (t - e + 4) % 4) return -1;\n          var n = t < e ? t : e;\n          return 0 === n && 3 === (t > e ? t : e) ? 3 : n;\n        }\n      }, {\n        key: \"isInHalfPlane\",\n        value: function (e, n) {\n          return n === t.SE ? e === t.SE || e === t.SW : e === n || e === n + 1;\n        }\n      }, {\n        key: \"quadrant\",\n        value: function () {\n          if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (0 === e && 0 === n) throw new m(\"Cannot compute the quadrant for point ( \" + e + \", \" + n + \" )\");\n            return e >= 0 ? n >= 0 ? t.NE : t.SE : n >= 0 ? t.NW : t.SW;\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof X) {\n            var i = arguments[0],\n              r = arguments[1];\n            if (r.x === i.x && r.y === i.y) throw new m(\"Cannot compute the quadrant for two identical points \" + i);\n            return r.x >= i.x ? r.y >= i.y ? t.NE : t.SE : r.y >= i.y ? t.NW : t.SW;\n          }\n        }\n      }]);\n    }();\n  je.NE = 0, je.NW = 1, je.SW = 2, je.SE = 3;\n  var We = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"compareDirection\",\n        value: function (t) {\n          return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : ct.index(t._p0, t._p1, this._p1);\n        }\n      }, {\n        key: \"getDy\",\n        value: function () {\n          return this._dy;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this._p0;\n        }\n      }, {\n        key: \"setNode\",\n        value: function (t) {\n          this._node = t;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          var e = Math.atan2(this._dy, this._dx),\n            n = this.getClass().getName(),\n            i = n.lastIndexOf(\".\"),\n            r = n.substring(i + 1);\n          t.print(\"  \" + r + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + e + \"   \" + this._label);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.compareDirection(e);\n        }\n      }, {\n        key: \"getDirectedCoordinate\",\n        value: function () {\n          return this._p1;\n        }\n      }, {\n        key: \"getDx\",\n        value: function () {\n          return this._dx;\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._edge;\n        }\n      }, {\n        key: \"getQuadrant\",\n        value: function () {\n          return this._quadrant;\n        }\n      }, {\n        key: \"getNode\",\n        value: function () {\n          return this._node;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = Math.atan2(this._dy, this._dx),\n            e = this.getClass().getName(),\n            n = e.lastIndexOf(\".\");\n          return \"  \" + e.substring(n + 1) + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + t + \"   \" + this._label;\n        }\n      }, {\n        key: \"computeLabel\",\n        value: function (t) {}\n      }, {\n        key: \"init\",\n        value: function (t, e) {\n          this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = je.quadrant(this._dx, this._dy), G.isTrue(!(0 === this._dx && 0 === this._dy), \"EdgeEnd with identical endpoints found\");\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {\n            var e = arguments[0];\n            this._edge = e;\n          } else if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2];\n            t.constructor_.call(this, n, i, r, null);\n          } else if (4 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = arguments[2],\n              u = arguments[3];\n            t.constructor_.call(this, s), this.init(a, o), this._label = u;\n          }\n        }\n      }]);\n    }(),\n    Ke = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getNextMin\",\n        value: function () {\n          return this._nextMin;\n        }\n      }, {\n        key: \"getDepth\",\n        value: function (t) {\n          return this._depth[t];\n        }\n      }, {\n        key: \"setVisited\",\n        value: function (t) {\n          this._isVisited = t;\n        }\n      }, {\n        key: \"computeDirectedLabel\",\n        value: function () {\n          this._label = new Ae(this._edge.getLabel()), this._isForward || this._label.flip();\n        }\n      }, {\n        key: \"getNext\",\n        value: function () {\n          return this._next;\n        }\n      }, {\n        key: \"setDepth\",\n        value: function (t, e) {\n          if (-999 !== this._depth[t] && this._depth[t] !== e) throw new gt(\"assigned depths do not match\", this.getCoordinate());\n          this._depth[t] = e;\n        }\n      }, {\n        key: \"isInteriorAreaEdge\",\n        value: function () {\n          for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, $.LEFT) === H.INTERIOR && this._label.getLocation(e, $.RIGHT) === H.INTERIOR || (t = !1);\n          return t;\n        }\n      }, {\n        key: \"setNextMin\",\n        value: function (t) {\n          this._nextMin = t;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          f(i, \"print\", this, 1).call(this, t), t.print(\" \" + this._depth[$.LEFT] + \"/\" + this._depth[$.RIGHT]), t.print(\" (\" + this.getDepthDelta() + \")\"), this._isInResult && t.print(\" inResult\");\n        }\n      }, {\n        key: \"setMinEdgeRing\",\n        value: function (t) {\n          this._minEdgeRing = t;\n        }\n      }, {\n        key: \"isLineEdge\",\n        value: function () {\n          var t = this._label.isLine(0) || this._label.isLine(1),\n            e = !this._label.isArea(0) || this._label.allPositionsEqual(0, H.EXTERIOR),\n            n = !this._label.isArea(1) || this._label.allPositionsEqual(1, H.EXTERIOR);\n          return t && e && n;\n        }\n      }, {\n        key: \"setEdgeRing\",\n        value: function (t) {\n          this._edgeRing = t;\n        }\n      }, {\n        key: \"getMinEdgeRing\",\n        value: function () {\n          return this._minEdgeRing;\n        }\n      }, {\n        key: \"getDepthDelta\",\n        value: function () {\n          var t = this._edge.getDepthDelta();\n          return this._isForward || (t = -t), t;\n        }\n      }, {\n        key: \"setInResult\",\n        value: function (t) {\n          this._isInResult = t;\n        }\n      }, {\n        key: \"getSym\",\n        value: function () {\n          return this._sym;\n        }\n      }, {\n        key: \"isForward\",\n        value: function () {\n          return this._isForward;\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._edge;\n        }\n      }, {\n        key: \"printEdge\",\n        value: function (t) {\n          this.print(t), t.print(\" \"), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);\n        }\n      }, {\n        key: \"setSym\",\n        value: function (t) {\n          this._sym = t;\n        }\n      }, {\n        key: \"setVisitedEdge\",\n        value: function (t) {\n          this.setVisited(t), this._sym.setVisited(t);\n        }\n      }, {\n        key: \"setEdgeDepths\",\n        value: function (t, e) {\n          var n = this.getEdge().getDepthDelta();\n          this._isForward || (n = -n);\n          var i = 1;\n          t === $.LEFT && (i = -1);\n          var r = $.opposite(t),\n            s = e + n * i;\n          this.setDepth(t, e), this.setDepth(r, s);\n        }\n      }, {\n        key: \"getEdgeRing\",\n        value: function () {\n          return this._edgeRing;\n        }\n      }, {\n        key: \"isInResult\",\n        value: function () {\n          return this._isInResult;\n        }\n      }, {\n        key: \"setNext\",\n        value: function (t) {\n          this._next = t;\n        }\n      }, {\n        key: \"isVisited\",\n        value: function () {\n          return this._isVisited;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];\n          var t = arguments[0],\n            e = arguments[1];\n          if (We.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));else {\n            var n = t.getNumPoints() - 1;\n            this.init(t.getCoordinate(n), t.getCoordinate(n - 1));\n          }\n          this.computeDirectedLabel();\n        }\n      }, {\n        key: \"depthFactor\",\n        value: function (t, e) {\n          return t === H.EXTERIOR && e === H.INTERIOR ? 1 : t === H.INTERIOR && e === H.EXTERIOR ? -1 : 0;\n        }\n      }]);\n    }(We),\n    Je = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"createNode\",\n        value: function (t) {\n          return new qe(t, null);\n        }\n      }]);\n    }(),\n    Qe = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"printEdges\",\n        value: function (t) {\n          t.println(\"Edges:\");\n          for (var e = 0; e < this._edges.size(); e++) {\n            t.println(\"edge \" + e + \":\");\n            var n = this._edges.get(e);\n            n.print(t), n.eiList.print(t);\n          }\n        }\n      }, {\n        key: \"find\",\n        value: function (t) {\n          return this._nodes.find(t);\n        }\n      }, {\n        key: \"addNode\",\n        value: function () {\n          if (arguments[0] instanceof qe) {\n            var t = arguments[0];\n            return this._nodes.addNode(t);\n          }\n          if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            return this._nodes.addNode(e);\n          }\n        }\n      }, {\n        key: \"getNodeIterator\",\n        value: function () {\n          return this._nodes.iterator();\n        }\n      }, {\n        key: \"linkResultDirectedEdges\",\n        value: function () {\n          for (var t = this._nodes.iterator(); t.hasNext();) {\n            t.next().getEdges().linkResultDirectedEdges();\n          }\n        }\n      }, {\n        key: \"debugPrintln\",\n        value: function (t) {\n          mt.out.println(t);\n        }\n      }, {\n        key: \"isBoundaryNode\",\n        value: function (t, e) {\n          var n = this._nodes.find(e);\n          if (null === n) return !1;\n          var i = n.getLabel();\n          return null !== i && i.getLocation(t) === H.BOUNDARY;\n        }\n      }, {\n        key: \"linkAllDirectedEdges\",\n        value: function () {\n          for (var t = this._nodes.iterator(); t.hasNext();) {\n            t.next().getEdges().linkAllDirectedEdges();\n          }\n        }\n      }, {\n        key: \"matchInSameDirection\",\n        value: function (t, e, n, i) {\n          return !!t.equals(n) && ct.index(t, e, i) === ct.COLLINEAR && je.quadrant(t, e) === je.quadrant(n, i);\n        }\n      }, {\n        key: \"getEdgeEnds\",\n        value: function () {\n          return this._edgeEndList;\n        }\n      }, {\n        key: \"debugPrint\",\n        value: function (t) {\n          mt.out.print(t);\n        }\n      }, {\n        key: \"getEdgeIterator\",\n        value: function () {\n          return this._edges.iterator();\n        }\n      }, {\n        key: \"findEdgeInSameDirection\",\n        value: function (t, e) {\n          for (var n = 0; n < this._edges.size(); n++) {\n            var i = this._edges.get(n),\n              r = i.getCoordinates();\n            if (this.matchInSameDirection(t, e, r[0], r[1])) return i;\n            if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2])) return i;\n          }\n          return null;\n        }\n      }, {\n        key: \"insertEdge\",\n        value: function (t) {\n          this._edges.add(t);\n        }\n      }, {\n        key: \"findEdgeEnd\",\n        value: function (t) {\n          for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {\n            var n = e.next();\n            if (n.getEdge() === t) return n;\n          }\n          return null;\n        }\n      }, {\n        key: \"addEdges\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next();\n            this._edges.add(n);\n            var i = new Ke(n, !0),\n              r = new Ke(n, !1);\n            i.setSym(r), r.setSym(i), this.add(i), this.add(r);\n          }\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._nodes.add(t), this._edgeEndList.add(t);\n        }\n      }, {\n        key: \"getNodes\",\n        value: function () {\n          return this._nodes.values();\n        }\n      }, {\n        key: \"findEdge\",\n        value: function (t, e) {\n          for (var n = 0; n < this._edges.size(); n++) {\n            var i = this._edges.get(n),\n              r = i.getCoordinates();\n            if (t.equals(r[0]) && e.equals(r[1])) return i;\n          }\n          return null;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._edges = new yt(), this._nodes = null, this._edgeEndList = new yt(), 0 === arguments.length) this._nodes = new Ze(new Je());else if (1 === arguments.length) {\n            var t = arguments[0];\n            this._nodes = new Ze(t);\n          }\n        }\n      }, {\n        key: \"linkResultDirectedEdges\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            e.next().getEdges().linkResultDirectedEdges();\n          }\n        }\n      }]);\n    }(),\n    $e = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"sortShellsAndHoles\",\n        value: function (t, e, n) {\n          for (var i = t.iterator(); i.hasNext();) {\n            var r = i.next();\n            r.isHole() ? n.add(r) : e.add(r);\n          }\n        }\n      }, {\n        key: \"computePolygons\",\n        value: function (t) {\n          for (var e = new yt(), n = t.iterator(); n.hasNext();) {\n            var i = n.next().toPolygon(this._geometryFactory);\n            e.add(i);\n          }\n          return e;\n        }\n      }, {\n        key: \"placeFreeHoles\",\n        value: function (e, n) {\n          for (var i = n.iterator(); i.hasNext();) {\n            var r = i.next();\n            if (null === r.getShell()) {\n              var s = t.findEdgeRingContaining(r, e);\n              if (null === s) throw new gt(\"unable to assign hole to a shell\", r.getCoordinate(0));\n              r.setShell(s);\n            }\n          }\n        }\n      }, {\n        key: \"buildMinimalEdgeRings\",\n        value: function (t, e, n) {\n          for (var i = new yt(), r = t.iterator(); r.hasNext();) {\n            var s = r.next();\n            if (s.getMaxNodeDegree() > 2) {\n              s.linkDirectedEdgesForMinimalEdgeRings();\n              var a = s.buildMinimalRings(),\n                o = this.findShell(a);\n              null !== o ? (this.placePolygonHoles(o, a), e.add(o)) : n.addAll(a);\n            } else i.add(s);\n          }\n          return i;\n        }\n      }, {\n        key: \"buildMaximalEdgeRings\",\n        value: function (t) {\n          for (var e = new yt(), n = t.iterator(); n.hasNext();) {\n            var i = n.next();\n            if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {\n              var r = new Fe(i, this._geometryFactory);\n              e.add(r), r.setInResult();\n            }\n          }\n          return e;\n        }\n      }, {\n        key: \"placePolygonHoles\",\n        value: function (t, e) {\n          for (var n = e.iterator(); n.hasNext();) {\n            var i = n.next();\n            i.isHole() && i.setShell(t);\n          }\n        }\n      }, {\n        key: \"getPolygons\",\n        value: function () {\n          return this.computePolygons(this._shellList);\n        }\n      }, {\n        key: \"findShell\",\n        value: function (t) {\n          for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {\n            var r = i.next();\n            r.isHole() || (n = r, e++);\n          }\n          return G.isTrue(e <= 1, \"found two shells in MinimalEdgeRing list\"), n;\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.add(t.getEdgeEnds(), t.getNodes());\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            Qe.linkResultDirectedEdges(n);\n            var i = this.buildMaximalEdgeRings(e),\n              r = new yt(),\n              s = this.buildMinimalEdgeRings(i, this._shellList, r);\n            this.sortShellsAndHoles(s, this._shellList, r), this.placeFreeHoles(this._shellList, r);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._geometryFactory = null, this._shellList = new yt();\n          var t = arguments[0];\n          this._geometryFactory = t;\n        }\n      }, {\n        key: \"findEdgeRingContaining\",\n        value: function (t, e) {\n          for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), s = null, a = null, o = e.iterator(); o.hasNext();) {\n            var u = o.next(),\n              l = u.getLinearRing(),\n              h = l.getEnvelopeInternal();\n            if (!h.equals(i) && h.contains(i)) {\n              r = jt.ptNotInList(n.getCoordinates(), l.getCoordinates());\n              var c = !1;\n              be.isInRing(r, l.getCoordinates()) && (c = !0), c && (null === s || a.contains(h)) && (a = (s = u).getLinearRing().getEnvelopeInternal());\n            }\n          }\n          return s;\n        }\n      }]);\n    }(),\n    tn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"getBounds\",\n        value: function () {}\n      }]);\n    }(),\n    en = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getItem\",\n        value: function () {\n          return this._item;\n        }\n      }, {\n        key: \"getBounds\",\n        value: function () {\n          return this._bounds;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [tn, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._bounds = null, this._item = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._bounds = t, this._item = e;\n        }\n      }]);\n    }(),\n    nn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"poll\",\n        value: function () {\n          if (this.isEmpty()) return null;\n          var t = this._items.get(1);\n          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._size;\n        }\n      }, {\n        key: \"reorder\",\n        value: function (t) {\n          for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));\n          this._items.set(t, n);\n        }\n      }, {\n        key: \"clear\",\n        value: function () {\n          this._size = 0, this._items.clear();\n        }\n      }, {\n        key: \"peek\",\n        value: function () {\n          return this.isEmpty() ? null : this._items.get(1);\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return 0 === this._size;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._items.add(null), this._size += 1;\n          var e = this._size;\n          for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));\n          this._items.set(e, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._size = null, this._items = null, this._size = 0, this._items = new yt(), this._items.add(null);\n        }\n      }]);\n    }(),\n    rn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"insert\",\n        value: function (t, e) {}\n      }, {\n        key: \"remove\",\n        value: function (t, e) {}\n      }, {\n        key: \"query\",\n        value: function () {}\n      }]);\n    }(),\n    sn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getLevel\",\n        value: function () {\n          return this._level;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._childBoundables.size();\n        }\n      }, {\n        key: \"getChildBoundables\",\n        value: function () {\n          return this._childBoundables;\n        }\n      }, {\n        key: \"addChildBoundable\",\n        value: function (t) {\n          G.isTrue(null === this._bounds), this._childBoundables.add(t);\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this._childBoundables.isEmpty();\n        }\n      }, {\n        key: \"getBounds\",\n        value: function () {\n          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [tn, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._childBoundables = new yt(), this._bounds = null, this._level = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this._level = t;\n          }\n        }\n      }]);\n    }(),\n    an = {\n      reverseOrder: function () {\n        return {\n          compare: function (t, e) {\n            return e.compareTo(t);\n          }\n        };\n      },\n      min: function (t) {\n        return an.sort(t), t.get(0);\n      },\n      sort: function (t, e) {\n        var n = t.toArray();\n        e ? At.sort(n, e) : At.sort(n);\n        for (var i = t.iterator(), r = 0, s = n.length; r < s; r++) i.next(), i.set(n[r]);\n      },\n      singletonList: function (t) {\n        var e = new yt();\n        return e.add(t), e;\n      }\n    },\n    on = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"maxDistance\",\n        value: function (e, n, i, r, s, a, o, u) {\n          var l = t.distance(e, n, s, a);\n          return l = Math.max(l, t.distance(e, n, o, u)), l = Math.max(l, t.distance(i, r, s, a)), l = Math.max(l, t.distance(i, r, o, u));\n        }\n      }, {\n        key: \"distance\",\n        value: function (t, e, n, i) {\n          var r = n - t,\n            s = i - e;\n          return Math.sqrt(r * r + s * s);\n        }\n      }, {\n        key: \"maximumDistance\",\n        value: function (e, n) {\n          var i = Math.min(e.getMinX(), n.getMinX()),\n            r = Math.min(e.getMinY(), n.getMinY()),\n            s = Math.max(e.getMaxX(), n.getMaxX()),\n            a = Math.max(e.getMaxY(), n.getMaxY());\n          return t.distance(i, r, s, a);\n        }\n      }, {\n        key: \"minMaxDistance\",\n        value: function (e, n) {\n          var i = e.getMinX(),\n            r = e.getMinY(),\n            s = e.getMaxX(),\n            a = e.getMaxY(),\n            o = n.getMinX(),\n            u = n.getMinY(),\n            l = n.getMaxX(),\n            h = n.getMaxY(),\n            c = t.maxDistance(i, r, i, a, o, u, o, h);\n          return c = Math.min(c, t.maxDistance(i, r, i, a, o, u, l, u)), c = Math.min(c, t.maxDistance(i, r, i, a, l, h, o, h)), c = Math.min(c, t.maxDistance(i, r, i, a, l, h, l, u)), c = Math.min(c, t.maxDistance(i, r, s, r, o, u, o, h)), c = Math.min(c, t.maxDistance(i, r, s, r, o, u, l, u)), c = Math.min(c, t.maxDistance(i, r, s, r, l, h, o, h)), c = Math.min(c, t.maxDistance(i, r, s, r, l, h, l, u)), c = Math.min(c, t.maxDistance(s, a, i, a, o, u, o, h)), c = Math.min(c, t.maxDistance(s, a, i, a, o, u, l, u)), c = Math.min(c, t.maxDistance(s, a, i, a, l, h, o, h)), c = Math.min(c, t.maxDistance(s, a, i, a, l, h, l, u)), c = Math.min(c, t.maxDistance(s, a, s, r, o, u, o, h)), c = Math.min(c, t.maxDistance(s, a, s, r, o, u, l, u)), c = Math.min(c, t.maxDistance(s, a, s, r, l, h, o, h)), c = Math.min(c, t.maxDistance(s, a, s, r, l, h, l, u));\n        }\n      }]);\n    }(),\n    un = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"maximumDistance\",\n        value: function () {\n          return on.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());\n        }\n      }, {\n        key: \"expandToQueue\",\n        value: function (e, n) {\n          var i = t.isComposite(this._boundable1),\n            r = t.isComposite(this._boundable2);\n          if (i && r) return t.area(this._boundable1) > t.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, e, n), null) : (this.expand(this._boundable2, this._boundable1, !0, e, n), null);\n          if (i) return this.expand(this._boundable1, this._boundable2, !1, e, n), null;\n          if (r) return this.expand(this._boundable2, this._boundable1, !0, e, n), null;\n          throw new m(\"neither boundable is composite\");\n        }\n      }, {\n        key: \"isLeaves\",\n        value: function () {\n          return !(t.isComposite(this._boundable1) || t.isComposite(this._boundable2));\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;\n        }\n      }, {\n        key: \"expand\",\n        value: function (e, n, i, r, s) {\n          for (var a = e.getChildBoundables().iterator(); a.hasNext();) {\n            var o = a.next(),\n              u = null;\n            (u = i ? new t(n, o, this._itemDistance) : new t(o, n, this._itemDistance)).getDistance() < s && r.add(u);\n          }\n        }\n      }, {\n        key: \"getBoundable\",\n        value: function (t) {\n          return 0 === t ? this._boundable1 : this._boundable2;\n        }\n      }, {\n        key: \"getDistance\",\n        value: function () {\n          return this._distance;\n        }\n      }, {\n        key: \"distance\",\n        value: function () {\n          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();\n        }\n      }, {\n        key: \"area\",\n        value: function (t) {\n          return t.getBounds().getArea();\n        }\n      }, {\n        key: \"isComposite\",\n        value: function (t) {\n          return t instanceof sn;\n        }\n      }]);\n    }(),\n    ln = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"visitItem\",\n        value: function (t) {}\n      }]);\n    }(),\n    hn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"queryInternal\",\n        value: function () {\n          if (rt(arguments[2], ln) && arguments[0] instanceof Object && arguments[1] instanceof sn) for (var t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(), i = 0; i < n.size(); i++) {\n            var r = n.get(i);\n            this.getIntersectsOp().intersects(r.getBounds(), t) && (r instanceof sn ? this.queryInternal(t, r, e) : r instanceof en ? e.visitItem(r.getItem()) : G.shouldNeverReachHere());\n          } else if (rt(arguments[2], nt) && arguments[0] instanceof Object && arguments[1] instanceof sn) for (var s = arguments[0], a = arguments[2], o = arguments[1].getChildBoundables(), u = 0; u < o.size(); u++) {\n            var l = o.get(u);\n            this.getIntersectsOp().intersects(l.getBounds(), s) && (l instanceof sn ? this.queryInternal(s, l, a) : l instanceof en ? a.add(l.getItem()) : G.shouldNeverReachHere());\n          }\n        }\n      }, {\n        key: \"getNodeCapacity\",\n        value: function () {\n          return this._nodeCapacity;\n        }\n      }, {\n        key: \"lastNode\",\n        value: function (t) {\n          return t.get(t.size() - 1);\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));\n          if (1 === arguments.length) {\n            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {\n              var n = e.next();\n              n instanceof sn ? t += this.size(n) : n instanceof en && (t += 1);\n            }\n            return t;\n          }\n        }\n      }, {\n        key: \"removeItem\",\n        value: function (t, e) {\n          for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {\n            var r = i.next();\n            r instanceof en && r.getItem() === e && (n = r);\n          }\n          return null !== n && (t.getChildBoundables().remove(n), !0);\n        }\n      }, {\n        key: \"itemsTree\",\n        value: function () {\n          if (0 === arguments.length) {\n            this.build();\n            var t = this.itemsTree(this._root);\n            return null === t ? new yt() : t;\n          }\n          if (1 === arguments.length) {\n            for (var e = arguments[0], n = new yt(), i = e.getChildBoundables().iterator(); i.hasNext();) {\n              var r = i.next();\n              if (r instanceof sn) {\n                var s = this.itemsTree(r);\n                null !== s && n.add(s);\n              } else r instanceof en ? n.add(r.getItem()) : G.shouldNeverReachHere();\n            }\n            return n.size() <= 0 ? null : n;\n          }\n        }\n      }, {\n        key: \"insert\",\n        value: function (t, e) {\n          G.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\"), this._itemBoundables.add(new en(t, e));\n        }\n      }, {\n        key: \"boundablesAtLevel\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = new yt();\n            return this.boundablesAtLevel(t, this._root, e), e;\n          }\n          if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2];\n            if (G.isTrue(n > -2), i.getLevel() === n) return r.add(i), null;\n            for (var s = i.getChildBoundables().iterator(); s.hasNext();) {\n              var a = s.next();\n              a instanceof sn ? this.boundablesAtLevel(n, a, r) : (G.isTrue(a instanceof en), -1 === n && r.add(a));\n            }\n            return null;\n          }\n        }\n      }, {\n        key: \"query\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.build();\n            var e = new yt();\n            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e), e;\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            if (this.build(), this.isEmpty()) return null;\n            this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.queryInternal(n, this._root, i);\n          }\n        }\n      }, {\n        key: \"build\",\n        value: function () {\n          if (this._built) return null;\n          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;\n        }\n      }, {\n        key: \"getRoot\",\n        value: function () {\n          return this.build(), this._root;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e);\n          }\n          if (3 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2],\n              s = this.removeItem(i, r);\n            if (s) return !0;\n            for (var a = null, o = i.getChildBoundables().iterator(); o.hasNext();) {\n              var u = o.next();\n              if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof sn && (s = this.remove(n, u, r))) {\n                a = u;\n                break;\n              }\n            }\n            return null !== a && a.getChildBoundables().isEmpty() && i.getChildBoundables().remove(a), s;\n          }\n        }\n      }, {\n        key: \"createHigherLevels\",\n        value: function (t, e) {\n          G.isTrue(!t.isEmpty());\n          var n = this.createParentBoundables(t, e + 1);\n          return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);\n        }\n      }, {\n        key: \"depth\",\n        value: function () {\n          if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));\n          if (1 === arguments.length) {\n            for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {\n              var n = e.next();\n              if (n instanceof sn) {\n                var i = this.depth(n);\n                i > t && (t = i);\n              }\n            }\n            return t + 1;\n          }\n        }\n      }, {\n        key: \"createParentBoundables\",\n        value: function (t, e) {\n          G.isTrue(!t.isEmpty());\n          var n = new yt();\n          n.add(this.createNode(e));\n          var i = new yt(t);\n          an.sort(i, this.getComparator());\n          for (var r = i.iterator(); r.hasNext();) {\n            var s = r.next();\n            this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(s);\n          }\n          return n;\n        }\n      }, {\n        key: \"isEmpty\",\n        value: function () {\n          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._root = null, this._built = !1, this._itemBoundables = new yt(), this._nodeCapacity = null, 0 === arguments.length) t.constructor_.call(this, t.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {\n            var e = arguments[0];\n            G.isTrue(e > 1, \"Node capacity must be greater than 1\"), this._nodeCapacity = e;\n          }\n        }\n      }, {\n        key: \"compareDoubles\",\n        value: function (t, e) {\n          return t > e ? 1 : t < e ? -1 : 0;\n        }\n      }]);\n    }();\n  hn.IntersectsOp = function () {}, hn.DEFAULT_NODE_CAPACITY = 10;\n  var cn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"distance\",\n        value: function (t, e) {}\n      }]);\n    }(),\n    fn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"createParentBoundablesFromVerticalSlices\",\n        value: function (t, e) {\n          G.isTrue(t.length > 0);\n          for (var n = new yt(), i = 0; i < t.length; i++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));\n          return n;\n        }\n      }, {\n        key: \"nearestNeighbourK\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            return this.nearestNeighbourK(t, A.POSITIVE_INFINITY, e);\n          }\n          if (3 === arguments.length) {\n            var n = arguments[0],\n              r = arguments[2],\n              s = arguments[1],\n              a = new nn();\n            a.add(n);\n            for (var o = new nn(); !a.isEmpty() && s >= 0;) {\n              var u = a.poll(),\n                l = u.getDistance();\n              if (l >= s) break;\n              if (u.isLeaves()) {\n                if (o.size() < r) o.add(u);else o.peek().getDistance() > l && (o.poll(), o.add(u)), s = o.peek().getDistance();\n              } else u.expandToQueue(a, s);\n            }\n            return i.getItems(o);\n          }\n        }\n      }, {\n        key: \"createNode\",\n        value: function (t) {\n          return new gn(t);\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return 0 === arguments.length ? f(i, \"size\", this, 1).call(this) : f(i, \"size\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"insert\",\n        value: function () {\n          if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U)) return f(i, \"insert\", this, 1).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1];\n          if (t.isNull()) return null;\n          f(i, \"insert\", this, 1).call(this, t, e);\n        }\n      }, {\n        key: \"getIntersectsOp\",\n        value: function () {\n          return i.intersectsOp;\n        }\n      }, {\n        key: \"verticalSlices\",\n        value: function (t, e) {\n          for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), s = 0; s < e; s++) {\n            i[s] = new yt();\n            for (var a = 0; r.hasNext() && a < n;) {\n              var o = r.next();\n              i[s].add(o), a++;\n            }\n          }\n          return i;\n        }\n      }, {\n        key: \"query\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return f(i, \"query\", this, 1).call(this, t);\n          }\n          if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            f(i, \"query\", this, 1).call(this, e, n);\n          }\n        }\n      }, {\n        key: \"getComparator\",\n        value: function () {\n          return i.yComparator;\n        }\n      }, {\n        key: \"createParentBoundablesFromVerticalSlice\",\n        value: function (t, e) {\n          return f(i, \"createParentBoundables\", this, 1).call(this, t, e);\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) {\n            var t = arguments[0],\n              e = arguments[1];\n            return f(i, \"remove\", this, 1).call(this, t, e);\n          }\n          return f(i, \"remove\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"depth\",\n        value: function () {\n          return 0 === arguments.length ? f(i, \"depth\", this, 1).call(this) : f(i, \"depth\", this, 1).apply(this, arguments);\n        }\n      }, {\n        key: \"createParentBoundables\",\n        value: function (t, e) {\n          G.isTrue(!t.isEmpty());\n          var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),\n            r = new yt(t);\n          an.sort(r, i.xComparator);\n          var s = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n))));\n          return this.createParentBoundablesFromVerticalSlices(s, e);\n        }\n      }, {\n        key: \"nearestNeighbour\",\n        value: function () {\n          if (1 === arguments.length) {\n            if (rt(arguments[0], cn)) {\n              var t = arguments[0];\n              if (this.isEmpty()) return null;\n              var e = new un(this.getRoot(), this.getRoot(), t);\n              return this.nearestNeighbour(e);\n            }\n            if (arguments[0] instanceof un) {\n              var n = arguments[0],\n                i = A.POSITIVE_INFINITY,\n                r = null,\n                s = new nn();\n              for (s.add(n); !s.isEmpty() && i > 0;) {\n                var a = s.poll(),\n                  o = a.getDistance();\n                if (o >= i) break;\n                a.isLeaves() ? (i = o, r = a) : a.expandToQueue(s, i);\n              }\n              return null === r ? null : [r.getBoundable(0).getItem(), r.getBoundable(1).getItem()];\n            }\n          } else {\n            if (2 === arguments.length) {\n              var u = arguments[0],\n                l = arguments[1];\n              if (this.isEmpty() || u.isEmpty()) return null;\n              var h = new un(this.getRoot(), u.getRoot(), l);\n              return this.nearestNeighbour(h);\n            }\n            if (3 === arguments.length) {\n              var c = arguments[2],\n                f = new en(arguments[0], arguments[1]),\n                g = new un(this.getRoot(), f, c);\n              return this.nearestNeighbour(g)[0];\n            }\n            if (4 === arguments.length) {\n              var v = arguments[2],\n                y = arguments[3],\n                d = new en(arguments[0], arguments[1]),\n                _ = new un(this.getRoot(), d, v);\n              return this.nearestNeighbourK(_, y);\n            }\n          }\n        }\n      }, {\n        key: \"isWithinDistance\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = A.POSITIVE_INFINITY,\n              i = new nn();\n            for (i.add(t); !i.isEmpty();) {\n              var r = i.poll(),\n                s = r.getDistance();\n              if (s > e) return !1;\n              if (r.maximumDistance() <= e) return !0;\n              if (r.isLeaves()) {\n                if ((n = s) <= e) return !0;\n              } else r.expandToQueue(i, n);\n            }\n            return !1;\n          }\n          if (3 === arguments.length) {\n            var a = arguments[0],\n              o = arguments[1],\n              u = arguments[2],\n              l = new un(this.getRoot(), a.getRoot(), o);\n            return this.isWithinDistance(l, u);\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [rn, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (0 === arguments.length) i.constructor_.call(this, i.DEFAULT_NODE_CAPACITY);else if (1 === arguments.length) {\n            var t = arguments[0];\n            hn.constructor_.call(this, t);\n          }\n        }\n      }, {\n        key: \"centreX\",\n        value: function (t) {\n          return i.avg(t.getMinX(), t.getMaxX());\n        }\n      }, {\n        key: \"avg\",\n        value: function (t, e) {\n          return (t + e) / 2;\n        }\n      }, {\n        key: \"getItems\",\n        value: function (t) {\n          for (var e = new Array(t.size()).fill(null), n = 0; !t.isEmpty();) {\n            var i = t.poll();\n            e[n] = i.getBoundable(0).getItem(), n++;\n          }\n          return e;\n        }\n      }, {\n        key: \"centreY\",\n        value: function (t) {\n          return i.avg(t.getMinY(), t.getMaxY());\n        }\n      }]);\n    }(hn),\n    gn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"computeBounds\",\n        value: function () {\n          for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {\n            var n = e.next();\n            null === t ? t = new U(n.getBounds()) : t.expandToInclude(n.getBounds());\n          }\n          return t;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          var t = arguments[0];\n          sn.constructor_.call(this, t);\n        }\n      }]);\n    }(sn);\n  fn.STRtreeNode = gn, fn.xComparator = new (function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"interfaces_\",\n      get: function () {\n        return [P];\n      }\n    }, {\n      key: \"compare\",\n      value: function (t, e) {\n        return hn.compareDoubles(fn.centreX(t.getBounds()), fn.centreX(e.getBounds()));\n      }\n    }]);\n  }())(), fn.yComparator = new (function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"interfaces_\",\n      get: function () {\n        return [P];\n      }\n    }, {\n      key: \"compare\",\n      value: function (t, e) {\n        return hn.compareDoubles(fn.centreY(t.getBounds()), fn.centreY(e.getBounds()));\n      }\n    }]);\n  }())(), fn.intersectsOp = new (function () {\n    return s(function t() {\n      n(this, t);\n    }, [{\n      key: \"interfaces_\",\n      get: function () {\n        return [IntersectsOp];\n      }\n    }, {\n      key: \"intersects\",\n      value: function (t, e) {\n        return t.intersects(e);\n      }\n    }]);\n  }())(), fn.DEFAULT_NODE_CAPACITY = 10;\n  var vn = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"relativeSign\",\n        value: function (t, e) {\n          return t < e ? -1 : t > e ? 1 : 0;\n        }\n      }, {\n        key: \"compare\",\n        value: function (e, n, i) {\n          if (n.equals2D(i)) return 0;\n          var r = t.relativeSign(n.x, i.x),\n            s = t.relativeSign(n.y, i.y);\n          switch (e) {\n            case 0:\n              return t.compareValue(r, s);\n            case 1:\n              return t.compareValue(s, r);\n            case 2:\n              return t.compareValue(s, -r);\n            case 3:\n              return t.compareValue(-r, s);\n            case 4:\n              return t.compareValue(-r, -s);\n            case 5:\n              return t.compareValue(-s, -r);\n            case 6:\n              return t.compareValue(-s, r);\n            case 7:\n              return t.compareValue(r, -s);\n          }\n          return G.shouldNeverReachHere(\"invalid octant value\"), 0;\n        }\n      }, {\n        key: \"compareValue\",\n        value: function (t, e) {\n          return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;\n        }\n      }]);\n    }(),\n    yn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getCoordinate\",\n        value: function () {\n          return this.coord;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? vn.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1;\n        }\n      }, {\n        key: \"isEndPoint\",\n        value: function (t) {\n          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.segmentIndex + \":\" + this.coord.toString();\n        }\n      }, {\n        key: \"isInterior\",\n        value: function () {\n          return this._isInterior;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2],\n            i = arguments[3];\n          this._segString = t, this.coord = new X(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));\n        }\n      }]);\n    }(),\n    dn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"hasNext\",\n        value: function () {}\n      }, {\n        key: \"next\",\n        value: function () {}\n      }, {\n        key: \"remove\",\n        value: function () {}\n      }]);\n    }(),\n    _n = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getSplitCoordinates\",\n        value: function () {\n          var t = new Zt();\n          this.addEndpoints();\n          for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n            var i = e.next();\n            this.addEdgeCoordinates(n, i, t), n = i;\n          }\n          return t.toCoordinateArray();\n        }\n      }, {\n        key: \"addCollapsedNodes\",\n        value: function () {\n          var t = new yt();\n          this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next().intValue();\n            this.add(this._edge.getCoordinate(n), n);\n          }\n        }\n      }, {\n        key: \"createSplitEdgePts\",\n        value: function (t, e) {\n          var n = e.segmentIndex - t.segmentIndex + 2;\n          if (2 === n) return [new X(t.coord), new X(e.coord)];\n          var i = this._edge.getCoordinate(e.segmentIndex),\n            r = e.isInterior() || !e.coord.equals2D(i);\n          r || n--;\n          var s = new Array(n).fill(null),\n            a = 0;\n          s[a++] = new X(t.coord);\n          for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) s[a++] = this._edge.getCoordinate(o);\n          return r && (s[a] = new X(e.coord)), s;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.println(\"Intersections:\");\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"findCollapsesFromExistingVertices\",\n        value: function (t) {\n          for (var e = 0; e < this._edge.size() - 2; e++) {\n            var n = this._edge.getCoordinate(e);\n            this._edge.getCoordinate(e + 1);\n            var i = this._edge.getCoordinate(e + 2);\n            n.equals2D(i) && t.add(at.valueOf(e + 1));\n          }\n        }\n      }, {\n        key: \"addEdgeCoordinates\",\n        value: function (t, e, n) {\n          var i = this.createSplitEdgePts(t, e);\n          n.add(i, !1);\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this._nodeMap.values().iterator();\n        }\n      }, {\n        key: \"addSplitEdges\",\n        value: function (t) {\n          this.addEndpoints(), this.addCollapsedNodes();\n          for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n            var i = e.next(),\n              r = this.createSplitEdge(n, i);\n            t.add(r), n = i;\n          }\n        }\n      }, {\n        key: \"findCollapseIndex\",\n        value: function (t, e, n) {\n          if (!t.coord.equals2D(e.coord)) return !1;\n          var i = e.segmentIndex - t.segmentIndex;\n          return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0);\n        }\n      }, {\n        key: \"findCollapsesFromInsertedNodes\",\n        value: function (t) {\n          for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {\n            var r = n.next();\n            this.findCollapseIndex(i, r, e) && t.add(at.valueOf(e[0])), i = r;\n          }\n        }\n      }, {\n        key: \"getEdge\",\n        value: function () {\n          return this._edge;\n        }\n      }, {\n        key: \"addEndpoints\",\n        value: function () {\n          var t = this._edge.size() - 1;\n          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);\n        }\n      }, {\n        key: \"createSplitEdge\",\n        value: function (t, e) {\n          var n = this.createSplitEdgePts(t, e);\n          return new xn(n, this._edge.getData());\n        }\n      }, {\n        key: \"add\",\n        value: function (t, e) {\n          var n = new yn(this._edge, t, e, this._edge.getSegmentOctant(e)),\n            i = this._nodeMap.get(n);\n          return null !== i ? (G.isTrue(i.coord.equals2D(t), \"Found equal nodes with different coordinates\"), i) : (this._nodeMap.put(n, n), n);\n        }\n      }, {\n        key: \"checkSplitEdgesCorrectness\",\n        value: function (t) {\n          var e = this._edge.getCoordinates(),\n            n = t.get(0).getCoordinate(0);\n          if (!n.equals2D(e[0])) throw new D(\"bad split edge start point at \" + n);\n          var i = t.get(t.size() - 1).getCoordinates(),\n            r = i[i.length - 1];\n          if (!r.equals2D(e[e.length - 1])) throw new D(\"bad split edge end point at \" + r);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._nodeMap = new He(), this._edge = null;\n          var t = arguments[0];\n          this._edge = t;\n        }\n      }]);\n    }(),\n    pn = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"octant\",\n        value: function () {\n          if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1];\n            if (0 === e && 0 === n) throw new m(\"Cannot compute the octant for point ( \" + e + \", \" + n + \" )\");\n            var i = Math.abs(e),\n              r = Math.abs(n);\n            return e >= 0 ? n >= 0 ? i >= r ? 0 : 1 : i >= r ? 7 : 6 : n >= 0 ? i >= r ? 3 : 2 : i >= r ? 4 : 5;\n          }\n          if (arguments[0] instanceof X && arguments[1] instanceof X) {\n            var s = arguments[0],\n              a = arguments[1],\n              o = a.x - s.x,\n              u = a.y - s.y;\n            if (0 === o && 0 === u) throw new m(\"Cannot compute the octant for two identical points \" + s);\n            return t.octant(o, u);\n          }\n        }\n      }]);\n    }(),\n    mn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"getCoordinates\",\n        value: function () {}\n      }, {\n        key: \"size\",\n        value: function () {}\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {}\n      }, {\n        key: \"isClosed\",\n        value: function () {}\n      }, {\n        key: \"setData\",\n        value: function (t) {}\n      }, {\n        key: \"getData\",\n        value: function () {}\n      }]);\n    }(),\n    kn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"addIntersection\",\n        value: function (t, e) {}\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [mn];\n        }\n      }]);\n    }(),\n    xn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getCoordinates\",\n        value: function () {\n          return this._pts;\n        }\n      }, {\n        key: \"size\",\n        value: function () {\n          return this._pts.length;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {\n          return this._pts[t];\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this._pts[0].equals(this._pts[this._pts.length - 1]);\n        }\n      }, {\n        key: \"getSegmentOctant\",\n        value: function (t) {\n          return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));\n        }\n      }, {\n        key: \"setData\",\n        value: function (t) {\n          this._data = t;\n        }\n      }, {\n        key: \"safeOctant\",\n        value: function (t, e) {\n          return t.equals2D(e) ? 0 : pn.octant(t, e);\n        }\n      }, {\n        key: \"getData\",\n        value: function () {\n          return this._data;\n        }\n      }, {\n        key: \"addIntersection\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this.addIntersectionNode(t, e);\n          } else if (4 === arguments.length) {\n            var n = arguments[1],\n              i = arguments[3],\n              r = new X(arguments[0].getIntersection(i));\n            this.addIntersection(r, n);\n          }\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return Ce.toLineString(new Qt(this._pts));\n        }\n      }, {\n        key: \"getNodeList\",\n        value: function () {\n          return this._nodeList;\n        }\n      }, {\n        key: \"addIntersectionNode\",\n        value: function (t, e) {\n          var n = e,\n            i = n + 1;\n          if (i < this._pts.length) {\n            var r = this._pts[i];\n            t.equals2D(r) && (n = i);\n          }\n          return this._nodeList.add(t, n);\n        }\n      }, {\n        key: \"addIntersections\",\n        value: function (t, e, n) {\n          for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [kn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._nodeList = new _n(this), this._pts = null, this._data = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._pts = t, this._data = e;\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0],\n              n = new yt();\n            return t.getNodedSubstrings(e, n), n;\n          }\n          if (2 === arguments.length) for (var i = arguments[1], r = arguments[0].iterator(); r.hasNext();) {\n            r.next().getNodeList().addSplitEdges(i);\n          }\n        }\n      }]);\n    }(),\n    In = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"minX\",\n        value: function () {\n          return Math.min(this.p0.x, this.p1.x);\n        }\n      }, {\n        key: \"orientationIndex\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0],\n              n = ct.index(this.p0, this.p1, e.p0),\n              i = ct.index(this.p0, this.p1, e.p1);\n            return n >= 0 && i >= 0 || n <= 0 && i <= 0 ? Math.max(n, i) : 0;\n          }\n          if (arguments[0] instanceof X) {\n            var r = arguments[0];\n            return ct.index(this.p0, this.p1, r);\n          }\n        }\n      }, {\n        key: \"toGeometry\",\n        value: function (t) {\n          return t.createLineString([this.p0, this.p1]);\n        }\n      }, {\n        key: \"isVertical\",\n        value: function () {\n          return this.p0.x === this.p1.x;\n        }\n      }, {\n        key: \"equals\",\n        value: function (e) {\n          if (!(e instanceof t)) return !1;\n          var n = e;\n          return this.p0.equals(n.p0) && this.p1.equals(n.p1);\n        }\n      }, {\n        key: \"intersection\",\n        value: function (t) {\n          var e = new we();\n          return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;\n        }\n      }, {\n        key: \"project\",\n        value: function () {\n          if (arguments[0] instanceof X) {\n            var e = arguments[0];\n            if (e.equals(this.p0) || e.equals(this.p1)) return new X(e);\n            var n = this.projectionFactor(e),\n              i = new X();\n            return i.x = this.p0.x + n * (this.p1.x - this.p0.x), i.y = this.p0.y + n * (this.p1.y - this.p0.y), i;\n          }\n          if (arguments[0] instanceof t) {\n            var r = arguments[0],\n              s = this.projectionFactor(r.p0),\n              a = this.projectionFactor(r.p1);\n            if (s >= 1 && a >= 1) return null;\n            if (s <= 0 && a <= 0) return null;\n            var o = this.project(r.p0);\n            s < 0 && (o = this.p0), s > 1 && (o = this.p1);\n            var u = this.project(r.p1);\n            return a < 0 && (u = this.p0), a > 1 && (u = this.p1), new t(o, u);\n          }\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          this.p1.compareTo(this.p0) < 0 && this.reverse();\n        }\n      }, {\n        key: \"angle\",\n        value: function () {\n          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function (t) {\n          return 0 === t ? this.p0 : this.p1;\n        }\n      }, {\n        key: \"distancePerpendicular\",\n        value: function (t) {\n          return xt.pointToLinePerpendicular(t, this.p0, this.p1);\n        }\n      }, {\n        key: \"minY\",\n        value: function () {\n          return Math.min(this.p0.y, this.p1.y);\n        }\n      }, {\n        key: \"midPoint\",\n        value: function () {\n          return t.midPoint(this.p0, this.p1);\n        }\n      }, {\n        key: \"projectionFactor\",\n        value: function (t) {\n          if (t.equals(this.p0)) return 0;\n          if (t.equals(this.p1)) return 1;\n          var e = this.p1.x - this.p0.x,\n            n = this.p1.y - this.p0.y,\n            i = e * e + n * n;\n          return i <= 0 ? A.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;\n        }\n      }, {\n        key: \"closestPoints\",\n        value: function (t) {\n          var e = this.intersection(t);\n          if (null !== e) return [e, e];\n          var n = new Array(2).fill(null),\n            i = A.MAX_VALUE,\n            r = null,\n            s = this.closestPoint(t.p0);\n          i = s.distance(t.p0), n[0] = s, n[1] = t.p0;\n          var a = this.closestPoint(t.p1);\n          (r = a.distance(t.p1)) < i && (i = r, n[0] = a, n[1] = t.p1);\n          var o = t.closestPoint(this.p0);\n          (r = o.distance(this.p0)) < i && (i = r, n[0] = this.p0, n[1] = o);\n          var u = t.closestPoint(this.p1);\n          return (r = u.distance(this.p1)) < i && (i = r, n[0] = this.p1, n[1] = u), n;\n        }\n      }, {\n        key: \"closestPoint\",\n        value: function (t) {\n          var e = this.projectionFactor(t);\n          return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1;\n        }\n      }, {\n        key: \"maxX\",\n        value: function () {\n          return Math.max(this.p0.x, this.p1.x);\n        }\n      }, {\n        key: \"getLength\",\n        value: function () {\n          return this.p0.distance(this.p1);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t,\n            n = this.p0.compareTo(e.p0);\n          return 0 !== n ? n : this.p1.compareTo(e.p1);\n        }\n      }, {\n        key: \"reverse\",\n        value: function () {\n          var t = this.p0;\n          this.p0 = this.p1, this.p1 = t;\n        }\n      }, {\n        key: \"equalsTopo\",\n        value: function (t) {\n          return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0);\n        }\n      }, {\n        key: \"lineIntersection\",\n        value: function (t) {\n          return pt.intersection(this.p0, this.p1, t.p0, t.p1);\n        }\n      }, {\n        key: \"maxY\",\n        value: function () {\n          return Math.max(this.p0.y, this.p1.y);\n        }\n      }, {\n        key: \"pointAlongOffset\",\n        value: function (t, e) {\n          var n = this.p0.x + t * (this.p1.x - this.p0.x),\n            i = this.p0.y + t * (this.p1.y - this.p0.y),\n            r = this.p1.x - this.p0.x,\n            s = this.p1.y - this.p0.y,\n            a = Math.sqrt(r * r + s * s),\n            o = 0,\n            u = 0;\n          if (0 !== e) {\n            if (a <= 0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n            o = e * r / a, u = e * s / a;\n          }\n          return new X(n - u, i + o);\n        }\n      }, {\n        key: \"setCoordinates\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setCoordinates(t.p0, t.p1);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;\n          }\n        }\n      }, {\n        key: \"segmentFraction\",\n        value: function (t) {\n          var e = this.projectionFactor(t);\n          return e < 0 ? e = 0 : (e > 1 || A.isNaN(e)) && (e = 1), e;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n        }\n      }, {\n        key: \"isHorizontal\",\n        value: function () {\n          return this.p0.y === this.p1.y;\n        }\n      }, {\n        key: \"reflect\",\n        value: function (t) {\n          var e = this.p1.getY() - this.p0.getY(),\n            n = this.p0.getX() - this.p1.getX(),\n            i = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()),\n            r = e * e + n * n,\n            s = e * e - n * n,\n            a = t.getX(),\n            o = t.getY();\n          return new X((-s * a - 2 * e * n * o - 2 * e * i) / r, (s * o - 2 * e * n * a - 2 * n * i) / r);\n        }\n      }, {\n        key: \"distance\",\n        value: function () {\n          if (arguments[0] instanceof t) {\n            var e = arguments[0];\n            return xt.segmentToSegment(this.p0, this.p1, e.p0, e.p1);\n          }\n          if (arguments[0] instanceof X) {\n            var n = arguments[0];\n            return xt.pointToSegment(n, this.p0, this.p1);\n          }\n        }\n      }, {\n        key: \"pointAlong\",\n        value: function (t) {\n          var e = new X();\n          return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;\n        }\n      }, {\n        key: \"hashCode\",\n        value: function () {\n          var t = A.doubleToLongBits(this.p0.x);\n          t ^= 31 * A.doubleToLongBits(this.p0.y);\n          var e = Math.trunc(t) ^ Math.trunc(t >> 32),\n            n = A.doubleToLongBits(this.p1.x);\n          return n ^= 31 * A.doubleToLongBits(this.p1.y), e ^ (Math.trunc(n) ^ Math.trunc(n >> 32));\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x, E];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.p0 = null, this.p1 = null, 0 === arguments.length) t.constructor_.call(this, new X(), new X());else if (1 === arguments.length) {\n            var e = arguments[0];\n            t.constructor_.call(this, e.p0, e.p1);\n          } else if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1];\n            this.p0 = n, this.p1 = i;\n          } else if (4 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2],\n              o = arguments[3];\n            t.constructor_.call(this, new X(r, s), new X(a, o));\n          }\n        }\n      }, {\n        key: \"midPoint\",\n        value: function (t, e) {\n          return new X((t.x + e.x) / 2, (t.y + e.y) / 2);\n        }\n      }]);\n    }(),\n    En = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"overlap\",\n        value: function () {\n          if (2 === arguments.length) ;else if (4 === arguments.length) {\n            var t = arguments[1],\n              e = arguments[2],\n              n = arguments[3];\n            arguments[0].getLineSegment(t, this._overlapSeg1), e.getLineSegment(n, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._overlapSeg1 = new In(), this._overlapSeg2 = new In();\n        }\n      }]);\n    }(),\n    Nn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getLineSegment\",\n        value: function (t, e) {\n          e.p0 = this._pts[t], e.p1 = this._pts[t + 1];\n        }\n      }, {\n        key: \"computeSelect\",\n        value: function (t, e, n, i) {\n          var r = this._pts[e],\n            s = this._pts[n];\n          if (n - e == 1) return i.select(this, e), null;\n          if (!t.intersects(r, s)) return null;\n          var a = Math.trunc((e + n) / 2);\n          e < a && this.computeSelect(t, e, a, i), a < n && this.computeSelect(t, a, n, i);\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];\n          return t;\n        }\n      }, {\n        key: \"computeOverlaps\",\n        value: function () {\n          if (2 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1];\n            this.computeOverlaps(this._start, this._end, t, t._start, t._end, e);\n          } else if (6 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = arguments[2],\n              s = arguments[3],\n              a = arguments[4],\n              o = arguments[5];\n            if (i - n == 1 && a - s == 1) return o.overlap(this, n, r, s), null;\n            if (!this.overlaps(n, i, r, s, a)) return null;\n            var u = Math.trunc((n + i) / 2),\n              l = Math.trunc((s + a) / 2);\n            n < u && (s < l && this.computeOverlaps(n, u, r, s, l, o), l < a && this.computeOverlaps(n, u, r, l, a, o)), u < i && (s < l && this.computeOverlaps(u, i, r, s, l, o), l < a && this.computeOverlaps(u, i, r, l, a, o));\n          }\n        }\n      }, {\n        key: \"setId\",\n        value: function (t) {\n          this._id = t;\n        }\n      }, {\n        key: \"select\",\n        value: function (t, e) {\n          this.computeSelect(t, this._start, this._end, e);\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          if (null === this._env) {\n            var t = this._pts[this._start],\n              e = this._pts[this._end];\n            this._env = new U(t, e);\n          }\n          return this._env;\n        }\n      }, {\n        key: \"overlaps\",\n        value: function (t, e, n, i, r) {\n          return U.intersects(this._pts[t], this._pts[e], n._pts[i], n._pts[r]);\n        }\n      }, {\n        key: \"getEndIndex\",\n        value: function () {\n          return this._end;\n        }\n      }, {\n        key: \"getStartIndex\",\n        value: function () {\n          return this._start;\n        }\n      }, {\n        key: \"getContext\",\n        value: function () {\n          return this._context;\n        }\n      }, {\n        key: \"getId\",\n        value: function () {\n          return this._id;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2],\n            i = arguments[3];\n          this._pts = t, this._start = e, this._end = n, this._context = i;\n        }\n      }]);\n    }(),\n    Tn = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, null, [{\n        key: \"findChainEnd\",\n        value: function (t, e) {\n          for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;\n          if (n >= t.length - 1) return t.length - 1;\n          for (var i = je.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length;) {\n            if (!t[r - 1].equals2D(t[r])) if (je.quadrant(t[r - 1], t[r]) !== i) break;\n            r++;\n          }\n          return r - 1;\n        }\n      }, {\n        key: \"getChains\",\n        value: function () {\n          if (1 === arguments.length) {\n            var e = arguments[0];\n            return t.getChains(e, null);\n          }\n          if (2 === arguments.length) {\n            var n = arguments[0],\n              i = arguments[1],\n              r = new yt(),\n              s = 0;\n            do {\n              var a = t.findChainEnd(n, s),\n                o = new Nn(n, s, a, i);\n              r.add(o), s = a;\n            } while (s < n.length - 1);\n            return r;\n          }\n        }\n      }]);\n    }(),\n    Sn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"computeNodes\",\n        value: function (t) {}\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {}\n      }]);\n    }(),\n    Ln = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"setSegmentIntersector\",\n        value: function (t) {\n          this._segInt = t;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Sn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._segInt = null, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            this.setSegmentIntersector(t);\n          }\n        }\n      }]);\n    }(),\n    Cn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getMonotoneChains\",\n        value: function () {\n          return this._monoChains;\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          return xn.getNodedSubstrings(this._nodedSegStrings);\n        }\n      }, {\n        key: \"getIndex\",\n        value: function () {\n          return this._index;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          for (var e = Tn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {\n            var n = e.next();\n            n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n);\n          }\n        }\n      }, {\n        key: \"computeNodes\",\n        value: function (t) {\n          this._nodedSegStrings = t;\n          for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n          this.intersectChains();\n        }\n      }, {\n        key: \"intersectChains\",\n        value: function () {\n          for (var t = new Rn(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (var n = e.next(), i = this._index.query(n.getEnvelope()).iterator(); i.hasNext();) {\n            var r = i.next();\n            if (r.getId() > n.getId() && (n.computeOverlaps(r, t), this._nOverlaps++), this._segInt.isDone()) return null;\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._monoChains = new yt(), this._index = new fn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length) ;else if (1 === arguments.length) {\n            var t = arguments[0];\n            Ln.constructor_.call(this, t);\n          }\n        }\n      }]);\n    }(Ln),\n    Rn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"overlap\",\n        value: function () {\n          if (4 !== arguments.length) return f(i, \"overlap\", this, 1).apply(this, arguments);\n          var t = arguments[1],\n            e = arguments[2],\n            n = arguments[3],\n            r = arguments[0].getContext(),\n            s = e.getContext();\n          this._si.processIntersections(r, t, s, n);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._si = null;\n          var t = arguments[0];\n          this._si = t;\n        }\n      }]);\n    }(En);\n  Cn.SegmentOverlapAction = Rn;\n  var wn = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"isDeletable\",\n      value: function (t, e, n, i) {\n        var r = this._inputLine[t],\n          s = this._inputLine[e],\n          a = this._inputLine[n];\n        return !!this.isConcave(r, s, a) && !!this.isShallow(r, s, a, i) && this.isShallowSampled(r, s, t, n, i);\n      }\n    }, {\n      key: \"deleteShallowConcavities\",\n      value: function () {\n        for (var e = 1, n = this.findNextNonDeletedIndex(e), i = this.findNextNonDeletedIndex(n), r = !1; i < this._inputLine.length;) {\n          var s = !1;\n          this.isDeletable(e, n, i, this._distanceTol) && (this._isDeleted[n] = t.DELETE, s = !0, r = !0), e = s ? i : n, n = this.findNextNonDeletedIndex(e), i = this.findNextNonDeletedIndex(n);\n        }\n        return r;\n      }\n    }, {\n      key: \"isShallowConcavity\",\n      value: function (t, e, n, i) {\n        return ct.index(t, e, n) === this._angleOrientation && xt.pointToSegment(e, t, n) < i;\n      }\n    }, {\n      key: \"isShallowSampled\",\n      value: function (e, n, i, r, s) {\n        var a = Math.trunc((r - i) / t.NUM_PTS_TO_CHECK);\n        a <= 0 && (a = 1);\n        for (var o = i; o < r; o += a) if (!this.isShallow(e, n, this._inputLine[o], s)) return !1;\n        return !0;\n      }\n    }, {\n      key: \"isConcave\",\n      value: function (t, e, n) {\n        var i = ct.index(t, e, n) === this._angleOrientation;\n        return i;\n      }\n    }, {\n      key: \"simplify\",\n      value: function (t) {\n        this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = ct.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);\n        var e = !1;\n        do {\n          e = this.deleteShallowConcavities();\n        } while (e);\n        return this.collapseLine();\n      }\n    }, {\n      key: \"findNextNonDeletedIndex\",\n      value: function (e) {\n        for (var n = e + 1; n < this._inputLine.length && this._isDeleted[n] === t.DELETE;) n++;\n        return n;\n      }\n    }, {\n      key: \"isShallow\",\n      value: function (t, e, n, i) {\n        return xt.pointToSegment(e, t, n) < i;\n      }\n    }, {\n      key: \"collapseLine\",\n      value: function () {\n        for (var e = new Zt(), n = 0; n < this._inputLine.length; n++) this._isDeleted[n] !== t.DELETE && e.add(this._inputLine[n]);\n        return e.toCoordinateArray();\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ct.COUNTERCLOCKWISE;\n        var t = arguments[0];\n        this._inputLine = t;\n      }\n    }, {\n      key: \"simplify\",\n      value: function (e, n) {\n        return new t(e).simplify(n);\n      }\n    }]);\n  }();\n  wn.INIT = 0, wn.DELETE = 1, wn.KEEP = 1, wn.NUM_PTS_TO_CHECK = 10;\n  var On = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"getCoordinates\",\n      value: function () {\n        return this._ptList.toArray(t.COORDINATE_ARRAY_TYPE);\n      }\n    }, {\n      key: \"setPrecisionModel\",\n      value: function (t) {\n        this._precisionModel = t;\n      }\n    }, {\n      key: \"addPt\",\n      value: function (t) {\n        var e = new X(t);\n        if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;\n        this._ptList.add(e);\n      }\n    }, {\n      key: \"reverse\",\n      value: function () {}\n    }, {\n      key: \"addPts\",\n      value: function (t, e) {\n        if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);else for (var i = t.length - 1; i >= 0; i--) this.addPt(t[i]);\n      }\n    }, {\n      key: \"isRedundant\",\n      value: function (t) {\n        if (this._ptList.size() < 1) return !1;\n        var e = this._ptList.get(this._ptList.size() - 1);\n        return t.distance(e) < this._minimimVertexDistance;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return new ae().createLineString(this.getCoordinates()).toString();\n      }\n    }, {\n      key: \"closeRing\",\n      value: function () {\n        if (this._ptList.size() < 1) return null;\n        var t = new X(this._ptList.get(0)),\n          e = this._ptList.get(this._ptList.size() - 1);\n        if (t.equals(e)) return null;\n        this._ptList.add(t);\n      }\n    }, {\n      key: \"setMinimumVertexDistance\",\n      value: function (t) {\n        this._minimimVertexDistance = t;\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new yt();\n      }\n    }]);\n  }();\n  On.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n  var bn = function () {\n    function t() {\n      n(this, t);\n    }\n    return s(t, null, [{\n      key: \"toDegrees\",\n      value: function (t) {\n        return 180 * t / Math.PI;\n      }\n    }, {\n      key: \"normalize\",\n      value: function (e) {\n        for (; e > Math.PI;) e -= t.PI_TIMES_2;\n        for (; e <= -Math.PI;) e += t.PI_TIMES_2;\n        return e;\n      }\n    }, {\n      key: \"angle\",\n      value: function () {\n        if (1 === arguments.length) {\n          var t = arguments[0];\n          return Math.atan2(t.y, t.x);\n        }\n        if (2 === arguments.length) {\n          var e = arguments[0],\n            n = arguments[1],\n            i = n.x - e.x,\n            r = n.y - e.y;\n          return Math.atan2(r, i);\n        }\n      }\n    }, {\n      key: \"isAcute\",\n      value: function (t, e, n) {\n        var i = t.x - e.x,\n          r = t.y - e.y;\n        return i * (n.x - e.x) + r * (n.y - e.y) > 0;\n      }\n    }, {\n      key: \"isObtuse\",\n      value: function (t, e, n) {\n        var i = t.x - e.x,\n          r = t.y - e.y;\n        return i * (n.x - e.x) + r * (n.y - e.y) < 0;\n      }\n    }, {\n      key: \"interiorAngle\",\n      value: function (e, n, i) {\n        var r = t.angle(n, e),\n          s = t.angle(n, i);\n        return Math.abs(s - r);\n      }\n    }, {\n      key: \"normalizePositive\",\n      value: function (e) {\n        if (e < 0) {\n          for (; e < 0;) e += t.PI_TIMES_2;\n          e >= t.PI_TIMES_2 && (e = 0);\n        } else {\n          for (; e >= t.PI_TIMES_2;) e -= t.PI_TIMES_2;\n          e < 0 && (e = 0);\n        }\n        return e;\n      }\n    }, {\n      key: \"angleBetween\",\n      value: function (e, n, i) {\n        var r = t.angle(n, e),\n          s = t.angle(n, i);\n        return t.diff(r, s);\n      }\n    }, {\n      key: \"diff\",\n      value: function (t, e) {\n        var n = null;\n        return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n;\n      }\n    }, {\n      key: \"toRadians\",\n      value: function (t) {\n        return t * Math.PI / 180;\n      }\n    }, {\n      key: \"getTurn\",\n      value: function (e, n) {\n        var i = Math.sin(n - e);\n        return i > 0 ? t.COUNTERCLOCKWISE : i < 0 ? t.CLOCKWISE : t.NONE;\n      }\n    }, {\n      key: \"angleBetweenOriented\",\n      value: function (e, n, i) {\n        var r = t.angle(n, e),\n          s = t.angle(n, i) - r;\n        return s <= -Math.PI ? s + t.PI_TIMES_2 : s > Math.PI ? s - t.PI_TIMES_2 : s;\n      }\n    }]);\n  }();\n  bn.PI_TIMES_2 = 2 * Math.PI, bn.PI_OVER_2 = Math.PI / 2, bn.PI_OVER_4 = Math.PI / 4, bn.COUNTERCLOCKWISE = ct.COUNTERCLOCKWISE, bn.CLOCKWISE = ct.CLOCKWISE, bn.NONE = ct.COLLINEAR;\n  var Mn = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"addNextSegment\",\n      value: function (t, e) {\n        if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;\n        var n = ct.index(this._s0, this._s1, this._s2),\n          i = n === ct.CLOCKWISE && this._side === $.LEFT || n === ct.COUNTERCLOCKWISE && this._side === $.RIGHT;\n        0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);\n      }\n    }, {\n      key: \"addLineEndCap\",\n      value: function (t, e) {\n        var n = new In(t, e),\n          i = new In();\n        this.computeOffsetSegment(n, $.LEFT, this._distance, i);\n        var r = new In();\n        this.computeOffsetSegment(n, $.RIGHT, this._distance, r);\n        var s = e.x - t.x,\n          a = e.y - t.y,\n          o = Math.atan2(a, s);\n        switch (this._bufParams.getEndCapStyle()) {\n          case _.CAP_ROUND:\n            this._segList.addPt(i.p1), this.addDirectedFillet(e, o + Math.PI / 2, o - Math.PI / 2, ct.CLOCKWISE, this._distance), this._segList.addPt(r.p1);\n            break;\n          case _.CAP_FLAT:\n            this._segList.addPt(i.p1), this._segList.addPt(r.p1);\n            break;\n          case _.CAP_SQUARE:\n            var u = new X();\n            u.x = Math.abs(this._distance) * Math.cos(o), u.y = Math.abs(this._distance) * Math.sin(o);\n            var l = new X(i.p1.x + u.x, i.p1.y + u.y),\n              h = new X(r.p1.x + u.x, r.p1.y + u.y);\n            this._segList.addPt(l), this._segList.addPt(h);\n        }\n      }\n    }, {\n      key: \"getCoordinates\",\n      value: function () {\n        return this._segList.getCoordinates();\n      }\n    }, {\n      key: \"addMitreJoin\",\n      value: function (t, e, n, i) {\n        var r = pt.intersection(e.p0, e.p1, n.p0, n.p1);\n        if (null !== r && (i <= 0 ? 1 : r.distance(t) / Math.abs(i)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(r), null;\n        this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit());\n      }\n    }, {\n      key: \"addOutsideTurn\",\n      value: function (e, n) {\n        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * t.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;\n        this._bufParams.getJoinStyle() === _.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === _.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (n && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, e, this._distance), this._segList.addPt(this._offset1.p0));\n      }\n    }, {\n      key: \"createSquare\",\n      value: function (t) {\n        this._segList.addPt(new X(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new X(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new X(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new X(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();\n      }\n    }, {\n      key: \"addSegments\",\n      value: function (t, e) {\n        this._segList.addPts(t, e);\n      }\n    }, {\n      key: \"addFirstSegment\",\n      value: function () {\n        this._segList.addPt(this._offset1.p0);\n      }\n    }, {\n      key: \"addCornerFillet\",\n      value: function (t, e, n, i, r) {\n        var s = e.x - t.x,\n          a = e.y - t.y,\n          o = Math.atan2(a, s),\n          u = n.x - t.x,\n          l = n.y - t.y,\n          h = Math.atan2(l, u);\n        i === ct.CLOCKWISE ? o <= h && (o += 2 * Math.PI) : o >= h && (o -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, o, h, i, r), this._segList.addPt(n);\n      }\n    }, {\n      key: \"addLastSegment\",\n      value: function () {\n        this._segList.addPt(this._offset1.p1);\n      }\n    }, {\n      key: \"initSideSegments\",\n      value: function (t, e, n) {\n        this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);\n      }\n    }, {\n      key: \"addLimitedMitreJoin\",\n      value: function (t, e, n, i) {\n        var r = this._seg0.p1,\n          s = bn.angle(r, this._seg0.p0),\n          a = bn.angleBetweenOriented(this._seg0.p0, r, this._seg1.p1) / 2,\n          o = bn.normalize(s + a),\n          u = bn.normalize(o + Math.PI),\n          l = i * n,\n          h = n - l * Math.abs(Math.sin(a)),\n          c = r.x + l * Math.cos(u),\n          f = r.y + l * Math.sin(u),\n          g = new X(c, f),\n          v = new In(r, g),\n          y = v.pointAlongOffset(1, h),\n          d = v.pointAlongOffset(1, -h);\n        this._side === $.LEFT ? (this._segList.addPt(y), this._segList.addPt(d)) : (this._segList.addPt(d), this._segList.addPt(y));\n      }\n    }, {\n      key: \"addDirectedFillet\",\n      value: function (t, e, n, i, r) {\n        var s = i === ct.CLOCKWISE ? -1 : 1,\n          a = Math.abs(e - n),\n          o = Math.trunc(a / this._filletAngleQuantum + .5);\n        if (o < 1) return null;\n        for (var u = a / o, l = new X(), h = 0; h < o; h++) {\n          var c = e + s * h * u;\n          l.x = t.x + r * Math.cos(c), l.y = t.y + r * Math.sin(c), this._segList.addPt(l);\n        }\n      }\n    }, {\n      key: \"computeOffsetSegment\",\n      value: function (t, e, n, i) {\n        var r = e === $.LEFT ? 1 : -1,\n          s = t.p1.x - t.p0.x,\n          a = t.p1.y - t.p0.y,\n          o = Math.sqrt(s * s + a * a),\n          u = r * n * s / o,\n          l = r * n * a / o;\n        i.p0.x = t.p0.x - l, i.p0.y = t.p0.y + u, i.p1.x = t.p1.x - l, i.p1.y = t.p1.y + u;\n      }\n    }, {\n      key: \"addInsideTurn\",\n      value: function (e, n) {\n        if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * t.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);else {\n          if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {\n            var i = new X((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n            this._segList.addPt(i);\n            var r = new X((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n            this._segList.addPt(r);\n          } else this._segList.addPt(this._s1);\n          this._segList.addPt(this._offset1.p0);\n        }\n      }\n    }, {\n      key: \"createCircle\",\n      value: function (t) {\n        var e = new X(t.x + this._distance, t.y);\n        this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();\n      }\n    }, {\n      key: \"addBevelJoin\",\n      value: function (t, e) {\n        this._segList.addPt(t.p1), this._segList.addPt(e.p0);\n      }\n    }, {\n      key: \"init\",\n      value: function (e) {\n        this._distance = e, this._maxCurveSegmentError = e * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new On(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(e * t.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n      }\n    }, {\n      key: \"addCollinear\",\n      value: function (t) {\n        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === _.JOIN_BEVEL || this._bufParams.getJoinStyle() === _.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ct.CLOCKWISE, this._distance));\n      }\n    }, {\n      key: \"closeRing\",\n      value: function () {\n        this._segList.closeRing();\n      }\n    }, {\n      key: \"hasNarrowConcaveAngle\",\n      value: function () {\n        return this._hasNarrowConcaveAngle;\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new In(), this._seg1 = new In(), this._offset0 = new In(), this._offset1 = new In(), this._side = 0, this._hasNarrowConcaveAngle = !1;\n        var e = arguments[0],\n          n = arguments[1],\n          i = arguments[2];\n        this._precisionModel = e, this._bufParams = n, this._li = new we(), this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === _.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i);\n      }\n    }]);\n  }();\n  Mn.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, Mn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, Mn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Mn.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n  var An = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getOffsetCurve\",\n        value: function (t, e) {\n          if (this._distance = e, 0 === e) return null;\n          var n = e < 0,\n            i = Math.abs(e),\n            r = this.getSegGen(i);\n          t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);\n          var s = r.getCoordinates();\n          return n && jt.reverse(s), s;\n        }\n      }, {\n        key: \"computeSingleSidedBufferCurve\",\n        value: function (t, e, n) {\n          var i = this.simplifyTolerance(this._distance);\n          if (e) {\n            n.addSegments(t, !0);\n            var r = wn.simplify(t, -i),\n              s = r.length - 1;\n            n.initSideSegments(r[s], r[s - 1], $.LEFT), n.addFirstSegment();\n            for (var a = s - 2; a >= 0; a--) n.addNextSegment(r[a], !0);\n          } else {\n            n.addSegments(t, !1);\n            var o = wn.simplify(t, i),\n              u = o.length - 1;\n            n.initSideSegments(o[0], o[1], $.LEFT), n.addFirstSegment();\n            for (var l = 2; l <= u; l++) n.addNextSegment(o[l], !0);\n          }\n          n.addLastSegment(), n.closeRing();\n        }\n      }, {\n        key: \"computeRingBufferCurve\",\n        value: function (t, e, n) {\n          var i = this.simplifyTolerance(this._distance);\n          e === $.RIGHT && (i = -i);\n          var r = wn.simplify(t, i),\n            s = r.length - 1;\n          n.initSideSegments(r[s - 1], r[0], e);\n          for (var a = 1; a <= s; a++) {\n            var o = 1 !== a;\n            n.addNextSegment(r[a], o);\n          }\n          n.closeRing();\n        }\n      }, {\n        key: \"computeLineBufferCurve\",\n        value: function (t, e) {\n          var n = this.simplifyTolerance(this._distance),\n            i = wn.simplify(t, n),\n            r = i.length - 1;\n          e.initSideSegments(i[0], i[1], $.LEFT);\n          for (var s = 2; s <= r; s++) e.addNextSegment(i[s], !0);\n          e.addLastSegment(), e.addLineEndCap(i[r - 1], i[r]);\n          var a = wn.simplify(t, -n),\n            o = a.length - 1;\n          e.initSideSegments(a[o], a[o - 1], $.LEFT);\n          for (var u = o - 2; u >= 0; u--) e.addNextSegment(a[u], !0);\n          e.addLastSegment(), e.addLineEndCap(a[1], a[0]), e.closeRing();\n        }\n      }, {\n        key: \"computePointCurve\",\n        value: function (t, e) {\n          switch (this._bufParams.getEndCapStyle()) {\n            case _.CAP_ROUND:\n              e.createCircle(t);\n              break;\n            case _.CAP_SQUARE:\n              e.createSquare(t);\n          }\n        }\n      }, {\n        key: \"getLineCurve\",\n        value: function (t, e) {\n          if (this._distance = e, this.isLineOffsetEmpty(e)) return null;\n          var n = Math.abs(e),\n            i = this.getSegGen(n);\n          if (t.length <= 1) this.computePointCurve(t[0], i);else if (this._bufParams.isSingleSided()) {\n            var r = e < 0;\n            this.computeSingleSidedBufferCurve(t, r, i);\n          } else this.computeLineBufferCurve(t, i);\n          return i.getCoordinates();\n        }\n      }, {\n        key: \"getBufferParameters\",\n        value: function () {\n          return this._bufParams;\n        }\n      }, {\n        key: \"simplifyTolerance\",\n        value: function (t) {\n          return t * this._bufParams.getSimplifyFactor();\n        }\n      }, {\n        key: \"getRingCurve\",\n        value: function (e, n, i) {\n          if (this._distance = i, e.length <= 2) return this.getLineCurve(e, i);\n          if (0 === i) return t.copyCoordinates(e);\n          var r = this.getSegGen(i);\n          return this.computeRingBufferCurve(e, n, r), r.getCoordinates();\n        }\n      }, {\n        key: \"computeOffsetCurve\",\n        value: function (t, e, n) {\n          var i = this.simplifyTolerance(this._distance);\n          if (e) {\n            var r = wn.simplify(t, -i),\n              s = r.length - 1;\n            n.initSideSegments(r[s], r[s - 1], $.LEFT), n.addFirstSegment();\n            for (var a = s - 2; a >= 0; a--) n.addNextSegment(r[a], !0);\n          } else {\n            var o = wn.simplify(t, i),\n              u = o.length - 1;\n            n.initSideSegments(o[0], o[1], $.LEFT), n.addFirstSegment();\n            for (var l = 2; l <= u; l++) n.addNextSegment(o[l], !0);\n          }\n          n.addLastSegment();\n        }\n      }, {\n        key: \"isLineOffsetEmpty\",\n        value: function (t) {\n          return 0 === t || t < 0 && !this._bufParams.isSingleSided();\n        }\n      }, {\n        key: \"getSegGen\",\n        value: function (t) {\n          return new Mn(this._precisionModel, this._bufParams, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._distance = 0, this._precisionModel = null, this._bufParams = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._precisionModel = t, this._bufParams = e;\n        }\n      }, {\n        key: \"copyCoordinates\",\n        value: function (t) {\n          for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new X(t[n]);\n          return e;\n        }\n      }]);\n    }(),\n    Pn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"findStabbedSegments\",\n        value: function () {\n          if (1 === arguments.length) {\n            for (var t = arguments[0], e = new yt(), n = this._subgraphs.iterator(); n.hasNext();) {\n              var i = n.next(),\n                r = i.getEnvelope();\n              t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e);\n            }\n            return e;\n          }\n          if (3 === arguments.length) if (rt(arguments[2], nt) && arguments[0] instanceof X && arguments[1] instanceof Ke) for (var s = arguments[0], a = arguments[1], o = arguments[2], u = a.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++) {\n            if (this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < s.x || this._seg.isHorizontal() || s.y < this._seg.p0.y || s.y > this._seg.p1.y || ct.index(this._seg.p0, this._seg.p1, s) === ct.RIGHT)) {\n              var h = a.getDepth($.LEFT);\n              this._seg.p0.equals(u[l]) || (h = a.getDepth($.RIGHT));\n              var c = new Dn(this._seg, h);\n              o.add(c);\n            }\n          } else if (rt(arguments[2], nt) && arguments[0] instanceof X && rt(arguments[1], nt)) for (var f = arguments[0], g = arguments[2], v = arguments[1].iterator(); v.hasNext();) {\n            var y = v.next();\n            y.isForward() && this.findStabbedSegments(f, y, g);\n          }\n        }\n      }, {\n        key: \"getDepth\",\n        value: function (t) {\n          var e = this.findStabbedSegments(t);\n          return 0 === e.size() ? 0 : an.min(e)._leftDepth;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._subgraphs = null, this._seg = new In();\n          var t = arguments[0];\n          this._subgraphs = t;\n        }\n      }]);\n    }(),\n    Dn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;\n          if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;\n          var n = this._upwardSeg.orientationIndex(e._upwardSeg);\n          return 0 !== n || 0 !== (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg);\n        }\n      }, {\n        key: \"compareX\",\n        value: function (t, e) {\n          var n = t.p0.compareTo(e.p0);\n          return 0 !== n ? n : t.p1.compareTo(e.p1);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this._upwardSeg.toString();\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._upwardSeg = null, this._leftDepth = null;\n          var t = arguments[0],\n            e = arguments[1];\n          this._upwardSeg = new In(t), this._leftDepth = e;\n        }\n      }]);\n    }();\n  Pn.DepthSegment = Dn;\n  var Fn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, null, [{\n        key: \"constructor_\",\n        value: function () {\n          p.constructor_.call(this, \"Projective point not representable on the Cartesian plane.\");\n        }\n      }]);\n    }(p),\n    Gn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getY\",\n        value: function () {\n          var t = this.y / this.w;\n          if (A.isNaN(t) || A.isInfinite(t)) throw new Fn();\n          return t;\n        }\n      }, {\n        key: \"getX\",\n        value: function () {\n          var t = this.x / this.w;\n          if (A.isNaN(t) || A.isInfinite(t)) throw new Fn();\n          return t;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          var t = new X();\n          return t.x = this.getX(), t.y = this.getY(), t;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;else if (1 === arguments.length) {\n            var e = arguments[0];\n            this.x = e.x, this.y = e.y, this.w = 1;\n          } else if (2 === arguments.length) {\n            if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n              var n = arguments[0],\n                i = arguments[1];\n              this.x = n, this.y = i, this.w = 1;\n            } else if (arguments[0] instanceof t && arguments[1] instanceof t) {\n              var r = arguments[0],\n                s = arguments[1];\n              this.x = r.y * s.w - s.y * r.w, this.y = s.x * r.w - r.x * s.w, this.w = r.x * s.y - s.x * r.y;\n            } else if (arguments[0] instanceof X && arguments[1] instanceof X) {\n              var a = arguments[0],\n                o = arguments[1];\n              this.x = a.y - o.y, this.y = o.x - a.x, this.w = a.x * o.y - o.x * a.y;\n            }\n          } else if (3 === arguments.length) {\n            var u = arguments[0],\n              l = arguments[1],\n              h = arguments[2];\n            this.x = u, this.y = l, this.w = h;\n          } else if (4 === arguments.length) {\n            var c = arguments[0],\n              f = arguments[1],\n              g = arguments[2],\n              v = arguments[3],\n              y = c.y - f.y,\n              d = f.x - c.x,\n              _ = c.x * f.y - f.x * c.y,\n              p = g.y - v.y,\n              m = v.x - g.x,\n              k = g.x * v.y - v.x * g.y;\n            this.x = d * k - m * _, this.y = p * _ - y * k, this.w = y * m - p * d;\n          }\n        }\n      }]);\n    }(),\n    qn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"area\",\n        value: function () {\n          return t.area(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"signedArea\",\n        value: function () {\n          return t.signedArea(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"interpolateZ\",\n        value: function (e) {\n          if (null === e) throw new m(\"Supplied point is null.\");\n          return t.interpolateZ(e, this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"longestSideLength\",\n        value: function () {\n          return t.longestSideLength(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"isAcute\",\n        value: function () {\n          return t.isAcute(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"circumcentre\",\n        value: function () {\n          return t.circumcentre(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"area3D\",\n        value: function () {\n          return t.area3D(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"centroid\",\n        value: function () {\n          return t.centroid(this.p0, this.p1, this.p2);\n        }\n      }, {\n        key: \"inCentre\",\n        value: function () {\n          return t.inCentre(this.p0, this.p1, this.p2);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.p0 = null, this.p1 = null, this.p2 = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this.p0 = t, this.p1 = e, this.p2 = n;\n        }\n      }, {\n        key: \"area\",\n        value: function (t, e, n) {\n          return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);\n        }\n      }, {\n        key: \"signedArea\",\n        value: function (t, e, n) {\n          return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;\n        }\n      }, {\n        key: \"det\",\n        value: function (t, e, n, i) {\n          return t * i - e * n;\n        }\n      }, {\n        key: \"interpolateZ\",\n        value: function (t, e, n, i) {\n          var r = e.x,\n            s = e.y,\n            a = n.x - r,\n            o = i.x - r,\n            u = n.y - s,\n            l = i.y - s,\n            h = a * l - o * u,\n            c = t.x - r,\n            f = t.y - s,\n            g = (l * c - o * f) / h,\n            v = (-u * c + a * f) / h;\n          return e.getZ() + g * (n.getZ() - e.getZ()) + v * (i.getZ() - e.getZ());\n        }\n      }, {\n        key: \"longestSideLength\",\n        value: function (t, e, n) {\n          var i = t.distance(e),\n            r = e.distance(n),\n            s = n.distance(t),\n            a = i;\n          return r > a && (a = r), s > a && (a = s), a;\n        }\n      }, {\n        key: \"circumcentreDD\",\n        value: function (t, e, n) {\n          var i = ut.valueOf(t.x).subtract(n.x),\n            r = ut.valueOf(t.y).subtract(n.y),\n            s = ut.valueOf(e.x).subtract(n.x),\n            a = ut.valueOf(e.y).subtract(n.y),\n            o = ut.determinant(i, r, s, a).multiply(2),\n            u = i.sqr().add(r.sqr()),\n            l = s.sqr().add(a.sqr()),\n            h = ut.determinant(r, u, a, l),\n            c = ut.determinant(i, u, s, l),\n            f = ut.valueOf(n.x).subtract(h.divide(o)).doubleValue(),\n            g = ut.valueOf(n.y).add(c.divide(o)).doubleValue();\n          return new X(f, g);\n        }\n      }, {\n        key: \"isAcute\",\n        value: function (t, e, n) {\n          return !!bn.isAcute(t, e, n) && !!bn.isAcute(e, n, t) && !!bn.isAcute(n, t, e);\n        }\n      }, {\n        key: \"circumcentre\",\n        value: function (e, n, i) {\n          var r = i.x,\n            s = i.y,\n            a = e.x - r,\n            o = e.y - s,\n            u = n.x - r,\n            l = n.y - s,\n            h = 2 * t.det(a, o, u, l),\n            c = t.det(o, a * a + o * o, l, u * u + l * l),\n            f = t.det(a, a * a + o * o, u, u * u + l * l);\n          return new X(r - c / h, s + f / h);\n        }\n      }, {\n        key: \"perpendicularBisector\",\n        value: function (t, e) {\n          var n = e.x - t.x,\n            i = e.y - t.y,\n            r = new Gn(t.x + n / 2, t.y + i / 2, 1),\n            s = new Gn(t.x - i + n / 2, t.y + n + i / 2, 1);\n          return new Gn(r, s);\n        }\n      }, {\n        key: \"angleBisector\",\n        value: function (t, e, n) {\n          var i = e.distance(t),\n            r = i / (i + e.distance(n)),\n            s = n.x - t.x,\n            a = n.y - t.y;\n          return new X(t.x + r * s, t.y + r * a);\n        }\n      }, {\n        key: \"area3D\",\n        value: function (t, e, n) {\n          var i = e.x - t.x,\n            r = e.y - t.y,\n            s = e.getZ() - t.getZ(),\n            a = n.x - t.x,\n            o = n.y - t.y,\n            u = n.getZ() - t.getZ(),\n            l = r * u - s * o,\n            h = s * a - i * u,\n            c = i * o - r * a,\n            f = l * l + h * h + c * c,\n            g = Math.sqrt(f) / 2;\n          return g;\n        }\n      }, {\n        key: \"centroid\",\n        value: function (t, e, n) {\n          var i = (t.x + e.x + n.x) / 3,\n            r = (t.y + e.y + n.y) / 3;\n          return new X(i, r);\n        }\n      }, {\n        key: \"inCentre\",\n        value: function (t, e, n) {\n          var i = e.distance(n),\n            r = t.distance(n),\n            s = t.distance(e),\n            a = i + r + s,\n            o = (i * t.x + r * e.x + s * n.x) / a,\n            u = (i * t.y + r * e.y + s * n.y) / a;\n          return new X(o, u);\n        }\n      }]);\n    }(),\n    Yn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"addRingSide\",\n        value: function (t, e, n, i, r) {\n          if (0 === e && t.length < Xt.MINIMUM_VALID_SIZE) return null;\n          var s = i,\n            a = r;\n          t.length >= Xt.MINIMUM_VALID_SIZE && ct.isCCW(t) && (s = r, a = i, n = $.opposite(n));\n          var o = this._curveBuilder.getRingCurve(t, n, e);\n          this.addCurve(o, s, a);\n        }\n      }, {\n        key: \"addRingBothSides\",\n        value: function (t, e) {\n          this.addRingSide(t, e, $.LEFT, H.EXTERIOR, H.INTERIOR), this.addRingSide(t, e, $.RIGHT, H.INTERIOR, H.EXTERIOR);\n        }\n      }, {\n        key: \"addPoint\",\n        value: function (t) {\n          if (this._distance <= 0) return null;\n          var e = t.getCoordinates(),\n            n = this._curveBuilder.getLineCurve(e, this._distance);\n          this.addCurve(n, H.EXTERIOR, H.INTERIOR);\n        }\n      }, {\n        key: \"addPolygon\",\n        value: function (t) {\n          var e = this._distance,\n            n = $.LEFT;\n          this._distance < 0 && (e = -this._distance, n = $.RIGHT);\n          var i = t.getExteriorRing(),\n            r = jt.removeRepeatedPoints(i.getCoordinates());\n          if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null;\n          if (this._distance <= 0 && r.length < 3) return null;\n          this.addRingSide(r, e, n, H.EXTERIOR, H.INTERIOR);\n          for (var s = 0; s < t.getNumInteriorRing(); s++) {\n            var a = t.getInteriorRingN(s),\n              o = jt.removeRepeatedPoints(a.getCoordinates());\n            this._distance > 0 && this.isErodedCompletely(a, -this._distance) || this.addRingSide(o, e, $.opposite(n), H.INTERIOR, H.EXTERIOR);\n          }\n        }\n      }, {\n        key: \"isTriangleErodedCompletely\",\n        value: function (t, e) {\n          var n = new qn(t[0], t[1], t[2]),\n            i = n.inCentre();\n          return xt.pointToSegment(i, n.p0, n.p1) < Math.abs(e);\n        }\n      }, {\n        key: \"addLineString\",\n        value: function (t) {\n          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;\n          var e = jt.removeRepeatedPoints(t.getCoordinates());\n          if (jt.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance);else {\n            var n = this._curveBuilder.getLineCurve(e, this._distance);\n            this.addCurve(n, H.EXTERIOR, H.INTERIOR);\n          }\n        }\n      }, {\n        key: \"addCurve\",\n        value: function (t, e, n) {\n          if (null === t || t.length < 2) return null;\n          var i = new xn(t, new Ae(0, H.BOUNDARY, e, n));\n          this._curveList.add(i);\n        }\n      }, {\n        key: \"getCurves\",\n        value: function () {\n          return this.add(this._inputGeom), this._curveList;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          if (t.isEmpty()) return null;\n          if (t instanceof Dt) this.addPolygon(t);else if (t instanceof wt) this.addLineString(t);else if (t instanceof bt) this.addPoint(t);else if (t instanceof zt) this.addCollection(t);else if (t instanceof se) this.addCollection(t);else if (t instanceof te) this.addCollection(t);else {\n            if (!(t instanceof Yt)) throw new W(t.getGeometryType());\n            this.addCollection(t);\n          }\n        }\n      }, {\n        key: \"isErodedCompletely\",\n        value: function (t, e) {\n          var n = t.getCoordinates();\n          if (n.length < 4) return e < 0;\n          if (4 === n.length) return this.isTriangleErodedCompletely(n, e);\n          var i = t.getEnvelopeInternal(),\n            r = Math.min(i.getHeight(), i.getWidth());\n          return e < 0 && 2 * Math.abs(e) > r;\n        }\n      }, {\n        key: \"addCollection\",\n        value: function (t) {\n          for (var e = 0; e < t.getNumGeometries(); e++) {\n            var n = t.getGeometryN(e);\n            this.add(n);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new yt();\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this._inputGeom = t, this._distance = e, this._curveBuilder = n;\n        }\n      }]);\n    }(),\n    zn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"locate\",\n        value: function (t) {}\n      }]);\n    }(),\n    Xn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"next\",\n        value: function () {\n          if (this._atStart) return this._atStart = !1, t.isAtomic(this._parent) && this._index++, this._parent;\n          if (null !== this._subcollectionIterator) {\n            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();\n            this._subcollectionIterator = null;\n          }\n          if (this._index >= this._max) throw new j();\n          var e = this._parent.getGeometryN(this._index++);\n          return e instanceof Yt ? (this._subcollectionIterator = new t(e), this._subcollectionIterator.next()) : e;\n        }\n      }, {\n        key: \"remove\",\n        value: function () {\n          throw new W(this.getClass().getName());\n        }\n      }, {\n        key: \"hasNext\",\n        value: function () {\n          if (this._atStart) return !0;\n          if (null !== this._subcollectionIterator) {\n            if (this._subcollectionIterator.hasNext()) return !0;\n            this._subcollectionIterator = null;\n          }\n          return !(this._index >= this._max);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [dn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;\n          var t = arguments[0];\n          this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();\n        }\n      }, {\n        key: \"isAtomic\",\n        value: function (t) {\n          return !(t instanceof Yt);\n        }\n      }]);\n    }(),\n    Bn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"locate\",\n        value: function (e) {\n          return t.locate(e, this._geom);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [zn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._geom = null;\n          var t = arguments[0];\n          this._geom = t;\n        }\n      }, {\n        key: \"locatePointInPolygon\",\n        value: function (e, n) {\n          if (n.isEmpty()) return H.EXTERIOR;\n          var i = n.getExteriorRing(),\n            r = t.locatePointInRing(e, i);\n          if (r !== H.INTERIOR) return r;\n          for (var s = 0; s < n.getNumInteriorRing(); s++) {\n            var a = n.getInteriorRingN(s),\n              o = t.locatePointInRing(e, a);\n            if (o === H.BOUNDARY) return H.BOUNDARY;\n            if (o === H.INTERIOR) return H.EXTERIOR;\n          }\n          return H.INTERIOR;\n        }\n      }, {\n        key: \"locatePointInRing\",\n        value: function (t, e) {\n          return e.getEnvelopeInternal().intersects(t) ? be.locateInRing(t, e.getCoordinates()) : H.EXTERIOR;\n        }\n      }, {\n        key: \"containsPointInPolygon\",\n        value: function (e, n) {\n          return H.EXTERIOR !== t.locatePointInPolygon(e, n);\n        }\n      }, {\n        key: \"locateInGeometry\",\n        value: function (e, n) {\n          if (n instanceof Dt) return t.locatePointInPolygon(e, n);\n          if (n instanceof Yt) for (var i = new Xn(n); i.hasNext();) {\n            var r = i.next();\n            if (r !== n) {\n              var s = t.locateInGeometry(e, r);\n              if (s !== H.EXTERIOR) return s;\n            }\n          }\n          return H.EXTERIOR;\n        }\n      }, {\n        key: \"isContained\",\n        value: function (e, n) {\n          return H.EXTERIOR !== t.locate(e, n);\n        }\n      }, {\n        key: \"locate\",\n        value: function (e, n) {\n          return n.isEmpty() ? H.EXTERIOR : n.getEnvelopeInternal().intersects(e) ? t.locateInGeometry(e, n) : H.EXTERIOR;\n        }\n      }]);\n    }(),\n    Un = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getNextCW\",\n        value: function (t) {\n          this.getEdges();\n          var e = this._edgeList.indexOf(t),\n            n = e - 1;\n          return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);\n        }\n      }, {\n        key: \"propagateSideLabels\",\n        value: function (t) {\n          for (var e = H.NONE, n = this.iterator(); n.hasNext();) {\n            var i = n.next().getLabel();\n            i.isArea(t) && i.getLocation(t, $.LEFT) !== H.NONE && (e = i.getLocation(t, $.LEFT));\n          }\n          if (e === H.NONE) return null;\n          for (var r = e, s = this.iterator(); s.hasNext();) {\n            var a = s.next(),\n              o = a.getLabel();\n            if (o.getLocation(t, $.ON) === H.NONE && o.setLocation(t, $.ON, r), o.isArea(t)) {\n              var u = o.getLocation(t, $.LEFT),\n                l = o.getLocation(t, $.RIGHT);\n              if (l !== H.NONE) {\n                if (l !== r) throw new gt(\"side location conflict\", a.getCoordinate());\n                u === H.NONE && G.shouldNeverReachHere(\"found single null side (at \" + a.getCoordinate() + \")\"), r = u;\n              } else G.isTrue(o.getLocation(t, $.LEFT) === H.NONE, \"found single null side\"), o.setLocation(t, $.RIGHT, r), o.setLocation(t, $.LEFT, r);\n            }\n          }\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          var t = this.iterator();\n          return t.hasNext() ? t.next().getCoordinate() : null;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          mt.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"isAreaLabelsConsistent\",\n        value: function (t) {\n          return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);\n        }\n      }, {\n        key: \"checkAreaLabelsConsistent\",\n        value: function (t) {\n          var e = this.getEdges();\n          if (e.size() <= 0) return !0;\n          var n = e.size() - 1,\n            i = e.get(n).getLabel().getLocation(t, $.LEFT);\n          G.isTrue(i !== H.NONE, \"Found unlabelled area edge\");\n          for (var r = i, s = this.iterator(); s.hasNext();) {\n            var a = s.next().getLabel();\n            G.isTrue(a.isArea(t), \"Found non-area edge\");\n            var o = a.getLocation(t, $.LEFT),\n              u = a.getLocation(t, $.RIGHT);\n            if (o === u) return !1;\n            if (u !== r) return !1;\n            r = o;\n          }\n          return !0;\n        }\n      }, {\n        key: \"findIndex\",\n        value: function (t) {\n          this.iterator();\n          for (var e = 0; e < this._edgeList.size(); e++) {\n            if (this._edgeList.get(e) === t) return e;\n          }\n          return -1;\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this.getEdges().iterator();\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return null === this._edgeList && (this._edgeList = new yt(this._edgeMap.values())), this._edgeList;\n        }\n      }, {\n        key: \"getLocation\",\n        value: function (t, e, n) {\n          return this._ptInAreaLocation[t] === H.NONE && (this._ptInAreaLocation[t] = Bn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new st();\n          t.append(\"EdgeEndStar:   \" + this.getCoordinate()), t.append(\"\\n\");\n          for (var e = this.iterator(); e.hasNext();) {\n            var n = e.next();\n            t.append(n), t.append(\"\\n\");\n          }\n          return t.toString();\n        }\n      }, {\n        key: \"computeEdgeEndLabels\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().computeLabel(t);\n          }\n        }\n      }, {\n        key: \"computeLabelling\",\n        value: function (t) {\n          this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);\n          for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var i = n.next().getLabel(), r = 0; r < 2; r++) i.isLine(r) && i.getLocation(r) === H.BOUNDARY && (e[r] = !0);\n          for (var s = this.iterator(); s.hasNext();) for (var a = s.next(), o = a.getLabel(), u = 0; u < 2; u++) if (o.isAnyNull(u)) {\n            var l = H.NONE;\n            if (e[u]) l = H.EXTERIOR;else {\n              var h = a.getCoordinate();\n              l = this.getLocation(u, h, t);\n            }\n            o.setAllLocationsIfNull(u, l);\n          }\n        }\n      }, {\n        key: \"getDegree\",\n        value: function () {\n          return this._edgeMap.size();\n        }\n      }, {\n        key: \"insertEdgeEnd\",\n        value: function (t, e) {\n          this._edgeMap.put(t, e), this._edgeList = null;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._edgeMap = new He(), this._edgeList = null, this._ptInAreaLocation = [H.NONE, H.NONE];\n        }\n      }]);\n    }(),\n    Vn = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"linkResultDirectedEdges\",\n        value: function () {\n          this.getResultAreaEdges();\n          for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {\n            var r = this._resultAreaEdgeList.get(i),\n              s = r.getSym();\n            if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {\n              case this._SCANNING_FOR_INCOMING:\n                if (!s.isInResult()) continue;\n                e = s, n = this._LINKING_TO_OUTGOING;\n                break;\n              case this._LINKING_TO_OUTGOING:\n                if (!r.isInResult()) continue;\n                e.setNext(r), n = this._SCANNING_FOR_INCOMING;\n            }\n          }\n          if (n === this._LINKING_TO_OUTGOING) {\n            if (null === t) throw new gt(\"no outgoing dirEdge found\", this.getCoordinate());\n            G.isTrue(t.isInResult(), \"unable to link last incoming dirEdge\"), e.setNext(t);\n          }\n        }\n      }, {\n        key: \"insert\",\n        value: function (t) {\n          var e = t;\n          this.insertEdgeEnd(e, e);\n        }\n      }, {\n        key: \"getRightmostEdge\",\n        value: function () {\n          var t = this.getEdges(),\n            e = t.size();\n          if (e < 1) return null;\n          var n = t.get(0);\n          if (1 === e) return n;\n          var i = t.get(e - 1),\n            r = n.getQuadrant(),\n            s = i.getQuadrant();\n          return je.isNorthern(r) && je.isNorthern(s) ? n : je.isNorthern(r) || je.isNorthern(s) ? 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (G.shouldNeverReachHere(\"found two horizontal edges incident on node\"), null) : i;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          mt.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n          for (var e = this.iterator(); e.hasNext();) {\n            var n = e.next();\n            t.print(\"out \"), n.print(t), t.println(), t.print(\"in \"), n.getSym().print(t), t.println();\n          }\n        }\n      }, {\n        key: \"getResultAreaEdges\",\n        value: function () {\n          if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;\n          this._resultAreaEdgeList = new yt();\n          for (var t = this.iterator(); t.hasNext();) {\n            var e = t.next();\n            (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e);\n          }\n          return this._resultAreaEdgeList;\n        }\n      }, {\n        key: \"updateLabelling\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            var n = e.next().getLabel();\n            n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1));\n          }\n        }\n      }, {\n        key: \"linkAllDirectedEdges\",\n        value: function () {\n          this.getEdges();\n          for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {\n            var i = this._edgeList.get(n),\n              r = i.getSym();\n            null === e && (e = r), null !== t && r.setNext(t), t = i;\n          }\n          e.setNext(t);\n        }\n      }, {\n        key: \"computeDepths\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0],\n              e = this.findIndex(t),\n              n = t.getDepth($.LEFT),\n              i = t.getDepth($.RIGHT),\n              r = this.computeDepths(e + 1, this._edgeList.size(), n);\n            if (this.computeDepths(0, e, r) !== i) throw new gt(\"depth mismatch at \" + t.getCoordinate());\n          } else if (3 === arguments.length) {\n            for (var s = arguments[1], a = arguments[2], o = arguments[0]; o < s; o++) {\n              var u = this._edgeList.get(o);\n              u.setEdgeDepths($.RIGHT, a), a = u.getDepth($.LEFT);\n            }\n            return a;\n          }\n        }\n      }, {\n        key: \"mergeSymLabels\",\n        value: function () {\n          for (var t = this.iterator(); t.hasNext();) {\n            var e = t.next();\n            e.getLabel().merge(e.getSym().getLabel());\n          }\n        }\n      }, {\n        key: \"linkMinimalDirectedEdges\",\n        value: function (t) {\n          for (var e = null, n = null, i = this._SCANNING_FOR_INCOMING, r = this._resultAreaEdgeList.size() - 1; r >= 0; r--) {\n            var s = this._resultAreaEdgeList.get(r),\n              a = s.getSym();\n            switch (null === e && s.getEdgeRing() === t && (e = s), i) {\n              case this._SCANNING_FOR_INCOMING:\n                if (a.getEdgeRing() !== t) continue;\n                n = a, i = this._LINKING_TO_OUTGOING;\n                break;\n              case this._LINKING_TO_OUTGOING:\n                if (s.getEdgeRing() !== t) continue;\n                n.setNextMin(s), i = this._SCANNING_FOR_INCOMING;\n            }\n          }\n          i === this._LINKING_TO_OUTGOING && (G.isTrue(null !== e, \"found null for first outgoing dirEdge\"), G.isTrue(e.getEdgeRing() === t, \"unable to link last incoming dirEdge\"), n.setNextMin(e));\n        }\n      }, {\n        key: \"getOutgoingDegree\",\n        value: function () {\n          if (0 === arguments.length) {\n            for (var t = 0, e = this.iterator(); e.hasNext();) {\n              e.next().isInResult() && t++;\n            }\n            return t;\n          }\n          if (1 === arguments.length) {\n            for (var n = arguments[0], i = 0, r = this.iterator(); r.hasNext();) {\n              r.next().getEdgeRing() === n && i++;\n            }\n            return i;\n          }\n        }\n      }, {\n        key: \"getLabel\",\n        value: function () {\n          return this._label;\n        }\n      }, {\n        key: \"findCoveredLineEdges\",\n        value: function () {\n          for (var t = H.NONE, e = this.iterator(); e.hasNext();) {\n            var n = e.next(),\n              i = n.getSym();\n            if (!n.isLineEdge()) {\n              if (n.isInResult()) {\n                t = H.INTERIOR;\n                break;\n              }\n              if (i.isInResult()) {\n                t = H.EXTERIOR;\n                break;\n              }\n            }\n          }\n          if (t === H.NONE) return null;\n          for (var r = t, s = this.iterator(); s.hasNext();) {\n            var a = s.next(),\n              o = a.getSym();\n            a.isLineEdge() ? a.getEdge().setCovered(r === H.INTERIOR) : (a.isInResult() && (r = H.EXTERIOR), o.isInResult() && (r = H.INTERIOR));\n          }\n        }\n      }, {\n        key: \"computeLabelling\",\n        value: function (t) {\n          f(i, \"computeLabelling\", this, 1).call(this, t), this._label = new Ae(H.NONE);\n          for (var e = this.iterator(); e.hasNext();) for (var n = e.next().getEdge().getLabel(), r = 0; r < 2; r++) {\n            var s = n.getLocation(r);\n            s !== H.INTERIOR && s !== H.BOUNDARY || this._label.setLocation(r, H.INTERIOR);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;\n        }\n      }]);\n    }(Un),\n    Hn = function (t) {\n      function i() {\n        return n(this, i), e(this, i);\n      }\n      return l(i, t), s(i, [{\n        key: \"createNode\",\n        value: function (t) {\n          return new qe(t, new Vn());\n        }\n      }]);\n    }(Je),\n    Zn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"compareTo\",\n        value: function (e) {\n          var n = e;\n          return t.compareOriented(this._pts, this._orientation, n._pts, n._orientation);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._pts = null, this._orientation = null;\n          var e = arguments[0];\n          this._pts = e, this._orientation = t.orientation(e);\n        }\n      }, {\n        key: \"orientation\",\n        value: function (t) {\n          return 1 === jt.increasingDirection(t);\n        }\n      }, {\n        key: \"compareOriented\",\n        value: function (t, e, n, i) {\n          for (var r = e ? 1 : -1, s = i ? 1 : -1, a = e ? t.length : -1, o = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1;;) {\n            var h = t[u].compareTo(n[l]);\n            if (0 !== h) return h;\n            var c = (u += r) === a,\n              f = (l += s) === o;\n            if (c && !f) return -1;\n            if (!c && f) return 1;\n            if (c && f) return 0;\n          }\n        }\n      }]);\n    }(),\n    jn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"print\",\n        value: function (t) {\n          t.print(\"MULTILINESTRING ( \");\n          for (var e = 0; e < this._edges.size(); e++) {\n            var n = this._edges.get(e);\n            e > 0 && t.print(\",\"), t.print(\"(\");\n            for (var i = n.getCoordinates(), r = 0; r < i.length; r++) r > 0 && t.print(\",\"), t.print(i[r].x + \" \" + i[r].y);\n            t.println(\")\");\n          }\n          t.print(\")  \");\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) this.add(e.next());\n        }\n      }, {\n        key: \"findEdgeIndex\",\n        value: function (t) {\n          for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;\n          return -1;\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this._edges.iterator();\n        }\n      }, {\n        key: \"getEdges\",\n        value: function () {\n          return this._edges;\n        }\n      }, {\n        key: \"get\",\n        value: function (t) {\n          return this._edges.get(t);\n        }\n      }, {\n        key: \"findEqualEdge\",\n        value: function (t) {\n          var e = new Zn(t.getCoordinates());\n          return this._ocaMap.get(e);\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this._edges.add(t);\n          var e = new Zn(t.getCoordinates());\n          this._ocaMap.put(e, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._edges = new yt(), this._ocaMap = new He();\n        }\n      }]);\n    }(),\n    Wn = function () {\n      return s(function t() {\n        n(this, t);\n      }, [{\n        key: \"processIntersections\",\n        value: function (t, e, n, i) {}\n      }, {\n        key: \"isDone\",\n        value: function () {}\n      }]);\n    }(),\n    Kn = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"isTrivialIntersection\",\n        value: function (e, n, i, r) {\n          if (e === i && 1 === this._li.getIntersectionNum()) {\n            if (t.isAdjacentSegments(n, r)) return !0;\n            if (e.isClosed()) {\n              var s = e.size() - 1;\n              if (0 === n && r === s || 0 === r && n === s) return !0;\n            }\n          }\n          return !1;\n        }\n      }, {\n        key: \"getProperIntersectionPoint\",\n        value: function () {\n          return this._properIntersectionPoint;\n        }\n      }, {\n        key: \"hasProperInteriorIntersection\",\n        value: function () {\n          return this._hasProperInterior;\n        }\n      }, {\n        key: \"getLineIntersector\",\n        value: function () {\n          return this._li;\n        }\n      }, {\n        key: \"hasProperIntersection\",\n        value: function () {\n          return this._hasProper;\n        }\n      }, {\n        key: \"processIntersections\",\n        value: function (t, e, n, i) {\n          if (t === n && e === i) return null;\n          this.numTests++;\n          var r = t.getCoordinates()[e],\n            s = t.getCoordinates()[e + 1],\n            a = n.getCoordinates()[i],\n            o = n.getCoordinates()[i + 1];\n          this._li.computeIntersection(r, s, a, o), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));\n        }\n      }, {\n        key: \"hasIntersection\",\n        value: function () {\n          return this._hasIntersection;\n        }\n      }, {\n        key: \"isDone\",\n        value: function () {\n          return !1;\n        }\n      }, {\n        key: \"hasInteriorIntersection\",\n        value: function () {\n          return this._hasInterior;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Wn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;\n          var t = arguments[0];\n          this._li = t;\n        }\n      }, {\n        key: \"isAdjacentSegments\",\n        value: function (t, e) {\n          return 1 === Math.abs(t - e);\n        }\n      }]);\n    }(),\n    Jn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getSegmentIndex\",\n        value: function () {\n          return this.segmentIndex;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          return this.coord;\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.print(this.coord), t.print(\" seg # = \" + this.segmentIndex), t.println(\" dist = \" + this.dist);\n        }\n      }, {\n        key: \"compareTo\",\n        value: function (t) {\n          var e = t;\n          return this.compare(e.segmentIndex, e.dist);\n        }\n      }, {\n        key: \"isEndPoint\",\n        value: function (t) {\n          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n        }\n      }, {\n        key: \"getDistance\",\n        value: function () {\n          return this.dist;\n        }\n      }, {\n        key: \"compare\",\n        value: function (t, e) {\n          return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [x];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.coord = null, this.segmentIndex = null, this.dist = null;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this.coord = new X(t), this.segmentIndex = e, this.dist = n;\n        }\n      }]);\n    }(),\n    Qn = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"print\",\n        value: function (t) {\n          t.println(\"Intersections:\");\n          for (var e = this.iterator(); e.hasNext();) {\n            e.next().print(t);\n          }\n        }\n      }, {\n        key: \"iterator\",\n        value: function () {\n          return this._nodeMap.values().iterator();\n        }\n      }, {\n        key: \"addSplitEdges\",\n        value: function (t) {\n          this.addEndpoints();\n          for (var e = this.iterator(), n = e.next(); e.hasNext();) {\n            var i = e.next(),\n              r = this.createSplitEdge(n, i);\n            t.add(r), n = i;\n          }\n        }\n      }, {\n        key: \"addEndpoints\",\n        value: function () {\n          var t = this.edge.pts.length - 1;\n          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);\n        }\n      }, {\n        key: \"createSplitEdge\",\n        value: function (t, e) {\n          var n = e.segmentIndex - t.segmentIndex + 2,\n            i = this.edge.pts[e.segmentIndex],\n            r = e.dist > 0 || !e.coord.equals2D(i);\n          r || n--;\n          var s = new Array(n).fill(null),\n            a = 0;\n          s[a++] = new X(t.coord);\n          for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++) s[a++] = this.edge.pts[o];\n          return r && (s[a] = e.coord), new ri(s, new Ae(this.edge._label));\n        }\n      }, {\n        key: \"add\",\n        value: function (t, e, n) {\n          var i = new Jn(t, e, n),\n            r = this._nodeMap.get(i);\n          return null !== r ? r : (this._nodeMap.put(i, i), i);\n        }\n      }, {\n        key: \"isIntersection\",\n        value: function (t) {\n          for (var e = this.iterator(); e.hasNext();) {\n            if (e.next().coord.equals(t)) return !0;\n          }\n          return !1;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._nodeMap = new He(), this.edge = null;\n          var t = arguments[0];\n          this.edge = t;\n        }\n      }]);\n    }(),\n    $n = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"isIntersects\",\n        value: function () {\n          return !this.isDisjoint();\n        }\n      }, {\n        key: \"isCovers\",\n        value: function () {\n          return (t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || t.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"isCoveredBy\",\n        value: function () {\n          return (t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) || t.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY])) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;\n        }\n      }, {\n        key: \"set\",\n        value: function () {\n          if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {\n            var n = Math.trunc(e / 3),\n              i = e % 3;\n            this._matrix[n][i] = Lt.toDimensionValue(t.charAt(e));\n          } else if (3 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2];\n            this._matrix[r][s] = a;\n          }\n        }\n      }, {\n        key: \"isContains\",\n        value: function () {\n          return t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"setAtLeast\",\n        value: function () {\n          if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) {\n            var n = Math.trunc(e / 3),\n              i = e % 3;\n            this.setAtLeast(n, i, Lt.toDimensionValue(t.charAt(e)));\n          } else if (3 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2];\n            this._matrix[r][s] < a && (this._matrix[r][s] = a);\n          }\n        }\n      }, {\n        key: \"setAtLeastIfValid\",\n        value: function (t, e, n) {\n          t >= 0 && e >= 0 && this.setAtLeast(t, e, n);\n        }\n      }, {\n        key: \"isWithin\",\n        value: function () {\n          return t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE;\n        }\n      }, {\n        key: \"isTouches\",\n        value: function (e, n) {\n          return e > n ? this.isTouches(n, e) : (e === Lt.A && n === Lt.A || e === Lt.L && n === Lt.L || e === Lt.L && n === Lt.A || e === Lt.P && n === Lt.A || e === Lt.P && n === Lt.L) && this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && (t.isTrue(this._matrix[H.INTERIOR][H.BOUNDARY]) || t.isTrue(this._matrix[H.BOUNDARY][H.INTERIOR]) || t.isTrue(this._matrix[H.BOUNDARY][H.BOUNDARY]));\n        }\n      }, {\n        key: \"isOverlaps\",\n        value: function (e, n) {\n          return e === Lt.P && n === Lt.P || e === Lt.A && n === Lt.A ? t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && t.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : e === Lt.L && n === Lt.L && 1 === this._matrix[H.INTERIOR][H.INTERIOR] && t.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) && t.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]);\n        }\n      }, {\n        key: \"isEquals\",\n        value: function (e, n) {\n          return e === n && t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && this._matrix[H.INTERIOR][H.EXTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.EXTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.EXTERIOR][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          for (var t = new Jt(\"123456789\"), e = 0; e < 3; e++) for (var n = 0; n < 3; n++) t.setCharAt(3 * e + n, Lt.toDimensionSymbol(this._matrix[e][n]));\n          return t.toString();\n        }\n      }, {\n        key: \"setAll\",\n        value: function (t) {\n          for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this._matrix[e][n] = t;\n        }\n      }, {\n        key: \"get\",\n        value: function (t, e) {\n          return this._matrix[t][e];\n        }\n      }, {\n        key: \"transpose\",\n        value: function () {\n          var t = this._matrix[1][0];\n          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this;\n        }\n      }, {\n        key: \"matches\",\n        value: function (e) {\n          if (9 !== e.length) throw new m(\"Should be length 9: \" + e);\n          for (var n = 0; n < 3; n++) for (var i = 0; i < 3; i++) if (!t.matches(this._matrix[n][i], e.charAt(3 * n + i))) return !1;\n          return !0;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n));\n        }\n      }, {\n        key: \"isDisjoint\",\n        value: function () {\n          return this._matrix[H.INTERIOR][H.INTERIOR] === Lt.FALSE && this._matrix[H.INTERIOR][H.BOUNDARY] === Lt.FALSE && this._matrix[H.BOUNDARY][H.INTERIOR] === Lt.FALSE && this._matrix[H.BOUNDARY][H.BOUNDARY] === Lt.FALSE;\n        }\n      }, {\n        key: \"isCrosses\",\n        value: function (e, n) {\n          return e === Lt.P && n === Lt.L || e === Lt.P && n === Lt.A || e === Lt.L && n === Lt.A ? t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t.isTrue(this._matrix[H.INTERIOR][H.EXTERIOR]) : e === Lt.L && n === Lt.P || e === Lt.A && n === Lt.P || e === Lt.A && n === Lt.L ? t.isTrue(this._matrix[H.INTERIOR][H.INTERIOR]) && t.isTrue(this._matrix[H.EXTERIOR][H.INTERIOR]) : e === Lt.L && n === Lt.L && 0 === this._matrix[H.INTERIOR][H.INTERIOR];\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [I];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map(function () {\n            return Array(3);\n          }), this.setAll(Lt.FALSE);else if (1 === arguments.length) if (\"string\" == typeof arguments[0]) {\n            var e = arguments[0];\n            t.constructor_.call(this), this.set(e);\n          } else if (arguments[0] instanceof t) {\n            var n = arguments[0];\n            t.constructor_.call(this), this._matrix[H.INTERIOR][H.INTERIOR] = n._matrix[H.INTERIOR][H.INTERIOR], this._matrix[H.INTERIOR][H.BOUNDARY] = n._matrix[H.INTERIOR][H.BOUNDARY], this._matrix[H.INTERIOR][H.EXTERIOR] = n._matrix[H.INTERIOR][H.EXTERIOR], this._matrix[H.BOUNDARY][H.INTERIOR] = n._matrix[H.BOUNDARY][H.INTERIOR], this._matrix[H.BOUNDARY][H.BOUNDARY] = n._matrix[H.BOUNDARY][H.BOUNDARY], this._matrix[H.BOUNDARY][H.EXTERIOR] = n._matrix[H.BOUNDARY][H.EXTERIOR], this._matrix[H.EXTERIOR][H.INTERIOR] = n._matrix[H.EXTERIOR][H.INTERIOR], this._matrix[H.EXTERIOR][H.BOUNDARY] = n._matrix[H.EXTERIOR][H.BOUNDARY], this._matrix[H.EXTERIOR][H.EXTERIOR] = n._matrix[H.EXTERIOR][H.EXTERIOR];\n          }\n        }\n      }, {\n        key: \"matches\",\n        value: function () {\n          if (Number.isInteger(arguments[0]) && \"string\" == typeof arguments[1]) {\n            var e = arguments[0],\n              n = arguments[1];\n            return n === Lt.SYM_DONTCARE || n === Lt.SYM_TRUE && (e >= 0 || e === Lt.TRUE) || n === Lt.SYM_FALSE && e === Lt.FALSE || n === Lt.SYM_P && e === Lt.P || n === Lt.SYM_L && e === Lt.L || n === Lt.SYM_A && e === Lt.A;\n          }\n          if (\"string\" == typeof arguments[0] && \"string\" == typeof arguments[1]) {\n            var i = arguments[1];\n            return new t(arguments[0]).matches(i);\n          }\n        }\n      }, {\n        key: \"isTrue\",\n        value: function (t) {\n          return t >= 0 || t === Lt.TRUE;\n        }\n      }]);\n    }(),\n    ti = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"size\",\n        value: function () {\n          return this._size;\n        }\n      }, {\n        key: \"addAll\",\n        value: function (t) {\n          return null === t || 0 === t.length ? null : (this.ensureCapacity(this._size + t.length), mt.arraycopy(t, 0, this._data, this._size, t.length), void (this._size += t.length));\n        }\n      }, {\n        key: \"ensureCapacity\",\n        value: function (t) {\n          if (t <= this._data.length) return null;\n          var e = Math.max(t, 2 * this._data.length);\n          this._data = At.copyOf(this._data, e);\n        }\n      }, {\n        key: \"toArray\",\n        value: function () {\n          var t = new Array(this._size).fill(null);\n          return mt.arraycopy(this._data, 0, t, 0, this._size), t;\n        }\n      }, {\n        key: \"add\",\n        value: function (t) {\n          this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._data = null, this._size = 0, 0 === arguments.length) t.constructor_.call(this, 10);else if (1 === arguments.length) {\n            var e = arguments[0];\n            this._data = new Array(e).fill(null);\n          }\n        }\n      }]);\n    }(),\n    ei = function () {\n      function t() {\n        n(this, t);\n      }\n      return s(t, [{\n        key: \"getChainStartIndices\",\n        value: function (t) {\n          var e = 0,\n            n = new ti(Math.trunc(t.length / 2));\n          n.add(e);\n          do {\n            var i = this.findChainEnd(t, e);\n            n.add(i), e = i;\n          } while (e < t.length - 1);\n          return n.toArray();\n        }\n      }, {\n        key: \"findChainEnd\",\n        value: function (t, e) {\n          for (var n = je.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {\n            if (je.quadrant(t[i - 1], t[i]) !== n) break;\n            i++;\n          }\n          return i - 1;\n        }\n      }, {\n        key: \"OLDgetChainStartIndices\",\n        value: function (e) {\n          var n = 0,\n            i = new yt();\n          i.add(n);\n          do {\n            var r = this.findChainEnd(e, n);\n            i.add(r), n = r;\n          } while (n < e.length - 1);\n          return t.toIntArray(i);\n        }\n      }], [{\n        key: \"toIntArray\",\n        value: function (t) {\n          for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();\n          return e;\n        }\n      }]);\n    }(),\n    ni = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"getCoordinates\",\n        value: function () {\n          return this.pts;\n        }\n      }, {\n        key: \"getMaxX\",\n        value: function (t) {\n          var e = this.pts[this.startIndex[t]].x,\n            n = this.pts[this.startIndex[t + 1]].x;\n          return e > n ? e : n;\n        }\n      }, {\n        key: \"getMinX\",\n        value: function (t) {\n          var e = this.pts[this.startIndex[t]].x,\n            n = this.pts[this.startIndex[t + 1]].x;\n          return e < n ? e : n;\n        }\n      }, {\n        key: \"computeIntersectsForChain\",\n        value: function () {\n          if (4 === arguments.length) {\n            var t = arguments[0],\n              e = arguments[1],\n              n = arguments[2],\n              i = arguments[3];\n            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);\n          } else if (6 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1],\n              a = arguments[2],\n              o = arguments[3],\n              u = arguments[4],\n              l = arguments[5];\n            if (s - r == 1 && u - o == 1) return l.addIntersections(this.e, r, a.e, o), null;\n            if (!this.overlaps(r, s, a, o, u)) return null;\n            var h = Math.trunc((r + s) / 2),\n              c = Math.trunc((o + u) / 2);\n            r < h && (o < c && this.computeIntersectsForChain(r, h, a, o, c, l), c < u && this.computeIntersectsForChain(r, h, a, c, u, l)), h < s && (o < c && this.computeIntersectsForChain(h, s, a, o, c, l), c < u && this.computeIntersectsForChain(h, s, a, c, u, l));\n          }\n        }\n      }, {\n        key: \"overlaps\",\n        value: function (t, e, n, i, r) {\n          return U.intersects(this.pts[t], this.pts[e], n.pts[i], n.pts[r]);\n        }\n      }, {\n        key: \"getStartIndexes\",\n        value: function () {\n          return this.startIndex;\n        }\n      }, {\n        key: \"computeIntersects\",\n        value: function (t, e) {\n          for (var n = 0; n < this.startIndex.length - 1; n++) for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.e = null, this.pts = null, this.startIndex = null;\n          var t = arguments[0];\n          this.e = t, this.pts = t.getCoordinates();\n          var e = new ei();\n          this.startIndex = e.getChainStartIndices(this.pts);\n        }\n      }]);\n    }(),\n    ii = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"getDepth\",\n        value: function (t, e) {\n          return this._depth[t][e];\n        }\n      }, {\n        key: \"setDepth\",\n        value: function (t, e, n) {\n          this._depth[t][e] = n;\n        }\n      }, {\n        key: \"isNull\",\n        value: function () {\n          if (0 === arguments.length) {\n            for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) if (this._depth[e][n] !== t.NULL_VALUE) return !1;\n            return !0;\n          }\n          if (1 === arguments.length) {\n            var i = arguments[0];\n            return this._depth[i][1] === t.NULL_VALUE;\n          }\n          if (2 === arguments.length) {\n            var r = arguments[0],\n              s = arguments[1];\n            return this._depth[r][s] === t.NULL_VALUE;\n          }\n        }\n      }, {\n        key: \"normalize\",\n        value: function () {\n          for (var t = 0; t < 2; t++) if (!this.isNull(t)) {\n            var e = this._depth[t][1];\n            this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);\n            for (var n = 1; n < 3; n++) {\n              var i = 0;\n              this._depth[t][n] > e && (i = 1), this._depth[t][n] = i;\n            }\n          }\n        }\n      }, {\n        key: \"getDelta\",\n        value: function (t) {\n          return this._depth[t][$.RIGHT] - this._depth[t][$.LEFT];\n        }\n      }, {\n        key: \"getLocation\",\n        value: function (t, e) {\n          return this._depth[t][e] <= 0 ? H.EXTERIOR : H.INTERIOR;\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          return \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n        }\n      }, {\n        key: \"add\",\n        value: function () {\n          if (1 === arguments.length) for (var e = arguments[0], n = 0; n < 2; n++) for (var i = 1; i < 3; i++) {\n            var r = e.getLocation(n, i);\n            r !== H.EXTERIOR && r !== H.INTERIOR || (this.isNull(n, i) ? this._depth[n][i] = t.depthAtLocation(r) : this._depth[n][i] += t.depthAtLocation(r));\n          } else if (3 === arguments.length) {\n            var s = arguments[0],\n              a = arguments[1];\n            arguments[2] === H.INTERIOR && this._depth[s][a]++;\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._depth = Array(2).fill().map(function () {\n            return Array(3);\n          });\n          for (var e = 0; e < 2; e++) for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE;\n        }\n      }, {\n        key: \"depthAtLocation\",\n        value: function (e) {\n          return e === H.EXTERIOR ? 0 : e === H.INTERIOR ? 1 : t.NULL_VALUE;\n        }\n      }]);\n    }();\n  ii.NULL_VALUE = -1;\n  var ri = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"getDepth\",\n        value: function () {\n          return this._depth;\n        }\n      }, {\n        key: \"getCollapsedEdge\",\n        value: function () {\n          var t = new Array(2).fill(null);\n          return t[0] = this.pts[0], t[1] = this.pts[1], new i(t, Ae.toLineLabel(this._label));\n        }\n      }, {\n        key: \"isIsolated\",\n        value: function () {\n          return this._isIsolated;\n        }\n      }, {\n        key: \"getCoordinates\",\n        value: function () {\n          return this.pts;\n        }\n      }, {\n        key: \"setIsolated\",\n        value: function (t) {\n          this._isIsolated = t;\n        }\n      }, {\n        key: \"setName\",\n        value: function (t) {\n          this._name = t;\n        }\n      }, {\n        key: \"equals\",\n        value: function (t) {\n          if (!(t instanceof i)) return !1;\n          var e = t;\n          if (this.pts.length !== e.pts.length) return !1;\n          for (var n = !0, r = !0, s = this.pts.length, a = 0; a < this.pts.length; a++) if (this.pts[a].equals2D(e.pts[a]) || (n = !1), this.pts[a].equals2D(e.pts[--s]) || (r = !1), !n && !r) return !1;\n          return !0;\n        }\n      }, {\n        key: \"getCoordinate\",\n        value: function () {\n          if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.pts[t];\n          }\n        }\n      }, {\n        key: \"print\",\n        value: function (t) {\n          t.print(\"edge \" + this._name + \": \"), t.print(\"LINESTRING (\");\n          for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(\",\"), t.print(this.pts[e].x + \" \" + this.pts[e].y);\n          t.print(\")  \" + this._label + \" \" + this._depthDelta);\n        }\n      }, {\n        key: \"computeIM\",\n        value: function (t) {\n          i.updateIM(this._label, t);\n        }\n      }, {\n        key: \"isCollapsed\",\n        value: function () {\n          return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this.pts[0].equals(this.pts[this.pts.length - 1]);\n        }\n      }, {\n        key: \"getMaximumSegmentIndex\",\n        value: function () {\n          return this.pts.length - 1;\n        }\n      }, {\n        key: \"getDepthDelta\",\n        value: function () {\n          return this._depthDelta;\n        }\n      }, {\n        key: \"getNumPoints\",\n        value: function () {\n          return this.pts.length;\n        }\n      }, {\n        key: \"printReverse\",\n        value: function (t) {\n          t.print(\"edge \" + this._name + \": \");\n          for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + \" \");\n          t.println(\"\");\n        }\n      }, {\n        key: \"getMonotoneChainEdge\",\n        value: function () {\n          return null === this._mce && (this._mce = new ni(this)), this._mce;\n        }\n      }, {\n        key: \"getEnvelope\",\n        value: function () {\n          if (null === this._env) {\n            this._env = new U();\n            for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]);\n          }\n          return this._env;\n        }\n      }, {\n        key: \"addIntersection\",\n        value: function (t, e, n, i) {\n          var r = new X(t.getIntersection(i)),\n            s = e,\n            a = t.getEdgeDistance(n, i),\n            o = s + 1;\n          if (o < this.pts.length) {\n            var u = this.pts[o];\n            r.equals2D(u) && (s = o, a = 0);\n          }\n          this.eiList.add(r, s, a);\n        }\n      }, {\n        key: \"toString\",\n        value: function () {\n          var t = new Jt();\n          t.append(\"edge \" + this._name + \": \"), t.append(\"LINESTRING (\");\n          for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(\",\"), t.append(this.pts[e].x + \" \" + this.pts[e].y);\n          return t.append(\")  \" + this._label + \" \" + this._depthDelta), t.toString();\n        }\n      }, {\n        key: \"isPointwiseEqual\",\n        value: function (t) {\n          if (this.pts.length !== t.pts.length) return !1;\n          for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;\n          return !0;\n        }\n      }, {\n        key: \"setDepthDelta\",\n        value: function (t) {\n          this._depthDelta = t;\n        }\n      }, {\n        key: \"getEdgeIntersectionList\",\n        value: function () {\n          return this.eiList;\n        }\n      }, {\n        key: \"addIntersections\",\n        value: function (t, e, n) {\n          for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new ii(), this._depthDelta = 0, 1 === arguments.length) {\n            var t = arguments[0];\n            i.constructor_.call(this, t, null);\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this.pts = e, this._label = n;\n          }\n        }\n      }, {\n        key: \"updateIM\",\n        value: function () {\n          if (!(2 === arguments.length && arguments[1] instanceof $n && arguments[0] instanceof Ae)) return f(i, \"updateIM\", this).apply(this, arguments);\n          var t = arguments[0],\n            e = arguments[1];\n          e.setAtLeastIfValid(t.getLocation(0, $.ON), t.getLocation(1, $.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, $.LEFT), t.getLocation(1, $.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, $.RIGHT), t.getLocation(1, $.RIGHT), 2));\n        }\n      }]);\n    }(Ge),\n    si = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"setWorkingPrecisionModel\",\n        value: function (t) {\n          this._workingPrecisionModel = t;\n        }\n      }, {\n        key: \"insertUniqueEdge\",\n        value: function (e) {\n          var n = this._edgeList.findEqualEdge(e);\n          if (null !== n) {\n            var i = n.getLabel(),\n              r = e.getLabel();\n            n.isPointwiseEqual(e) || (r = new Ae(e.getLabel())).flip(), i.merge(r);\n            var s = t.depthDelta(r),\n              a = n.getDepthDelta() + s;\n            n.setDepthDelta(a);\n          } else this._edgeList.add(e), e.setDepthDelta(t.depthDelta(e.getLabel()));\n        }\n      }, {\n        key: \"buildSubgraphs\",\n        value: function (t, e) {\n          for (var n = new yt(), i = t.iterator(); i.hasNext();) {\n            var r = i.next(),\n              s = r.getRightmostCoordinate(),\n              a = new Pn(n).getDepth(s);\n            r.computeDepth(a), r.findResultEdges(), n.add(r), e.add(r.getDirectedEdges(), r.getNodes());\n          }\n        }\n      }, {\n        key: \"createSubgraphs\",\n        value: function (t) {\n          for (var e = new yt(), n = t.getNodes().iterator(); n.hasNext();) {\n            var i = n.next();\n            if (!i.isVisited()) {\n              var r = new _t();\n              r.create(i), e.add(r);\n            }\n          }\n          return an.sort(e, an.reverseOrder()), e;\n        }\n      }, {\n        key: \"createEmptyResultGeometry\",\n        value: function () {\n          return this._geomFact.createPolygon();\n        }\n      }, {\n        key: \"getNoder\",\n        value: function (t) {\n          if (null !== this._workingNoder) return this._workingNoder;\n          var e = new Cn(),\n            n = new we();\n          return n.setPrecisionModel(t), e.setSegmentIntersector(new Kn(n)), e;\n        }\n      }, {\n        key: \"buffer\",\n        value: function (t, e) {\n          var n = this._workingPrecisionModel;\n          null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();\n          var i = new An(n, this._bufParams),\n            r = new Yn(t, e, i).getCurves();\n          if (r.size() <= 0) return this.createEmptyResultGeometry();\n          this.computeNodedEdges(r, n), this._graph = new Qe(new Hn()), this._graph.addEdges(this._edgeList.getEdges());\n          var s = this.createSubgraphs(this._graph),\n            a = new $e(this._geomFact);\n          this.buildSubgraphs(s, a);\n          var o = a.getPolygons();\n          return o.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(o);\n        }\n      }, {\n        key: \"computeNodedEdges\",\n        value: function (t, e) {\n          var n = this.getNoder(e);\n          n.computeNodes(t);\n          for (var i = n.getNodedSubstrings().iterator(); i.hasNext();) {\n            var r = i.next(),\n              s = r.getCoordinates();\n            if (2 !== s.length || !s[0].equals2D(s[1])) {\n              var a = r.getData(),\n                o = new ri(r.getCoordinates(), new Ae(a));\n              this.insertUniqueEdge(o);\n            }\n          }\n        }\n      }, {\n        key: \"setNoder\",\n        value: function (t) {\n          this._workingNoder = t;\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new jn();\n          var t = arguments[0];\n          this._bufParams = t;\n        }\n      }, {\n        key: \"depthDelta\",\n        value: function (t) {\n          var e = t.getLocation(0, $.LEFT),\n            n = t.getLocation(0, $.RIGHT);\n          return e === H.INTERIOR && n === H.EXTERIOR ? 1 : e === H.EXTERIOR && n === H.INTERIOR ? -1 : 0;\n        }\n      }, {\n        key: \"convertSegStrings\",\n        value: function (t) {\n          for (var e = new ae(), n = new yt(); t.hasNext();) {\n            var i = t.next(),\n              r = e.createLineString(i.getCoordinates());\n            n.add(r);\n          }\n          return e.buildGeometry(n);\n        }\n      }]);\n    }(),\n    ai = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"rescale\",\n        value: function () {\n          if (rt(arguments[0], Z)) for (var t = arguments[0].iterator(); t.hasNext();) {\n            var e = t.next();\n            this.rescale(e.getCoordinates());\n          } else if (arguments[0] instanceof Array) {\n            for (var n = arguments[0], i = 0; i < n.length; i++) n[i].x = n[i].x / this._scaleFactor + this._offsetX, n[i].y = n[i].y / this._scaleFactor + this._offsetY;\n            2 === n.length && n[0].equals2D(n[1]) && mt.out.println(n);\n          }\n        }\n      }, {\n        key: \"scale\",\n        value: function () {\n          if (rt(arguments[0], Z)) {\n            for (var t = arguments[0], e = new yt(t.size()), n = t.iterator(); n.hasNext();) {\n              var i = n.next();\n              e.add(new xn(this.scale(i.getCoordinates()), i.getData()));\n            }\n            return e;\n          }\n          if (arguments[0] instanceof Array) {\n            for (var r = arguments[0], s = new Array(r.length).fill(null), a = 0; a < r.length; a++) s[a] = new X(Math.round((r[a].x - this._offsetX) * this._scaleFactor), Math.round((r[a].y - this._offsetY) * this._scaleFactor), r[a].getZ());\n            return jt.removeRepeatedPoints(s);\n          }\n        }\n      }, {\n        key: \"isIntegerPrecision\",\n        value: function () {\n          return 1 === this._scaleFactor;\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          var t = this._noder.getNodedSubstrings();\n          return this._isScaled && this.rescale(t), t;\n        }\n      }, {\n        key: \"computeNodes\",\n        value: function (t) {\n          var e = t;\n          this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Sn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            t.constructor_.call(this, e, n, 0, 0);\n          } else if (4 === arguments.length) {\n            var i = arguments[0],\n              r = arguments[1];\n            this._noder = i, this._scaleFactor = r, this._isScaled = !this.isIntegerPrecision();\n          }\n        }\n      }]);\n    }(),\n    oi = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"checkEndPtVertexIntersections\",\n        value: function () {\n          if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {\n            var e = t.next().getCoordinates();\n            this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings);\n          } else if (2 === arguments.length) for (var n = arguments[0], i = arguments[1].iterator(); i.hasNext();) for (var r = i.next().getCoordinates(), s = 1; s < r.length - 1; s++) if (r[s].equals(n)) throw new D(\"found endpt/interior pt intersection at index \" + s + \" :pt \" + n);\n        }\n      }, {\n        key: \"checkInteriorIntersections\",\n        value: function () {\n          if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {\n            var i = n.next();\n            this.checkInteriorIntersections(e, i);\n          } else if (2 === arguments.length) for (var r = arguments[0], s = arguments[1], a = r.getCoordinates(), o = s.getCoordinates(), u = 0; u < a.length - 1; u++) for (var l = 0; l < o.length - 1; l++) this.checkInteriorIntersections(r, u, s, l);else if (4 === arguments.length) {\n            var h = arguments[0],\n              c = arguments[1],\n              f = arguments[2],\n              g = arguments[3];\n            if (h === f && c === g) return null;\n            var v = h.getCoordinates()[c],\n              y = h.getCoordinates()[c + 1],\n              d = f.getCoordinates()[g],\n              _ = f.getCoordinates()[g + 1];\n            if (this._li.computeIntersection(v, y, d, _), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, v, y) || this.hasInteriorIntersection(this._li, d, _))) throw new D(\"found non-noded intersection at \" + v + \"-\" + y + \" and \" + d + \"-\" + _);\n          }\n        }\n      }, {\n        key: \"checkValid\",\n        value: function () {\n          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();\n        }\n      }, {\n        key: \"checkCollapses\",\n        value: function () {\n          if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) {\n            var e = t.next();\n            this.checkCollapses(e);\n          } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), i = 0; i < n.length - 2; i++) this.checkCollapse(n[i], n[i + 1], n[i + 2]);\n        }\n      }, {\n        key: \"hasInteriorIntersection\",\n        value: function (t, e, n) {\n          for (var i = 0; i < t.getIntersectionNum(); i++) {\n            var r = t.getIntersection(i);\n            if (!r.equals(e) && !r.equals(n)) return !0;\n          }\n          return !1;\n        }\n      }, {\n        key: \"checkCollapse\",\n        value: function (e, n, i) {\n          if (e.equals(i)) throw new D(\"found non-noded collapse at \" + t.fact.createLineString([e, n, i]));\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._li = new we(), this._segStrings = null;\n          var t = arguments[0];\n          this._segStrings = t;\n        }\n      }]);\n    }();\n  oi.fact = new ae();\n  var ui = function () {\n    function t() {\n      n(this, t), t.constructor_.apply(this, arguments);\n    }\n    return s(t, [{\n      key: \"intersectsScaled\",\n      value: function (t, e) {\n        var n = Math.min(t.x, e.x),\n          i = Math.max(t.x, e.x),\n          r = Math.min(t.y, e.y),\n          s = Math.max(t.y, e.y),\n          a = this._maxx < n || this._minx > i || this._maxy < r || this._miny > s;\n        if (a) return !1;\n        var o = this.intersectsToleranceSquare(t, e);\n        return G.isTrue(!(a && o), \"Found bad envelope test\"), o;\n      }\n    }, {\n      key: \"initCorners\",\n      value: function (t) {\n        var e = .5;\n        this._minx = t.x - e, this._maxx = t.x + e, this._miny = t.y - e, this._maxy = t.y + e, this._corner[0] = new X(this._maxx, this._maxy), this._corner[1] = new X(this._minx, this._maxy), this._corner[2] = new X(this._minx, this._miny), this._corner[3] = new X(this._maxx, this._miny);\n      }\n    }, {\n      key: \"intersects\",\n      value: function (t, e) {\n        return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));\n      }\n    }, {\n      key: \"scale\",\n      value: function (t) {\n        return Math.round(t * this._scaleFactor);\n      }\n    }, {\n      key: \"getCoordinate\",\n      value: function () {\n        return this._originalPt;\n      }\n    }, {\n      key: \"copyScaled\",\n      value: function (t, e) {\n        e.x = this.scale(t.x), e.y = this.scale(t.y);\n      }\n    }, {\n      key: \"getSafeEnvelope\",\n      value: function () {\n        if (null === this._safeEnv) {\n          var e = t.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n          this._safeEnv = new U(this._originalPt.x - e, this._originalPt.x + e, this._originalPt.y - e, this._originalPt.y + e);\n        }\n        return this._safeEnv;\n      }\n    }, {\n      key: \"intersectsPixelClosure\",\n      value: function (t, e) {\n        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));\n      }\n    }, {\n      key: \"intersectsToleranceSquare\",\n      value: function (t, e) {\n        var n = !1,\n          i = !1;\n        return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!n || !i) || !!t.equals(this._pt) || !!e.equals(this._pt))));\n      }\n    }, {\n      key: \"addSnappedNode\",\n      value: function (t, e) {\n        var n = t.getCoordinate(e),\n          i = t.getCoordinate(e + 1);\n        return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0);\n      }\n    }], [{\n      key: \"constructor_\",\n      value: function () {\n        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;\n        var t = arguments[0],\n          e = arguments[1],\n          n = arguments[2];\n        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new m(\"Scale factor must be non-zero\");\n        1 !== e && (this._pt = new X(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new X(), this._p1Scaled = new X()), this.initCorners(this._pt);\n      }\n    }]);\n  }();\n  ui.SAFE_ENV_EXPANSION_FACTOR = .75;\n  var li = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"select\",\n        value: function () {\n          if (1 === arguments.length) ;else if (2 === arguments.length) {\n            var t = arguments[1];\n            arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment);\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this.selectedSegment = new In();\n        }\n      }]);\n    }(),\n    hi = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"snap\",\n        value: function () {\n          if (1 === arguments.length) {\n            var t = arguments[0];\n            return this.snap(t, null, -1);\n          }\n          if (3 === arguments.length) {\n            var e = arguments[0],\n              i = arguments[1],\n              r = arguments[2],\n              a = e.getSafeEnvelope(),\n              o = new ci(e, i, r);\n            return this._index.query(a, new (function () {\n              return s(function t() {\n                n(this, t);\n              }, [{\n                key: \"interfaces_\",\n                get: function () {\n                  return [ln];\n                }\n              }, {\n                key: \"visitItem\",\n                value: function (t) {\n                  t.select(a, o);\n                }\n              }]);\n            }())()), o.isNodeAdded();\n          }\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._index = null;\n          var t = arguments[0];\n          this._index = t;\n        }\n      }]);\n    }(),\n    ci = function (t) {\n      function i() {\n        var t;\n        return n(this, i), t = e(this, i), i.constructor_.apply(t, arguments), t;\n      }\n      return l(i, t), s(i, [{\n        key: \"isNodeAdded\",\n        value: function () {\n          return this._isNodeAdded;\n        }\n      }, {\n        key: \"select\",\n        value: function () {\n          if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Nn)) return f(i, \"select\", this, 1).apply(this, arguments);\n          var t = arguments[1],\n            e = arguments[0].getContext();\n          if (this._parentEdge === e && (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)) return null;\n          this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;\n          var t = arguments[0],\n            e = arguments[1],\n            n = arguments[2];\n          this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n;\n        }\n      }]);\n    }(li);\n  hi.HotPixelSnapAction = ci;\n  var fi = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"processIntersections\",\n        value: function (t, e, n, i) {\n          if (t === n && e === i) return null;\n          var r = t.getCoordinates()[e],\n            s = t.getCoordinates()[e + 1],\n            a = n.getCoordinates()[i],\n            o = n.getCoordinates()[i + 1];\n          if (this._li.computeIntersection(r, s, a, o), this._li.hasIntersection() && this._li.isInteriorIntersection()) {\n            for (var u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u));\n            t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1);\n          }\n        }\n      }, {\n        key: \"isDone\",\n        value: function () {\n          return !1;\n        }\n      }, {\n        key: \"getInteriorIntersections\",\n        value: function () {\n          return this._interiorIntersections;\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Wn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._li = null, this._interiorIntersections = null;\n          var t = arguments[0];\n          this._li = t, this._interiorIntersections = new yt();\n        }\n      }]);\n    }(),\n    gi = function () {\n      return s(function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }, [{\n        key: \"checkCorrectness\",\n        value: function (t) {\n          var e = xn.getNodedSubstrings(t),\n            n = new oi(e);\n          try {\n            n.checkValid();\n          } catch (t) {\n            if (!(t instanceof p)) throw t;\n            t.printStackTrace();\n          }\n        }\n      }, {\n        key: \"getNodedSubstrings\",\n        value: function () {\n          return xn.getNodedSubstrings(this._nodedSegStrings);\n        }\n      }, {\n        key: \"snapRound\",\n        value: function (t, e) {\n          var n = this.findInteriorIntersections(t, e);\n          this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);\n        }\n      }, {\n        key: \"findInteriorIntersections\",\n        value: function (t, e) {\n          var n = new fi(e);\n          return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();\n        }\n      }, {\n        key: \"computeVertexSnaps\",\n        value: function () {\n          if (rt(arguments[0], Z)) for (var t = arguments[0].iterator(); t.hasNext();) {\n            var e = t.next();\n            this.computeVertexSnaps(e);\n          } else if (arguments[0] instanceof xn) for (var n = arguments[0], i = n.getCoordinates(), r = 0; r < i.length; r++) {\n            var s = new ui(i[r], this._scaleFactor, this._li);\n            this._pointSnapper.snap(s, n, r) && n.addIntersection(i[r], r);\n          }\n        }\n      }, {\n        key: \"computeNodes\",\n        value: function (t) {\n          this._nodedSegStrings = t, this._noder = new Cn(), this._pointSnapper = new hi(this._noder.getIndex()), this.snapRound(t, this._li);\n        }\n      }, {\n        key: \"computeIntersectionSnaps\",\n        value: function (t) {\n          for (var e = t.iterator(); e.hasNext();) {\n            var n = e.next(),\n              i = new ui(n, this._scaleFactor, this._li);\n            this._pointSnapper.snap(i);\n          }\n        }\n      }, {\n        key: \"interfaces_\",\n        get: function () {\n          return [Sn];\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;\n          var t = arguments[0];\n          this._pm = t, this._li = new we(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();\n        }\n      }]);\n    }(),\n    vi = function () {\n      function t() {\n        n(this, t), t.constructor_.apply(this, arguments);\n      }\n      return s(t, [{\n        key: \"bufferFixedPrecision\",\n        value: function (t) {\n          var e = new ai(new gi(new ie(1)), t.getScale()),\n            n = new si(this._bufParams);\n          n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);\n        }\n      }, {\n        key: \"bufferReducedPrecision\",\n        value: function () {\n          if (0 === arguments.length) {\n            for (var e = t.MAX_PRECISION_DIGITS; e >= 0; e--) {\n              try {\n                this.bufferReducedPrecision(e);\n              } catch (t) {\n                if (!(t instanceof gt)) throw t;\n                this._saveException = t;\n              }\n              if (null !== this._resultGeometry) return null;\n            }\n            throw this._saveException;\n          }\n          if (1 === arguments.length) {\n            var n = arguments[0],\n              i = t.precisionScaleFactor(this._argGeom, this._distance, n),\n              r = new ie(i);\n            this.bufferFixedPrecision(r);\n          }\n        }\n      }, {\n        key: \"computeGeometry\",\n        value: function () {\n          if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;\n          var t = this._argGeom.getFactory().getPrecisionModel();\n          t.getType() === ie.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();\n        }\n      }, {\n        key: \"setQuadrantSegments\",\n        value: function (t) {\n          this._bufParams.setQuadrantSegments(t);\n        }\n      }, {\n        key: \"bufferOriginalPrecision\",\n        value: function () {\n          try {\n            var t = new si(this._bufParams);\n            this._resultGeometry = t.buffer(this._argGeom, this._distance);\n          } catch (t) {\n            if (!(t instanceof D)) throw t;\n            this._saveException = t;\n          }\n        }\n      }, {\n        key: \"getResultGeometry\",\n        value: function (t) {\n          return this._distance = t, this.computeGeometry(), this._resultGeometry;\n        }\n      }, {\n        key: \"setEndCapStyle\",\n        value: function (t) {\n          this._bufParams.setEndCapStyle(t);\n        }\n      }], [{\n        key: \"constructor_\",\n        value: function () {\n          if (this._argGeom = null, this._distance = null, this._bufParams = new _(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {\n            var t = arguments[0];\n            this._argGeom = t;\n          } else if (2 === arguments.length) {\n            var e = arguments[0],\n              n = arguments[1];\n            this._argGeom = e, this._bufParams = n;\n          }\n        }\n      }, {\n        key: \"bufferOp\",\n        value: function () {\n          if (2 === arguments.length) {\n            var e = arguments[1];\n            return new t(arguments[0]).getResultGeometry(e);\n          }\n          if (3 === arguments.length) {\n            if (Number.isInteger(arguments[2]) && arguments[0] instanceof V && \"number\" == typeof arguments[1]) {\n              var n = arguments[1],\n                i = arguments[2],\n                r = new t(arguments[0]);\n              return r.setQuadrantSegments(i), r.getResultGeometry(n);\n            }\n            if (arguments[2] instanceof _ && arguments[0] instanceof V && \"number\" == typeof arguments[1]) {\n              var s = arguments[1];\n              return new t(arguments[0], arguments[2]).getResultGeometry(s);\n            }\n          } else if (4 === arguments.length) {\n            var a = arguments[1],\n              o = arguments[2],\n              u = arguments[3],\n              l = new t(arguments[0]);\n            return l.setQuadrantSegments(o), l.setEndCapStyle(u), l.getResultGeometry(a);\n          }\n        }\n      }, {\n        key: \"precisionScaleFactor\",\n        value: function (t, e, n) {\n          var i = t.getEnvelopeInternal(),\n            r = kt.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())) + 2 * (e > 0 ? e : 0),\n            s = n - Math.trunc(Math.log(r) / Math.log(10) + 1);\n          return Math.pow(10, s);\n        }\n      }]);\n    }();\n  vi.CAP_ROUND = _.CAP_ROUND, vi.CAP_BUTT = _.CAP_FLAT, vi.CAP_FLAT = _.CAP_FLAT, vi.CAP_SQUARE = _.CAP_SQUARE, vi.MAX_PRECISION_DIGITS = 12;\n  var yi = [\"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\"],\n    di = function () {\n      return s(function t(e) {\n        n(this, t), this.geometryFactory = e || new ae();\n      }, [{\n        key: \"read\",\n        value: function (t) {\n          var e,\n            n = (e = \"string\" == typeof t ? JSON.parse(t) : t).type;\n          if (!_i[n]) throw new Error(\"Unknown GeoJSON type: \" + e.type);\n          return -1 !== yi.indexOf(n) ? _i[n].call(this, e.coordinates) : \"GeometryCollection\" === n ? _i[n].call(this, e.geometries) : _i[n].call(this, e);\n        }\n      }, {\n        key: \"write\",\n        value: function (t) {\n          var e = t.getGeometryType();\n          if (!pi[e]) throw new Error(\"Geometry is not supported\");\n          return pi[e].call(this, t);\n        }\n      }]);\n    }(),\n    _i = {\n      Feature: function (t) {\n        var e = {};\n        for (var n in t) e[n] = t[n];\n        if (t.geometry) {\n          var i = t.geometry.type;\n          if (!_i[i]) throw new Error(\"Unknown GeoJSON type: \" + t.type);\n          e.geometry = this.read(t.geometry);\n        }\n        return t.bbox && (e.bbox = _i.bbox.call(this, t.bbox)), e;\n      },\n      FeatureCollection: function (t) {\n        var e = {};\n        if (t.features) {\n          e.features = [];\n          for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));\n        }\n        return t.bbox && (e.bbox = this.parse.bbox.call(this, t.bbox)), e;\n      },\n      coordinates: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var r = t[n];\n          e.push(i(X, g(r)));\n        }\n        return e;\n      },\n      bbox: function (t) {\n        return this.geometryFactory.createLinearRing([new X(t[0], t[1]), new X(t[2], t[1]), new X(t[2], t[3]), new X(t[0], t[3]), new X(t[0], t[1])]);\n      },\n      Point: function (t) {\n        var e = i(X, g(t));\n        return this.geometryFactory.createPoint(e);\n      },\n      MultiPoint: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) e.push(_i.Point.call(this, t[n]));\n        return this.geometryFactory.createMultiPoint(e);\n      },\n      LineString: function (t) {\n        var e = _i.coordinates.call(this, t);\n        return this.geometryFactory.createLineString(e);\n      },\n      MultiLineString: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) e.push(_i.LineString.call(this, t[n]));\n        return this.geometryFactory.createMultiLineString(e);\n      },\n      Polygon: function (t) {\n        for (var e = _i.coordinates.call(this, t[0]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {\n          var s = t[r],\n            a = _i.coordinates.call(this, s),\n            o = this.geometryFactory.createLinearRing(a);\n          i.push(o);\n        }\n        return this.geometryFactory.createPolygon(n, i);\n      },\n      MultiPolygon: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var i = t[n];\n          e.push(_i.Polygon.call(this, i));\n        }\n        return this.geometryFactory.createMultiPolygon(e);\n      },\n      GeometryCollection: function (t) {\n        for (var e = [], n = 0; n < t.length; ++n) {\n          var i = t[n];\n          e.push(this.read(i));\n        }\n        return this.geometryFactory.createGeometryCollection(e);\n      }\n    },\n    pi = {\n      coordinate: function (t) {\n        var e = [t.x, t.y];\n        return t.z && e.push(t.z), t.m && e.push(t.m), e;\n      },\n      Point: function (t) {\n        return {\n          type: \"Point\",\n          coordinates: pi.coordinate.call(this, t.getCoordinate())\n        };\n      },\n      MultiPoint: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = pi.Point.call(this, i);\n          e.push(r.coordinates);\n        }\n        return {\n          type: \"MultiPoint\",\n          coordinates: e\n        };\n      },\n      LineString: function (t) {\n        for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {\n          var r = n[i];\n          e.push(pi.coordinate.call(this, r));\n        }\n        return {\n          type: \"LineString\",\n          coordinates: e\n        };\n      },\n      MultiLineString: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = pi.LineString.call(this, i);\n          e.push(r.coordinates);\n        }\n        return {\n          type: \"MultiLineString\",\n          coordinates: e\n        };\n      },\n      Polygon: function (t) {\n        var e = [],\n          n = pi.LineString.call(this, t._shell);\n        e.push(n.coordinates);\n        for (var i = 0; i < t._holes.length; ++i) {\n          var r = t._holes[i],\n            s = pi.LineString.call(this, r);\n          e.push(s.coordinates);\n        }\n        return {\n          type: \"Polygon\",\n          coordinates: e\n        };\n      },\n      MultiPolygon: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = pi.Polygon.call(this, i);\n          e.push(r.coordinates);\n        }\n        return {\n          type: \"MultiPolygon\",\n          coordinates: e\n        };\n      },\n      GeometryCollection: function (t) {\n        for (var e = [], n = 0; n < t._geometries.length; ++n) {\n          var i = t._geometries[n],\n            r = i.getGeometryType();\n          e.push(pi[r].call(this, i));\n        }\n        return {\n          type: \"GeometryCollection\",\n          geometries: e\n        };\n      }\n    };\n  return {\n    BufferOp: vi,\n    GeoJSONReader: function () {\n      return s(function t(e) {\n        n(this, t), this.parser = new di(e || new ae());\n      }, [{\n        key: \"read\",\n        value: function (t) {\n          return this.parser.read(t);\n        }\n      }]);\n    }(),\n    GeoJSONWriter: function () {\n      return s(function t() {\n        n(this, t), this.parser = new di(this.geometryFactory);\n      }, [{\n        key: \"write\",\n        value: function (t) {\n          return this.parser.write(t);\n        }\n      }]);\n    }()\n  };\n});\n//# sourceMappingURL=jsts.min.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}