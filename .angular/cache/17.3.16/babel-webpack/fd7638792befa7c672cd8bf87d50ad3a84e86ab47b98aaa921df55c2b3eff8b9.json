{"ast":null,"code":"// index.ts\nimport { bbox as calcBbox } from \"@turf/bbox\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { booleanPointOnLine as isPointOnLine } from \"@turf/boolean-point-on-line\";\nimport { getGeom } from \"@turf/invariant\";\nfunction booleanContains(feature1, feature2) {\n  const geom1 = getGeom(feature1);\n  const geom2 = getGeom(feature2);\n  const type1 = geom1.type;\n  const type2 = geom2.type;\n  const coords1 = geom1.coordinates;\n  const coords2 = geom2.coordinates;\n  switch (type1) {\n    case \"Point\":\n      switch (type2) {\n        case \"Point\":\n          return compareCoords(coords1, coords2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"Point\":\n          return isPointInMultiPoint(geom1, geom2);\n        case \"MultiPoint\":\n          return isMultiPointInMultiPoint(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"LineString\":\n      switch (type2) {\n        case \"Point\":\n          return isPointOnLine(geom2, geom1, {\n            ignoreEndVertices: true\n          });\n        case \"LineString\":\n          return isLineOnLine(geom1, geom2);\n        case \"MultiPoint\":\n          return isMultiPointOnLine(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"Polygon\":\n      switch (type2) {\n        case \"Point\":\n          return booleanPointInPolygon(geom2, geom1, {\n            ignoreBoundary: true\n          });\n        case \"LineString\":\n          return isLineInPoly(geom1, geom2);\n        case \"Polygon\":\n          return isPolyInPoly(geom1, geom2);\n        case \"MultiPoint\":\n          return isMultiPointInPoly(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"MultiPolygon\":\n      switch (type2) {\n        case \"Polygon\":\n          return isPolygonInMultiPolygon(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\nfunction isPolygonInMultiPolygon(multiPolygon, polygon) {\n  return multiPolygon.coordinates.some(coords => isPolyInPoly({\n    type: \"Polygon\",\n    coordinates: coords\n  }, polygon));\n}\nfunction isPointInMultiPoint(multiPoint, pt) {\n  let i;\n  let output = false;\n  for (i = 0; i < multiPoint.coordinates.length; i++) {\n    if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n      output = true;\n      break;\n    }\n  }\n  return output;\n}\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n  for (const coord2 of multiPoint2.coordinates) {\n    let matchFound = false;\n    for (const coord1 of multiPoint1.coordinates) {\n      if (compareCoords(coord2, coord1)) {\n        matchFound = true;\n        break;\n      }\n    }\n    if (!matchFound) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isMultiPointOnLine(lineString, multiPoint) {\n  let haveFoundInteriorPoint = false;\n  for (const coord of multiPoint.coordinates) {\n    if (isPointOnLine(coord, lineString, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n    if (!isPointOnLine(coord, lineString)) {\n      return false;\n    }\n  }\n  if (haveFoundInteriorPoint) {\n    return true;\n  }\n  return false;\n}\nfunction isMultiPointInPoly(polygon, multiPoint) {\n  for (const coord of multiPoint.coordinates) {\n    if (!booleanPointInPolygon(coord, polygon, {\n      ignoreBoundary: true\n    })) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n  let haveFoundInteriorPoint = false;\n  for (const coords of lineString2.coordinates) {\n    if (isPointOnLine({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: true\n    })) {\n      haveFoundInteriorPoint = true;\n    }\n    if (!isPointOnLine({\n      type: \"Point\",\n      coordinates: coords\n    }, lineString1, {\n      ignoreEndVertices: false\n    })) {\n      return false;\n    }\n  }\n  return haveFoundInteriorPoint;\n}\nfunction isLineInPoly(polygon, linestring) {\n  let output = false;\n  let i = 0;\n  const polyBbox = calcBbox(polygon);\n  const lineBbox = calcBbox(linestring);\n  if (!doBBoxOverlap(polyBbox, lineBbox)) {\n    return false;\n  }\n  for (i; i < linestring.coordinates.length - 1; i++) {\n    const midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n    if (booleanPointInPolygon({\n      type: \"Point\",\n      coordinates: midPoint\n    }, polygon, {\n      ignoreBoundary: true\n    })) {\n      output = true;\n      break;\n    }\n  }\n  return output;\n}\nfunction isPolyInPoly(feature1, feature2) {\n  if (feature1.type === \"Feature\" && feature1.geometry === null) {\n    return false;\n  }\n  if (feature2.type === \"Feature\" && feature2.geometry === null) {\n    return false;\n  }\n  const poly1Bbox = calcBbox(feature1);\n  const poly2Bbox = calcBbox(feature2);\n  if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n    return false;\n  }\n  const coords = getGeom(feature2).coordinates;\n  for (const ring of coords) {\n    for (const coord of ring) {\n      if (!booleanPointInPolygon(coord, feature1)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction doBBoxOverlap(bbox1, bbox2) {\n  if (bbox1[0] > bbox2[0]) {\n    return false;\n  }\n  if (bbox1[2] < bbox2[2]) {\n    return false;\n  }\n  if (bbox1[1] > bbox2[1]) {\n    return false;\n  }\n  if (bbox1[3] < bbox2[3]) {\n    return false;\n  }\n  return true;\n}\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nfunction getMidpoint(pair1, pair2) {\n  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nvar turf_boolean_contains_default = booleanContains;\nexport { booleanContains, compareCoords, turf_boolean_contains_default as default, doBBoxOverlap, getMidpoint, isLineInPoly, isLineOnLine, isMultiPointInMultiPoint, isMultiPointInPoly, isMultiPointOnLine, isPointInMultiPoint, isPolyInPoly, isPolygonInMultiPolygon };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}