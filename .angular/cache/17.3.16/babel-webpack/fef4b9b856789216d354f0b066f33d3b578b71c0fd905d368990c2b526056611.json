{"ast":null,"code":"// index.ts\nimport { centerMean } from \"@turf/center-mean\";\nimport { distance } from \"@turf/distance\";\nimport { centroid } from \"@turf/centroid\";\nimport { isNumber, point, isObject, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nfunction centerMedian(features, options = {}) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var counter = options.counter || 10;\n  if (!isNumber(counter)) throw new Error(\"counter must be a number\");\n  var weightTerm = options.weight;\n  var meanCenter = centerMean(features, {\n    weight: options.weight\n  });\n  var centroids = featureCollection([]);\n  featureEach(features, function (feature) {\n    var _a;\n    centroids.features.push(centroid(feature, {\n      properties: {\n        weight: (_a = feature.properties) == null ? void 0 : _a[weightTerm]\n      }\n    }));\n  });\n  const properties = {\n    tolerance: options.tolerance,\n    medianCandidates: []\n  };\n  return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);\n}\nfunction findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {\n  var tolerance = properties.tolerance || 1e-3;\n  var candidateXsum = 0;\n  var candidateYsum = 0;\n  var kSum = 0;\n  var centroidCount = 0;\n  featureEach(centroids, function (theCentroid) {\n    var _a;\n    var weightValue = (_a = theCentroid.properties) == null ? void 0 : _a.weight;\n    var weight = weightValue === void 0 || weightValue === null ? 1 : weightValue;\n    weight = Number(weight);\n    if (!isNumber(weight)) throw new Error(\"weight value must be a number\");\n    if (weight > 0) {\n      centroidCount += 1;\n      var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);\n      if (distanceFromCandidate === 0) distanceFromCandidate = 1;\n      var k = weight / distanceFromCandidate;\n      candidateXsum += theCentroid.geometry.coordinates[0] * k;\n      candidateYsum += theCentroid.geometry.coordinates[1] * k;\n      kSum += k;\n    }\n  });\n  if (centroidCount < 1) throw new Error(\"no features to measure\");\n  var candidateX = candidateXsum / kSum;\n  var candidateY = candidateYsum / kSum;\n  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {\n    return point([candidateX, candidateY], {\n      medianCandidates: properties.medianCandidates\n    });\n  } else {\n    properties.medianCandidates.push([candidateX, candidateY]);\n    return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);\n  }\n}\nvar turf_center_median_default = centerMedian;\nexport { centerMedian, turf_center_median_default as default };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}